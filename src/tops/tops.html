<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
</head>


<body>












<div style="text-align: center;"><big><big><span style="font-weight: bold;">TOPS Solver Component</span></big></big>

      

    <br>












</div>












<br>












The <a href="http://www.tops-scidac.org">TOPS</a> Solver Component (TSC) is a <a href="http://www.llnl.gov/CASC/components">Babel/SIDL</a> based 
<a href="http://www.cca-forum.org">CCA</a>
compliant HPC software component (henceforth shortened to CCA
component). It provides direct access to virtually all of the
TOPS (as well as many other) linear and nonlinear algebraic solvers including geometric and algebraic multigrid (a
partial list may be found <a href="http://www.mcs.anl.gov/petsc/petsc-as/documentation/linearsolvertable.html">here</a>).<br>












<br>









TOPS solvers may be used in three distinct ways:<br>









<ol>









  <li>as a solver component (TSC),</li>









  <li>through a common C, C++, Fortran, Python language binding (<a href="http://www.mcs.anl.gov/petsc">PETSc</a>),</li>









  <li>through each package's individual binding.</li>









</ol>









For all three approaches first <a href="topsinstaller.html">download and install</a> the TOPS software. (These pages ONLY describe using the TOPS Solver Components, consult <a href="http://www.mcs.anl.gov/petsc">PETSc</a> or each package directly to see how to use them as traditional software libraries).<br>









<div style="text-align: center;"><big><span style="font-weight: bold;"></span></big><br>









</div>












The application developer interacts with the&nbsp;
TSC by constructing a CCA component that implements the <a href="tops.sidl.html">TOPS.System</a>
interface and one or more problem specific interfaces. This&nbsp;System
component will define the algebraic system to be
solved. <br>



<br>



The TSC and the System component can be combined using a <a href="examples/cxx/ex1/ex1.cxx">traditional programming language</a>, a <a href="examples/cxx/ex1/Ex1_rc">component scripting language</a> or a component GUI&nbsp;<a href="topsccafe.html">(see demo)</a> such as <a href="http://www.cca-forum.org/ccafe/">ccaffeine</a>. The TSC and the&nbsp;System component then collaborate
to solve one or more algebraic problems. Complex applications will likely
also couple several additional CCA components, see the <a href="http://cca-forum.org/tutorials/">CCA tutorials</a> for more information on writing applications using CCA components. <br>



<br>



The <a href="topsgenerator.html">TOPS component generator</a> can be used to generate the SIDL for your problem and all the boilerplate code needed to use it as a CCA component.<br>












<br>



<div style="text-align: center;"><big><big><span style="font-weight: bold;">TOPS Solver Component Tutorial</span></big></big><br>



</div>








<br>









<ul>









  <li>Structured grids<span style="font-weight: bold;"></span></li>









  
  
  
  
  
  
  
  
  
  <ul>









    <li><a href="#Example_1:">nonlinear, single component</a></li>









    <li><a href="#Example_2:">nonlinear, multi-componen</a>t</li>









    <li><a href="#Example_3:">linear, single component, three dimensions</a></li>









  
  
  
  
  
  
  
  
  
  </ul>









  <li>Unstructured grids</li>









  
  
  
  
  
  
  
  
  
  <ul>









    <li>l<a href="#Example_4:">inear, single component</a></li>









  
  
  
  
  
  
  
  
  
  </ul>









</ul>





Installation:<br>






<br>






If you <span style="font-weight: bold;">did not use</span> the TOPSInstaller to build the TSC, then configure PETSc with <span style="font-family: monospace; color: rgb(51, 51, 255);">config/configure.py --with-shared=1
--with-babel-dir=dir --with-ccafe-dir=dir --with-clanguage=cxx</span> (any other options you desire).
Then do <span style="font-family: monospace; color: rgb(51, 51, 255);">make all test.<br>

<br>

</span>To compile and run the first example: &nbsp;<span style="font-family: monospace; color: rgb(51, 51, 255);">cd&nbsp;src/tops/examples/cxx/ex1</span> and do <span style="font-family: monospace; color: rgb(51, 51, 255);">make server-cxx test-cca<br>

<br>

</span>



&nbsp;



<span style="font-weight: bold;"><a name="Example_1:"></a>Example 1</span>:<br>






<br>












The first is the classic Bratu problem&nbsp;discretized with
finite differences on a regular grid in two dimensions. The application
code consists of the SIDL definition of&nbsp;the&nbsp;System component

  (in <a href="examples/cxx/ex1/ex1.sidl.html">ex1.sidl</a>)<br>












<br>











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
package Ex1 version 0.0.0 {class System implements-all TOPS.System.System, TOPS.System.Compute.Residual {}}</span><span style="color: rgb(51, 51, 255); font-family: monospace;">

</span><br style="color: rgb(51, 51, 255); font-family: monospace;">












<br>












and the code that defines the nonlinear equation (in <a href="examples/cxx/ex1/server/cxx/Ex1_System_Impl.cxx.html#Ex1.System.computeResidual">Ex1_System_Impl.cxx</a>)<br>












<br>











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
void
Ex1::System_impl::computeResidual (
  /* in */ ::sidl::array</span><double><span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;"> x,
  /* in */ ::sidl::array</span><double><span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;"> f) 
throw (){
  </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">// DO-NOT-DELETE splicer.begin(Ex1.System.computeResidual)</span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">&nbsp;TOPS::Structured::Solver solver = this-&gt;solver;
  </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">int xs = f.lower(0);            // first grid point in X and Y directions on this process
  </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">int ys = f.lower(1);
  </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">int xm = f.length(0);       // number of local grid points in X and Y directions on this process
  </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">int ym = f.length(1);</span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">int i,j;
  </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">int mx = solver.getDimensionX();
  </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">int my = solver.getDimensionY();

  </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">double hx     = 1.0/(double)(mx-1);
  </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">double hy     = 1.0/(double)(my-1);
  <br>











double sc     = hx*hy;
  <br>











double hxdhy  = hx/hy; 
  <br>











double hydhx  = hy/hx;
 
  </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">/*
     Compute function over the locally owned part of the grid
  */
  </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">&nbsp; for (j=ys; j&lt;ys+ym; j++) {<br>











&nbsp;&nbsp;&nbsp; for (i=xs; i&lt;xs+xm; i++) {<br>











&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (i == 0 || j == 0 || i == mx-1 || j == my-1) {<br>











&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f.set(i,j,x.get(i,j));<br>











&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br>











&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double u&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = x.get(i,j);<br>











&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double uxx&nbsp;&nbsp;&nbsp;&nbsp; = (2.0*u - x.get(i-1,j) - x.get(i+1,j))*hydhx;<br>











&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double uyy&nbsp;&nbsp;&nbsp;&nbsp; = (2.0*u - x.get(i,j-1) - x.get(i,j+1))*hxdhy;<br>











&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f.set(i,j,uxx + uyy - sc*exp(u));<br>











&nbsp; &nbsp; &nbsp; }<br>











&nbsp;&nbsp;&nbsp; }<br>











&nbsp; }&nbsp; <br>











&nbsp; // DO-NOT-DELETE splicer.end(Ex1.System.computeResidual)<br>











}</span><span style="font-style: italic; color: rgb(51, 51, 255);"></span><br>











<br>









<span style="font-weight: bold;"><a name="Example_2:"></a>Example 2:</span><br>









<br>











The next example is a version of the driven cavity; this is a
multicomponent PDE again solved on a structured grid.&nbsp;<br>











First tell the Tops.Solver that it is solving a multicomponent problem with four components (in <a href="examples/cxx/ex2/server/cxx/Ex2_System_Impl.cxx.html#Ex2.System.initializeOnce">Ex2_System_Impl.cxx</a>)<br>











<br>











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">void ex2::system_impl::initializeOnce throw (){ </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">//&nbsp;</span></double></double><span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">DO-NOT-DELETE splicer.begin(Ex2.System.initializeOnce)</span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">











<double><double><span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">this-&gt;</span><ys +ym="" j="" {="" for="" (i="xs;" i=""><xs +xm="" if="" (i="=" 0="" i="" mx-1="" |="" j="=" my-1="" f.set(i,j,x.get(i,j="" else="" u="x.get(i,j);" uxx="(2.0*u" x.get(i-1,j="" x.get(i+1,j))*hydhx="" double="" x.get(i,j-1="" x.get(i,j+1))*hxdhy="" f.set(i,j,uxx="" +="" uyy="(2.0*u" -="" sc*exp(u="" splicer.end(ex1.system.computeresidual="" }="" next="" driven="" cavity="" sidl="" identical="" example="" above="" difference="" in="" component="" implementation="" simply="" routine="" to="" tell="" the="" tops.solver="" that="" it="" is="" solving="" a="" multicomponent="" problem="" with="" four="" components="" void="" ex2::system_impl::initializeonce="" throw="" (="" {="" do-not-delete="" splicer.begin(ex2.system.initializeonce="" this=""><span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">solver.setBlockSize(4);
  </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">// DO-NOT-DELETE splicer.end(Ex2.System.initializeOnce)
</span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">}</span><br>











<br>











&nbsp;and define several PDE parameters (in <a href="examples/cxx/ex2/server/cxx/Ex2_System_Impl.hxx.html#Ex2.System._implementation">Ex2_System_Impl.hxx</a>)<br>











<br>











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">// DO-NOT-DELETE splicer.begin(Ex2.System._implementation)
    </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">TOPS::Structured::Solver solver;
    </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">double
&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grashof, prandtl, lid; </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">// DO-NOT-DELETE splicer.end(Ex2.System._implementation)

   </span><br style="font-style: italic;">











<br>











initialize them (</xs></ys></double></double>in <a href="examples/cxx/ex2/server/cxx/Ex2_System_Impl.cxx.html#Ex2.System._ctor">Ex2_System_Impl.cxx</a>)<br>











<br>











<double><double><ys +ym="" j="" {="" for="" (i="xs;" i=""><xs +xm="" if="" (i="=" 0="" i="" mx-1="" |="" j="=" my-1="" f.set(i,j,x.get(i,j="" else="" u="x.get(i,j);" uxx="(2.0*u" x.get(i-1,j="" x.get(i+1,j))*hydhx="" double="" x.get(i,j-1="" x.get(i,j+1))*hxdhy="" f.set(i,j,uxx="" +="" uyy="(2.0*u" -="" sc*exp(u="" splicer.end(ex1.system.computeresidual="" }="" next="" driven="" cavity="" sidl="" identical="" example="" above="" difference="" in="" component="" implementation="" simply="" routine="" to="" tell="" the="" tops.solver="" that="" it="" is="" solving="" a="" multicomponent="" problem="" with="" four="" components="" void="" ex2::system_impl::initializeonce="" throw="" (="" {="" do-not-delete="" splicer.begin(ex2.system.initializeonce="" this=""><span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">void Ex2::System_impl::_ctor() {
     </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">// DO-NOT-DELETE splicer.begin(Ex2.System._ctor)</span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">this-&gt;lid     = 0.0;
     this-&gt;prandtl = 1.0;
     this-&gt;grashof = 1.0;
     </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">











<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">// DO-NOT-DELETE splicer.end(Ex2.System._ctor)
   }</span><br>











<br>











One can also provide a nonzero initial guess to the solver by
inheriting from&nbsp;TOPS.SystemComputeInitialGuess using SIDL such as (in <a href="examples/cxx/ex2/ex2.sidl.html">Ex2.sidl</a>)<br>











<br>











</xs></ys></double></double><span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">package
Ex2 version 0.0.0 {class System implements-all TOPS.System.System,
TOPS.System.Compute.Residual, TOPS.System.Compute.InitialGuess {}}</span><span style="color: rgb(51, 51, 255); font-family: monospace;">

</span><double><double><ys +ym="" j="" {="" for="" (i="xs;" i=""><xs +xm="" if="" (i="=" 0="" i="" mx-1="" |="" j="=" my-1="" f.set(i,j,x.get(i,j="" else="" u="x.get(i,j);" uxx="(2.0*u" x.get(i-1,j="" x.get(i+1,j))*hydhx="" double="" x.get(i,j-1="" x.get(i,j+1))*hxdhy="" f.set(i,j,uxx="" +="" uyy="(2.0*u" -="" sc*exp(u="" splicer.end(ex1.system.computeresidual="" }="" next="" driven="" cavity="" sidl="" identical="" example="" above="" difference="" in="" component="" implementation="" simply="" routine="" to="" tell="" the="" tops.solver="" that="" it="" is="" solving="" a="" multicomponent="" problem="" with="" four="" components="" void="" ex2::system_impl::initializeonce="" throw="" (="" {="" do-not-delete="" splicer.begin(ex2.system.initializeonce="" this=""><span style="font-family: monospace;">&nbsp;</span><br>











<br>











and providing code like (in <a href="examples/cxx/ex2/server/cxx/Ex2_System_Impl.cxx.html#Ex2.System.computeInitialGuess">Ex2_System_Impl.cxx</a>)<br>











<br>











<span style="color: rgb(51, 51, 255); font-family: monospace;">void Ex2::System_impl::computeInitialGuess (&nbsp;/* in */ ::sidl::array&lt;double&gt; x ) throw () {</span><br style="color: rgb(51, 51, 255); font-family: monospace;">











<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; // DO-NOT-DELETE splicer.begin(Ex2.System.computeInitialGuess)</span><br style="color: rgb(51, 51, 255); font-family: monospace;">











<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; /*</span><br style="color: rgb(51, 51, 255); font-family: monospace;">











<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp; Compute initial guess over the locally owned part of the grid</span><br style="color: rgb(51, 51, 255); font-family: monospace;">











<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp; Initial condition is motionless fluid and equilibrium temperature</span><br style="color: rgb(51, 51, 255); font-family: monospace;">











<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; */</span><br style="color: rgb(51, 51, 255); font-family: monospace;">











<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; TOPS::Structured::Solver solver = this-&gt;solver;</span><br style="color: rgb(51, 51, 255); font-family: monospace;">











<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; int xs = x.lower(1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // first grid point in X and Y directions on this process</span><br style="color: rgb(51, 51, 255); font-family: monospace;">











<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; int ys = x.lower(2);</span><br style="color: rgb(51, 51, 255); font-family: monospace;">











<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp;
int xm = x.length(1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // number
of local grid points in X and Y directions on this process</span><br style="color: rgb(51, 51, 255); font-family: monospace;">











<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; int ym = x.length(2);</span><br style="color: rgb(51, 51, 255); font-family: monospace;">











<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; int i,j;</span><br style="color: rgb(51, 51, 255); font-family: monospace;">











<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; double dx&nbsp; = 1.0/(solver.getDimensionX()-1);</span><br style="color: rgb(51, 51, 255); font-family: monospace;">











<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; double grashof = this-&gt;grashof;&nbsp; </span><br style="color: rgb(51, 51, 255); font-family: monospace;">











<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; for (j=ys; j&lt;ys+ym; j++) {</span><br style="color: rgb(51, 51, 255); font-family: monospace;">











<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp;&nbsp;&nbsp; for (i=xs; i&lt;xs+xm; i++) {</span><br style="color: rgb(51, 51, 255); font-family: monospace;">











<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x.set(U,i,j,0.0);</span><br style="color: rgb(51, 51, 255); font-family: monospace;">











<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x.set(V,i,j,0.0);</span><br style="color: rgb(51, 51, 255); font-family: monospace;">











<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x.set(OMEGA,i,j,0.0);</span><br style="color: rgb(51, 51, 255); font-family: monospace;">











<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x.set(TEMP,i,j,(grashof&gt;0)*i*dx);</span><br style="color: rgb(51, 51, 255); font-family: monospace;">











<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp;&nbsp;&nbsp; }</span><br style="color: rgb(51, 51, 255); font-family: monospace;">











<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; }</span><br style="color: rgb(51, 51, 255); font-family: monospace;">











<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; // DO-NOT-DELETE splicer.end(Ex2.System.computeInitialGuess)</span><br style="color: rgb(51, 51, 255); font-family: monospace;">











<span style="color: rgb(51, 51, 255); font-family: monospace;">}</span><br>











<br>









<span style="font-weight: bold;"><a name="Example_3:"></a>Example 3:</span><br>









<br>











A simple Poisson problem in 3 dimensions again on a
structured grid, with zero Dirichlet boundary conditions. The SIDL code
is (in <a href="examples/cxx/ex3/ex3.sidl.html">ex3.sidl</a>)<br>











<br>











<span style="color: rgb(51, 51, 255); font-family: monospace;">package Ex3 version 0.0.0 {</span><span style="color: rgb(51, 51, 255); font-family: monospace;">class System implements-all TOPS.System.System, TOPS.System.Compute.Matrix, TOPS.System.Compute.RightHandSide {</span><span style="color: rgb(51, 51, 255); font-family: monospace;">}</span><span style="color: rgb(51, 51, 255);"><span style="font-family: monospace;">}</span><br style="font-family: monospace;">









<br>









</span></xs></ys></double></double>The code that defines the matrix is given by (in <a href="examples/cxx/ex3/server/cxx/Ex3_System_Impl.cxx.html#Ex3.System.computeMatrix">Ex3_System_Impl.cxx</a>)<br>









<double><double><ys +ym="" j="" {="" for="" (i="xs;" i=""><xs +xm="" if="" (i="=" 0="" i="" mx-1="" |="" j="=" my-1="" f.set(i,j,x.get(i,j="" else="" u="x.get(i,j);" uxx="(2.0*u" x.get(i-1,j="" x.get(i+1,j))*hydhx="" double="" x.get(i,j-1="" x.get(i,j+1))*hxdhy="" f.set(i,j,uxx="" +="" uyy="(2.0*u" -="" sc*exp(u="" splicer.end(ex1.system.computeresidual="" }="" next="" driven="" cavity="" sidl="" identical="" example="" above="" difference="" in="" component="" implementation="" simply="" routine="" to="" tell="" the="" tops.solver="" that="" it="" is="" solving="" a="" multicomponent="" problem="" with="" four="" components="" void="" ex2::system_impl::initializeonce="" throw="" (="" {="" do-not-delete="" splicer.begin(ex2.system.initializeonce="" this=""><span style="color: rgb(51, 51, 255);"></span>

<span style="color: rgb(255, 0, 0);"><span style="color: rgb(0, 0, 0);"></span><br>









<span style="font-family: monospace; color: rgb(51, 51, 255);">void Ex3::System_impl::computeMatrix (/* in */ ::TOPS::Matrix J ) throw () {</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; // DO-NOT-DELETE splicer.begin(Ex3.System.computeMatrix)</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; TOPS::Structured::Matrix B = (TOPS::MatrixStructured)J;</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; TOPS::Structured::Solver solver = this-&gt;solver;</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; int xs = B.lower(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // first grid point in X and Y directions on this process</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; int ys = B.lower(1);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; int zs = B.lower(2);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp;
int xm = B.length(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // number of
local grid points in X and Y directions on this process</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; int ym = B.length(1);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; int zm = B.length(2);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; int i,j,k;</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; int mx = solver.getDimensionX();</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; int my = solver.getDimensionY();</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; int mz = solver.getDimensionZ();</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; double hx&nbsp;&nbsp;&nbsp;&nbsp; = 1.0/(double)(mx-1);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; double hy&nbsp;&nbsp;&nbsp;&nbsp; = 1.0/(double)(my-1);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; double hz&nbsp;&nbsp;&nbsp;&nbsp; = 1.0/(double)(mz-1);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; double sc&nbsp;&nbsp;&nbsp;&nbsp; = hx*hy*hz;</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; double hxhydhz&nbsp; = hx*hy/hz; </span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; double hyhzdhx&nbsp; = hy*hz/hx;</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; double hxhzdhy&nbsp; = hx*hz/hy;</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp;</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; /*</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp;&nbsp;&nbsp;&nbsp; Compute part of matrix over the locally owned part of the grid</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; */</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; double d = 2.0*(hxhydhz + hxhzdhy + hyhzdhx);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; sidl::array&lt;double&gt; dd = sidl::array&lt;double&gt;::create1d(1,&amp;d);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; double r[7];</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; r[0] = r[6] = -hxhydhz;</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; r[1] = r[5] = -hxhzdhy;</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; r[2] = r[4] = -hyhzdhx;</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; r[3] = 2.0*(hxhydhz + hxhzdhy + hyhzdhx);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; sidl::array&lt;double&gt; rr = sidl::array&lt;double&gt;::create1d(7,r);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; for (k=zs; k&lt;zs+zm; k++) {</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp;&nbsp;&nbsp; for (j=ys; j&lt;ys+ym; j++) {</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i=xs; i&lt;xs+xm; i++) {</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; if (i==0 || j==0 || k==0 || i==mx-1 || j==my-1 || k==mz-1){</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B.set(i,j,k,dd); // diagonal entry</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B.set(i,j,k,rr);&nbsp;&nbsp; // seven point stencil</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp;&nbsp;&nbsp; }</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; }</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; // DO-NOT-DELETE splicer.end(Ex3.System.computeMatrix)</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">}</span><br>









<br>









<span style="color: rgb(0, 0, 0);">The code that computes the right hand side is given by (in <a href="examples/cxx/ex3/server/cxx/Ex3_System_Impl.cxx.html#Ex3.System.computeRightHandSide">Ex3_System_Impl.cxx</a>)<br>









<br>









<span style="font-family: monospace; color: rgb(51, 51, 255);">void Ex3::System_impl::computeRightHandSide (/* in */ ::sidl::array&lt;double&gt; b ) throw () {</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; // DO-NOT-DELETE splicer.begin(Ex3.System.computeRightHandSide)</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; TOPS::Structured::Solver solver = this-&gt;solver;</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; int xs = b.lower(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // first grid point in X and Y directions on this process</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; int ys = b.lower(1);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; int zs = b.lower(2);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp;
int xm = b.length(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // number of
local grid points in X and Y directions on this process</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; int ym = b.length(1);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; int zm = b.length(2);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; int i,j,k;</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; int mx = solver.getDimensionX();</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; int my = solver.getDimensionY();</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; int mz = solver.getDimensionZ();</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; double hx&nbsp;&nbsp;&nbsp;&nbsp; = 1.0/(double)(mx-1);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; double hy&nbsp;&nbsp;&nbsp;&nbsp; = 1.0/(double)(my-1);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; double hz&nbsp;&nbsp;&nbsp;&nbsp; = 1.0/(double)(mz-1);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; double sc&nbsp;&nbsp;&nbsp;&nbsp; = hx*hy*hz;</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp;</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; /*</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp;&nbsp;&nbsp;&nbsp; Compute right hand side over the locally owned part of the grid</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; */</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; for (k=zs; k&lt;zs+zm; k++) {</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp;&nbsp;&nbsp; for (j=ys; j&lt;ys+ym; j++) {</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i=xs; i&lt;xs+xm; i++) {</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (i == 0 || j == 0 || i == mx-1 || j == my-1 || k == 0 || k == mz-1) {</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b.set(i,j,k,0.0);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b.set(i,j,k,sc);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp;&nbsp;&nbsp; }</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; }&nbsp; </span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; // DO-NOT-DELETE splicer.end(Ex3.System.computeRightHandSide)</span><br style="font-family: monospace; color: rgb(51, 51, 255);">









<span style="font-family: monospace;"><span style="color: rgb(51, 51, 255);">}</span><br>









<br>









</span><big style="font-weight: bold;"><small><a name="Example_4:"></a>Example 4:</small><br>







<br>







</big></span></span></xs></ys></double></double><span style="color: rgb(255, 0, 0);"><span style="color: rgb(0, 0, 0);">Handling
algebraic systems that arise from unstructured grids or any
unstructured data structure is generally orders of magnitude more
difficult than from structured grids. This is largely due to needing to
manage the (problem specific) (for example, grid) data that is used to
evaluate functions and matrices; the SciDAC Terascale Simulation Tools
and Technologies (<a href="http://www.tstt-scidac.org/">TSTT</a>) ISIC
is responsible for developing software for this portion of the
application, thus the interface for the algebraic solvers can be very
small.<br>







<br>







Up front, the user indicates the ghost degrees of freedom needed by
each process, then (as with the structured grid case) the solver
requests local calculations from the TOPS.System interfaces. The needed
ghost nodes is computed by the TSTT component then provided to the
TOPS.Solver by, for example </span></span><span style="color: rgb(255, 0, 0);"><span style="color: rgb(0, 0, 0);">(in <a href="examples/cxx/ex4/server/cxx/Ex4_System_Impl.cxx.html#Ex4.System.initializeOnce">Ex4_System_Impl.cxx</a>)</span></span><br>







<span style="color: rgb(255, 0, 0);"><span style="color: rgb(0, 0, 0);"><br>







<span style="font-family: monospace; color: rgb(51, 51, 255);">void Ex4::System_impl::initializeOnce () throw () </span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">{</span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; // DO-NOT-DELETE splicer.begin(Ex4.System.initializeOnce)</span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; this-&gt;solver.setLocalSize(this-&gt;n);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; int rank; MPI_Comm_rank(MPI_COMM_WORLD,&amp;rank);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; int size; MPI_Comm_rank(MPI_COMM_WORLD,&amp;size);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; int start = this-&gt;n*rank;</span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; int cnt = 0,g[2];</span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; if (rank) g[cnt++] = start-1;</span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; if (rank == size-1) g[cnt++] = start+this-&gt;n;</span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; this-&gt;solver.setGhostPoints(sidl::array&lt;int&gt;::create1d(cnt,g));</span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; // DO-NOT-DELETE splicer.end(Ex4.System.initializeOnce)</span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">}<br>







<br>







</span></span></span><span style="color: rgb(255, 0, 0);"><span style="color: rgb(0, 0, 0);">For
simplicity we are using a one dimensional grid decomposed into slices,
those each process has one or two ghost points (when run on one process
there are no ghost points). The problem, again to make the code
trivial, is the one dimensional Possion problem.<br>







<br>







When the nonlinear residual or right hand side is requested a "ghosted
array" is passed into and out of the application method thus the user
does <span style="font-weight: bold;">not </span>to do the MPI communication directly.<br>







<br>







<span style="font-family: monospace; color: rgb(51, 51, 255);">void Ex4::System_impl::computeRightHandSide (/* in */ ::sidl::array&lt;double&gt; b ) throw () </span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">{</span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; // DO-NOT-DELETE splicer.begin(Ex4.System.computeRightHandSide)</span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; int i,nlocal = b.length(0);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; int rank; MPI_Comm_rank(MPI_COMM_WORLD,&amp;rank);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; int size; MPI_Comm_rank(MPI_COMM_WORLD,&amp;size);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; // For a finite element discretization the local element contributions to the </span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; // ghost degrees of freedom would also be computed here. Skipped here.</span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; if (!rank) nlocal--;</span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; if (rank == size-1) nlocal--;</span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; for (i=0; i&lt;nlocal; i++) {</span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp;&nbsp;&nbsp; b.set(i,1.0);</span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; }</span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">&nbsp; // DO-NOT-DELETE splicer.end(Ex4.System.computeRightHandSide)</span><br style="font-family: monospace; color: rgb(51, 51, 255);">







<span style="font-family: monospace; color: rgb(51, 51, 255);">}<br>







<br>







</span></span></span><span style="color: rgb(255, 0, 0);"><span style="color: rgb(0, 0, 0);">The
matrix values are contributed by block, generally the entire
contribution for a single finite element is added in a single call.<br>







<br style="font-family: monospace;">







</span></span><span style="color: rgb(255, 0, 0);"><span style="color: rgb(0, 0, 0);"><span style="font-family: monospace; color: rgb(51, 51, 255);"></span><br>







<br>







</span></span><double><double><ys +ym="" j="" {="" for="" (i="xs;" i=""><xs +xm="" if="" (i="=" 0="" i="" mx-1="" |="" j="=" my-1="" f.set(i,j,x.get(i,j="" else="" u="x.get(i,j);" uxx="(2.0*u" x.get(i-1,j="" x.get(i+1,j))*hydhx="" double="" x.get(i,j-1="" x.get(i,j+1))*hxdhy="" f.set(i,j,uxx="" +="" uyy="(2.0*u" -="" sc*exp(u="" splicer.end(ex1.system.computeresidual="" }="" next="" driven="" cavity="" sidl="" identical="" example="" above="" difference="" in="" component="" implementation="" simply="" routine="" to="" tell="" the="" tops.solver="" that="" it="" is="" solving="" a="" multicomponent="" problem="" with="" four="" components="" void="" ex2::system_impl::initializeonce="" throw="" (="" {="" do-not-delete="" splicer.begin(ex2.system.initializeonce="" this=""><span style="color: rgb(255, 0, 0);"><span style="color: rgb(0, 0, 0);"><span style="font-family: monospace;"><br style="color: rgb(255, 0, 0);">









</span></span>

</span>




   
</xs></ys></double></double>
</body>
</html>
