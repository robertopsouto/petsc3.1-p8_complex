<center><a href="Meshing.hh">Actual source code: Meshing.hh</a></center><br>

<html>
<head>
<title></title>
<meta name="generator" content="c2html 0.9.5">
<meta name="date" content="2011-03-17T19:00:34+00:00">
</head>

<body bgcolor="#FFFFFF">
<pre width="80"><a name="line1">  1: </a>//Sieve-centric meshing utilities -- arbitrary dimensions
<a name="line2">  2: </a><font color="#A020F0">#include </font><font color="#666666">"Mesh.hh"</font><font color="#A020F0"></font>
<a name="line3">  3: </a><font color="#A020F0">#include </font><font color="#666666">"SieveAlgorithms.hh"</font><font color="#A020F0"></font>

<a name="line5">  5: </a>namespace ALE {

<a name="line7">  7: </a>  namespace Meshing {
<a name="line8">  8: </a>    namespace Geometry {
<a name="line9">  9: </a>
<a name="line10"> 10: </a>
<a name="line11"> 11: </a>      double * Meshing_FaceNormal(Obj&lt;Mesh&gt; m, Mesh::point_type f) {
<a name="line12"> 12: </a>        const ALE::Obj&lt;Mesh::sieve_type&gt; &amp; s = m-&gt;getSieve();
<a name="line13"> 13: </a>        int dim = m-&gt;getDimension();
<a name="line14"> 14: </a>        double normal[dim];
<a name="line15"> 15: </a>        <font color="#4169E1">for</font> (int i = 0; i &lt; dim; i++) {
<a name="line16"> 16: </a>          <font color="#4169E1">for</font> (int j = 0; j &lt; dim; j++) {
<a name="line17"> 17: </a>
<a name="line18"> 18: </a>          }
<a name="line19"> 19: </a>        }
<a name="line20"> 20: </a>      }
<a name="line21"> 21: </a>
<a name="line22"> 22: </a>      double CellVolume(ALE::Obj&lt;ALE::Mesh&gt; m, ALE::Mesh::point_type c) {  //returns the SIGNED cell volume
<a name="line23"> 23: </a>        int celldim = m-&gt;getDimension() - m-&gt;height(c);
<a name="line24"> 24: </a>        <font color="#4169E1">if</font> (m-&gt;depth(c) == 0) <font color="#4169E1">return</font> 0.;
<a name="line25"> 25: </a>        const double
<a name="line26"> 26: </a>      }

<a name="line28"> 28: </a>      bool InCircumcircle(ALE::Obj&lt;Mesh&gt; m, Mesh::point_type c, Mesh::point_type p) {
<a name="line29"> 29: </a>
<a name="line30"> 30: </a>      }
<a name="line31"> 31: </a>
<a name="line32"> 32: </a>      bool InCell(Obj&lt;Mesh&gt; m, Mesh:point_type c, Mesh::point_type p) {
<a name="line33"> 33: </a>        //express it in barycentric coordinates and <font color="#4169E1">do</font> the dumbest thing.. FOR NOW!
<a name="line34"> 34: </a>
<a name="line35"> 35: </a>      }

<a name="line37"> 37: </a>      double Circumcircle(Obj&lt;ALE::Mesh&gt; m, Mesh::point_type c, double * circumcenter) {
<a name="line38"> 38: </a>        //ok, to generalize this to n dimensions easily we are going to create an algorithm that iteratively finds the circumcenter
<a name="line39"> 39: </a>        //through a steepest-descent scheme on the circumcenter starting from the center of mass.
<a name="line40"> 40: </a>        //on each iteration:
<a name="line41"> 41: </a>        // d = (1/n)*sum_n(|p_n - c|^2)
<a name="line42"> 42: </a>        // c = c + sum_n((p_n - c)(|p_n - c|^2 - d)/(|p_n - c|^2)
<a name="line43"> 43: </a>        int dim = m-&gt;getDimension();
<a name="line44"> 44: </a>        double d, errdist;
<a name="line45"> 45: </a>        double * tmpcoords = m-&gt;restrict(m-&gt;getRealSection(<font color="#666666">"coordinates"</font>), c);
<a name="line46"> 46: </a>        <font color="#4169E1">for</font> (int iteration = 0; iteration &lt; 10; iteration++) {
<a name="line47"> 47: </a>          <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-comm(), <font color="#666666">"current radius: %f\n"</font>, d);
<a name="line48"> 48: </a>          <font color="#4169E1">for</font> (int vertex = 0; vertex &lt; dim+1; vertex++) {
<a name="line49"> 49: </a>
<a name="line50"> 50: </a>          }
<a name="line51"> 51: </a>        }
<a name="line52"> 52: </a>        double err = new double[dim];
<a name="line53"> 53: </a>        d = sqrt(d);
<a name="line54"> 54: </a>        delete err;
<a name="line55"> 55: </a>        <font color="#4169E1">return</font> d;
<a name="line56"> 56: </a>      }
<a name="line57"> 57: </a>    }
<a name="line58"> 58: </a><strong><font color="#FF0000">    ALE:</font></strong>:Mesh::point_type Meshing_ConeConstruct(ALE::Obj&lt;ALE::Mesh&gt; m, ALE::Mesh::point_type v, ALE::Mesh::point_type c, ALE::Mesh::point_type &amp; max_index){
<a name="line59"> 59: </a>      //pretty commenting
<a name="line60"> 60: </a><strong><font color="#FF0000">      std:</font></strong>:string a_string;
<a name="line61"> 61: </a>      const char * a;
<a name="line62"> 62: </a>      <font color="#4169E1">for</font> (int i = 0; i &lt; m-&gt;depth() - m-&gt;depth(c); i++) {
<a name="line63"> 63: </a>        a_string = a_string + <font color="#666666">"  "</font>;
<a name="line64"> 64: </a>      }
<a name="line65"> 65: </a>      a = a_string.c_str();
<a name="line66"> 66: </a>      //glue vertex v to the closure of c creating a simplex of dimension dim(c)+1 in the center.
<a name="line67"> 67: </a>      //<font color="#4169E1">return</font> the new simplex (which will be the new current_index-1 also)
<a name="line68"> 68: </a><strong><font color="#FF0000">      ALE:</font></strong>:Obj&lt;ALE::Mesh::sieve_type&gt; s = m-&gt;getSieve();
<a name="line69"> 69: </a><strong><font color="#FF0000">      ALE:</font></strong>:Obj&lt;ALE::Mesh::label_type&gt; depth = m-&gt;getLabel(<font color="#666666">"depth"</font>);
<a name="line70"> 70: </a>      //it is ok to create copies of all things in the closure of c with the same local sieve, then extend them all such that:
<a name="line71"> 71: </a>      // 1. the lowest dimensional ones have v in their cone as well
<a name="line72"> 72: </a>      // 2. the copies support their original
<a name="line73"> 73: </a>      //<font color="#4169E1">do</font> this through recursion: <font color="#4169E1">for</font> 3D one would add the volume based upon the face, then add the faces based upon the edges, recursing to add the edges
<a name="line74"> 74: </a>      <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"%sentered cone construct with vertex %d, cell %d\n"</font>, a, v, c);
<a name="line75"> 75: </a><strong><font color="#FF0000">      ALE:</font></strong>:Obj&lt;ALE::Mesh::sieve_type::supportSet&gt; current_join = s-&gt;nJoin(c, v, m-&gt;getDimension()); //base <font color="#4169E1">case</font>
<a name="line76"> 76: </a>      <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"%sTOTAL nJoin size: %d\n"</font>, a, current_join-&gt;size());
<a name="line77"> 77: </a>      <font color="#4169E1">if</font> (current_join-&gt;size() == 0) { //recurse
<a name="line78"> 78: </a>        //the created volume in the cone construction will always be covered by c
<a name="line79"> 79: </a>        max_index++;
<a name="line80"> 80: </a><strong><font color="#FF0000">        ALE:</font></strong>:Mesh::point_type constructed_index = max_index;
<a name="line81"> 81: </a>        s-&gt;addArrow(c, constructed_index);
<a name="line82"> 82: </a>        m-&gt;setValue(depth, constructed_index, m-&gt;depth(c) + 1);
<a name="line83"> 83: </a>        <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"%sInserting %d of depth %d into the mesh\n"</font>, a, constructed_index, m-&gt;depth(c) + 1);
<a name="line84"> 84: </a>        <font color="#4169E1">if</font> (m-&gt;depth(c) == 0) {
<a name="line85"> 85: </a>          //base <font color="#4169E1">case</font>: add an EDGE between this vertex and v as the simplest construction
<a name="line86"> 86: </a>          s-&gt;addArrow(v, constructed_index);
<a name="line87"> 87: </a>          <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"%s%d and %d are in the cone of %d\n"</font>, a,v, c, constructed_index);
<a name="line88"> 88: </a>          <font color="#4169E1">return</font> constructed_index;
<a name="line89"> 89: </a>        } <font color="#4169E1">else</font> { //recursive <font color="#4169E1">case</font>: add a face with surrounding edges
<a name="line90"> 90: </a><strong><font color="#FF0000">          ALE:</font></strong>:Mesh::sieve_type::supportSet current_cone; //the recursively-derived cone of the present thing
<a name="line91"> 91: </a><strong><font color="#FF0000">          ALE:</font></strong>:Mesh::sieve_type::supportSet tmp_cone; //used to avoid static
<a name="line92"> 92: </a><strong><font color="#FF0000">          ALE:</font></strong>:Obj&lt;ALE::Mesh::sieve_type::coneSequence&gt; cone_c = s-&gt;cone(c);
<a name="line93"> 93: </a><strong><font color="#FF0000">          ALE:</font></strong>:Mesh::sieve_type::coneSequence::iterator cc_iter = cone_c-&gt;begin();
<a name="line94"> 94: </a><strong><font color="#FF0000">          ALE:</font></strong>:Mesh::sieve_type::coneSequence::iterator cc_iter_end = cone_c-&gt;end();
<a name="line95"> 95: </a>          //because of STATIC everywhere operations on the sieve MUST be atomic
<a name="line96"> 96: </a>          <font color="#4169E1">while</font>(cc_iter != cc_iter_end) {
<a name="line97"> 97: </a>            <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"%s%d is in the cone of %d\n"</font>, a,*cc_iter, c);
<a name="line98"> 98: </a>            tmp_cone.insert(*cc_iter);
<a name="line99"> 99: </a>            cc_iter++;
<a name="line100">100: </a>          }
<a name="line101">101: </a><strong><font color="#FF0000">          ALE:</font></strong>:Mesh::sieve_type::supportSet::iterator curc_iter = tmp_cone.begin();
<a name="line102">102: </a><strong><font color="#FF0000">          ALE:</font></strong>:Mesh::sieve_type::supportSet::iterator curc_iter_end = tmp_cone.end();
<a name="line103">103: </a>          <font color="#4169E1">while</font> (curc_iter != curc_iter_end) {
<a name="line104">104: </a>            <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"%srecursing on %d\n"</font>, a,*curc_iter);
<a name="line105">105: </a><strong><font color="#FF0000">            ALE:</font></strong>:Mesh::point_type cc_point = Meshing_ConeConstruct(m, v, *curc_iter, max_index);
<a name="line106">106: </a>            current_cone.insert(cc_point);
<a name="line107">107: </a>            curc_iter++;
<a name="line108">108: </a>          }
<a name="line109">109: </a>          //<font color="#4169E1">for</font> all items in current_cone, set the arrows right.
<a name="line110">110: </a>          curc_iter = current_cone.begin();
<a name="line111">111: </a>          curc_iter_end = current_cone.end();
<a name="line112">112: </a>          <font color="#4169E1">while</font> (curc_iter != curc_iter_end) {
<a name="line113">113: </a>            s-&gt;addArrow(*curc_iter, constructed_index);
<a name="line114">114: </a>            curc_iter++;
<a name="line115">115: </a>          }
<a name="line116">116: </a>        }
<a name="line117">117: </a>        <font color="#4169E1">return</font> constructed_index;
<a name="line118">118: </a>      } <font color="#4169E1">else</font> {
<a name="line119">119: </a><strong><font color="#FF0000">        ALE:</font></strong>:Mesh::sieve_type::supportSet::iterator cj_iter = current_join-&gt;begin();
<a name="line120">120: </a><strong><font color="#FF0000">        ALE:</font></strong>:Mesh::sieve_type::supportSet::iterator cj_iter_end = current_join-&gt;end();
<a name="line121">121: </a>        int min_depth_in_join = m-&gt;depth(c)+1; //the depth of the thing we want to connect up to
<a name="line122">122: </a>        cj_iter = current_join-&gt;begin();
<a name="line123">123: </a>        cj_iter_end = current_join-&gt;end();
<a name="line124">124: </a>        <font color="#4169E1">while</font> (cj_iter != cj_iter_end) {
<a name="line125">125: </a>          int cj_depth = m-&gt;depth(*cj_iter);
<a name="line126">126: </a>          <font color="#4169E1">if</font> (cj_depth != min_depth_in_join) {
<a name="line127">127: </a><strong><font color="#FF0000">            ALE:</font></strong>:Mesh::sieve_type::supportSet::iterator cj_erase = cj_iter;
<a name="line128">128: </a>            cj_iter++;
<a name="line129">129: </a>            current_join-&gt;erase(cj_erase);
<a name="line130">130: </a>          } <font color="#4169E1">else</font> {
<a name="line131">131: </a>            cj_iter++;
<a name="line132">132: </a>          }
<a name="line133">133: </a>        }
<a name="line134">134: </a>        //<font color="#4169E1">return</font> the existing item in the join; <font color="#4169E1">if</font> there is more than one item in the join something is wrong.
<a name="line135">135: </a>        <font color="#4169E1">if</font> (current_join-&gt;size() != 1) throw ALE::Exception(<font color="#666666">"ConeConstruct: bad join of size &gt; 1"</font>);
<a name="line136">136: </a>        <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"%sjoin already exists, returning %d\n"</font>, a,*current_join-&gt;begin());
<a name="line137">137: </a>        <font color="#4169E1">return</font> *current_join-&gt;begin();
<a name="line138">138: </a>      }
<a name="line139">139: </a>      <font color="#4169E1">return</font> c;
<a name="line140">140: </a>    }
<a name="line141">141: </a>
<a name="line142">142: </a><font color="#B22222">/*</font>
<a name="line143">143: </a><font color="#B22222">  Meshing_FlattenCell</font>
<a name="line144">144: </a><font color="#B22222">  </font>
<a name="line145">145: </a><font color="#B22222">  Flatten the present cell to its support such that the resulting mesh is uninterpolated</font>
<a name="line146">146: </a><font color="#B22222">  </font>
<a name="line147">147: </a><font color="#B22222">  Use it when you've glued on both sides of a hyperface.</font>
<a name="line148">148: </a><font color="#B22222">  </font>
<a name="line149">149: </a><font color="#B22222">  Returns nothing!</font>
<a name="line150">150: </a><font color="#B22222">  </font>
<a name="line151">151: </a><font color="#B22222">*/</font>
<a name="line152">152: </a>
<a name="line153">153: </a>    void Meshing_FlattenCell(ALE::Obj&lt;ALE::Mesh&gt; m, ALE::Mesh::point_type c) {
<a name="line154">154: </a><strong><font color="#FF0000">      ALE:</font></strong>:Obj&lt;ALE::Mesh::sieve_type&gt; s = m-&gt;getSieve();
<a name="line155">155: </a>
<a name="line156">156: </a>    }
<a name="line157">157: </a>
<a name="line158">158: </a><font color="#B22222">/*</font>
<a name="line159">159: </a><font color="#B22222">Meshing_CoarsenMesh</font>

<a name="line161">161: </a><font color="#B22222">Done through the cone construction of simplices based upon traversal.  so:</font>
<a name="line162">162: </a><font color="#B22222">1. vertex finds vertex to make a line</font>
<a name="line163">163: </a><font color="#B22222">2. line finds vertex to make a triangle</font>
<a name="line164">164: </a><font color="#B22222">3. triangle finds vertex to make a tetrahedron</font>
<a name="line165">165: </a><font color="#B22222">4. once a simplex is sufficiently surrounded, intermediate points may be collapsed to uninterpolate</font>
<a name="line166">166: </a><font color="#B22222">5. preserves the vertex namespace </font>
<a name="line167">167: </a><font color="#B22222">6. based on traversal, so will preserve boundaries/internal boundaries implicitly.</font>

<a name="line169">169: </a><font color="#B22222">*/</font>
<a name="line170">170: </a>
<a name="line171">171: </a><strong><font color="#FF0000">    ALE:</font></strong>:Obj&lt;ALE::Mesh&gt; Meshing_CoarsenMesh(ALE::Obj&lt;ALE::Mesh&gt; m, ALE::Obj&lt;ALE::Mesh::sieve_type::supportSet&gt; includedVertices, bool interpolate = true) {
<a name="line172">172: </a>      //<font color="#4169E1">do</font> this based upon SEARCH rather than anything <font color="#4169E1">else</font>.  add Delaunay condition later.
<a name="line173">173: </a>      //int dim = m-&gt;getDimension();
<a name="line174">174: </a>      //build a series of sets <font color="#4169E1">for</font> enqueuing new topological features;
<a name="line175">175: </a>      //find the maximum-valued vertex index
<a name="line176">176: </a><strong><font color="#FF0000">      ALE:</font></strong>:Mesh::point_type cur_index;
<a name="line177">177: </a><strong><font color="#FF0000">      ALE:</font></strong>:Obj&lt;ALE::Mesh::label_sequence&gt; all_vertices = m-&gt;depthStratum(0);
<a name="line178">178: </a><strong><font color="#FF0000">      ALE:</font></strong>:Mesh::label_sequence::iterator av_iter = all_vertices-&gt;begin();
<a name="line179">179: </a><strong><font color="#FF0000">      ALE:</font></strong>:Mesh::label_sequence::iterator av_iter_end = all_vertices-&gt;end();
<a name="line180">180: </a>      cur_index = *av_iter;
<a name="line181">181: </a>      <font color="#4169E1">while</font> (av_iter != av_iter_end) {
<a name="line182">182: </a>        <font color="#4169E1">if</font> (*av_iter &gt; cur_index) cur_index = *av_iter;
<a name="line183">183: </a>        av_iter++;
<a name="line184">184: </a>      }
<a name="line185">185: </a>      //go through all vertices as an outer loop; might have discontinuous mesh regions
<a name="line186">186: </a><strong><font color="#FF0000">      ALE:</font></strong>:Mesh::sieve_type::supportSet::iterator v_iter = includedVertices-&gt;begin();
<a name="line187">187: </a><strong><font color="#FF0000">      ALE:</font></strong>:Mesh::sieve_type::supportSet::iterator v_iter_end = includedVertices-&gt;end();
<a name="line188">188: </a>      <font color="#4169E1">while</font> (v_iter != v_iter_end) {
<a name="line189">189: </a>
<a name="line190">190: </a>        v_iter++;
<a name="line191">191: </a>      }
<a name="line192">192: </a>    }
<a name="line193">193: </a>

<a name="line195">195: </a>    Obj&lt;Mesh&gt; DelaunayCoarsen(Obj&lt;Mesh&gt; fine_mesh, Obj&lt;Mesh::sieve_type::supportSet&gt; vertex_subset) {
<a name="line196">196: </a>      //<font color="#4169E1">return</font> a coarsened version of the present mesh; all meshing calculations done through adjacency.
<a name="line197">197: </a>      //the fine mesh gives us a GREAT DEAL of spacial information and allows us to approximate nearest neighbors readily.
<a name="line198">198: </a>      Obj&lt;Mesh::sieve_type&gt; f_s = fine_mesh-&gt;getSieve();
<a name="line199">199: </a>      //create the new mesh
<a name="line200">200: </a>      Obj&lt;Mesh&gt; m = new Mesh();
<a name="line201">201: </a>      Obj&lt;Mesh::sieve_type&gt; s = new Mesh::sieve_type();
<a name="line202">202: </a>      m-&gt;setSieve(s);
<a name="line203">203: </a>
<a name="line204">204: </a>    }

<a name="line206">206: </a>    //ok we're obviously having problems with other things, but sieve just sped
<a name="line207">207: </a>    //WAY up, so let's just implement some simple forms of space triangulation
<a name="line208">208: </a>    //I'm going to request that the boundaries be done in a bit of a different way than before.

<a name="line210">210: </a>
<a name="line211">211: </a>
<a name="line212">212: </a>    Obj&lt;Mesh&gt; DelaunaySimplicialize_Recursive(Obj&lt;Mesh&gt; boundary, Obj&lt;Mesh::sieve_type::supportSet&gt; vertex_subset) {
<a name="line213">213: </a>      //implement a simple meshing thing over the boundary, inserting vertices when necessary (or not <font color="#4169E1">if</font> constrained)
<a name="line214">214: </a>      Obj&lt;Mesh&gt; m = new Mesh();
<a name="line215">215: </a>      Obj&lt;Mesh::sieve_type&gt; s = new Mesh::sieve_type();
<a name="line216">216: </a>
<a name="line217">217: </a>    }
<a name="line218">218: </a>
<a name="line219">219: </a>    Obj&lt;Mesh&gt; DelaunayCoarsen(Obj&lt;Mesh&gt; fine_mesh, Obj&lt;Mesh::supportSet&gt; includedVertices) {
<a name="line220">220: </a>      //<font color="#4169E1">for</font> each thing in the coarse set: outwardly construct its LINK from its nearest neighbors; respecting previously done work <font color="#4169E1">for</font> other simplices
<a name="line221">221: </a>      //<font color="#4169E1">if</font> each local link is delaunay then the whole thing is delaunay(?)
<a name="line222">222: </a>      Obj&lt;Mesh::sieve_type&gt; f_s = fine_mesh-&gt;getSieve();
<a name="line223">223: </a>      int dim = fine_mesh-&gt;getDimension();
<a name="line224">224: </a>      Obj&lt;Mesh&gt; n_m = new Mesh(fine_mesh-&gt;comm(), dim, 0);
<a name="line225">225: </a>      Obj&lt;Mesh::sieve_type n_s = new Mesh::sieve_type(fine_mesh-&gt;comm(), 0);
<a name="line226">226: </a>      n_m-&gt;setSieve(n_s);
<a name="line227">227: </a>      //what <font color="#4169E1">do</font> we have to <font color="#4169E1">do</font> to add a simplex?  I'll tell you what:
<a name="line228">228: </a>      //1. Make sure that it's across a doublet from the edge it was created on.
<a name="line229">229: </a>      //2. so, there will be a center simplex and its positive and negative suspension sides to dim-dimensional simplices
<a name="line230">230: </a>      //3. the orientations of these will be opposite, of course.
<a name="line231">231: </a>       //create a queue <font color="#4169E1">for</font> the sake of components to remesh
<a name="line232">232: </a>      Obj&lt;Mesh::supportSet&gt; point_queue = new Mesh::supportSet();
<a name="line233">233: </a>      point_queue-&gt;insert(*includedVertices-&gt;begin());
<a name="line234">234: </a>      <font color="#4169E1">while</font> (!point_queue-&gt;empty()) {
<a name="line235">235: </a><strong><font color="#FF0000">        Mesh:</font></strong>:supportSet::iterator c_point_iter = point_queue-&gt;begin();
<a name="line236">236: </a><strong><font color="#FF0000">        Mesh:</font></strong>:point_type c_point = *c_point_iter;
<a name="line237">237: </a>        point_queue-&gt;remove(*c_point_iter);
<a name="line238">238: </a>        int point_depth = m-&gt;depth(c_point);
<a name="line239">239: </a>        <font color="#4169E1">if</font> (point_depth == dim) {
<a name="line240">240: </a>          //nothing to <font color="#4169E1">do</font> here; it shouldn't happen
<a name="line241">241: </a>        } <font color="#4169E1">else</font> {
<a name="line242">242: </a>          //we want to glue this simplex to a new vertex s.t. it doesn't collide with any other things and if we're building a dim-dim
<a name="line243">243: </a>          //simplex, we want it to be delaunay. w.r.t. the <font color="#666666">"doublets"</font> it invokes.
<a name="line244">244: </a>          bool mesh_from_point = true;
<a name="line245">245: </a>          <font color="#4169E1">if</font> (n_s-&gt;hasPoint(c_point)) { //this <font color="#4169E1">case</font> should only happen in the <font color="#4169E1">case</font> of the includedVertices
<a name="line246">246: </a>            <font color="#4169E1">if</font> (point_depth == dim - 1) { //in this <font color="#4169E1">case</font> it's a simplex <font color="#666666">"face"</font> and we want it to be covered on each <font color="#666666">"side"</font> only.
<a name="line247">247: </a>            }
<a name="line248">248: </a>          }
<a name="line249">249: </a>
<a name="line250">250: </a>        }
<a name="line251">251: </a>      } //end of the point_queue <font color="#4169E1">while</font>.
<a name="line252">252: </a>    }
<a name="line253">253: </a>
<a name="line254">254: </a>    Obj&lt;Mesh&gt; DelaunayTetrahedralize(Obj&lt;Mesh&gt; boundary, bool constrained = false) {
<a name="line255">255: </a>
<a name="line256">256: </a>    }
<a name="line257">257: </a>
<a name="line258">258: </a>    Obj&lt;Mesh&gt; DelaunaySimplicialize(Obj&lt;Mesh&gt; boundary, bool constrained = false) {
<a name="line259">259: </a>
<a name="line260">260: </a>    }
<a name="line261">261: </a>
<a name="line262">262: </a>    Obj&lt;Mesh&gt; SparseVoronoiRefine(Obj&lt;Mesh&gt; m, Obj&lt;real_section_type&gt; refinement_limits) {
<a name="line263">263: </a>
<a name="line264">264: </a>    }
<a name="line265">265: </a>  }
<a name="line266">266: </a>}
</pre>
</body>

</html>
