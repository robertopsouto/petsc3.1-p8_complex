<center><a href="Hierarchy.hh">Actual source code: Hierarchy.hh</a></center><br>

<html>
<head>
<title></title>
<meta name="generator" content="c2html 0.9.5">
<meta name="date" content="2011-03-17T19:00:11+00:00">
</head>

<body bgcolor="#FFFFFF">
<pre width="80"><a name="line1">  1: </a>//rewritten Hierarchy.h made explicitly to output directly to <A href="../../../../docs/manualpages/DMMG/DMMG.html#DMMG">DMMG</A>
<a name="line2">  2: </a><font color="#A020F0">#include &lt;list&gt;</font>
<a name="line3">  3: </a><font color="#A020F0">#include &lt;Mesh.hh&gt;</font>
<a name="line4">  4: </a><font color="#A020F0">#include &lt;stdlib.h&gt;</font>
<a name="line5">  5: </a><font color="#A020F0">#include &lt;string&gt;</font>

<a name="line7">  7: </a>//#include <font color="#666666">"petscmesh.h"</font>
<a name="line8"> 8: </a> #include <A href="../../../../include/petscdmmg.h.html">petscdmmg.h</A>
<a name="line9">  9: </a>//#include <font color="#666666">"petscmat.h"</font>
<a name="line10"> 10: </a> #include <A href="../../../../include/private/meshimpl.h.html">private/meshimpl.h</A>
<a name="line11"> 11: </a><font color="#A020F0">#include &lt;Distribution.hh&gt;</font>
<a name="line12"> 12: </a><font color="#A020F0">#include &lt;Generator.hh&gt;</font>
<a name="line13"> 13: </a><font color="#A020F0">#include &lt;SieveAlgorithms.hh&gt;</font>
<a name="line14"> 14: </a><font color="#A020F0">#include &lt;Selection.hh&gt;</font>
<a name="line15"> 15: </a>//helper functions:

<a name="line17"> 17: </a>bool PointIsInElement(ALE::Obj&lt;PETSC_MESH_TYPE&gt; m, PETSC_MESH_TYPE::point_type element, double * point);
<a name="line18"> 18: </a><strong><font color="#4169E1"><A href="../../../../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode">PetscErrorCode</A> MeshLocateInMesh(Mesh finemesh, Mesh coarsemesh)</font></strong>;
<a name="line19"> 19: </a>//double PointDist(double * pointA, double * pointB, int dim);

<a name="line21"> 21: </a>// Functions only used here

<a name="line23"> 23: </a><strong><font color="#4169E1"><A href="../../../../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode">PetscErrorCode</A> MeshSpacingFunction(Mesh mesh)</font></strong>; //builds the spacing function <font color="#4169E1">for</font> the mesh
<a name="line24"> 24: </a><strong><font color="#4169E1"><A href="../../../../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode">PetscErrorCode</A> MeshIDBoundary(Mesh mesh)</font></strong>; //finds the boundary of the mesh.

<a name="line26"> 26: </a><font color="#A020F0">#ifdef PETSC_HAVE_TRIANGLE</font>
<a name="line27"> 27: </a>//SetupTriangulateio: set all the fields of the triangulateio structures to be good <font color="#4169E1">for</font> initial input/output
<a name="line28"> 28: </a><strong><font color="#4169E1"><a name="SetupTriangulateio"></a>void SetupTriangulateio(triangulateio * input, triangulateio * output)</font></strong> {
<a name="line29"> 29: </a>  input-&gt;numberofsegments = 0;
<a name="line30"> 30: </a>  input-&gt;segmentlist = NULL;
<a name="line31"> 31: </a>  input-&gt;numberoftriangles = 0;
<a name="line32"> 32: </a>  input-&gt;numberofcorners = 0;
<a name="line33"> 33: </a>  input-&gt;numberofpointattributes = 0;
<a name="line34"> 34: </a>  input-&gt;pointattributelist = NULL;
<a name="line35"> 35: </a>  input-&gt;numberoftriangleattributes = 0;
<a name="line36"> 36: </a>  input-&gt;trianglelist = NULL;
<a name="line37"> 37: </a>  input-&gt;triangleattributelist = NULL;
<a name="line38"> 38: </a>  input-&gt;trianglearealist = NULL;
<a name="line39"> 39: </a>  input-&gt;segmentmarkerlist = NULL;
<a name="line40"> 40: </a>  input-&gt;holelist = NULL;
<a name="line41"> 41: </a>  input-&gt;numberofholes = 0;
<a name="line42"> 42: </a>  input-&gt;regionlist = NULL;
<a name="line43"> 43: </a>  input-&gt;numberofregions = 0;
<a name="line44"> 44: </a>
<a name="line45"> 45: </a>  output-&gt;pointlist = NULL;
<a name="line46"> 46: </a>  output-&gt;pointattributelist = NULL;
<a name="line47"> 47: </a>  output-&gt;pointmarkerlist = NULL;
<a name="line48"> 48: </a>  output-&gt;trianglelist = NULL;
<a name="line49"> 49: </a>  output-&gt;triangleattributelist = NULL;
<a name="line50"> 50: </a>  output-&gt;trianglearealist = NULL;
<a name="line51"> 51: </a>  output-&gt;neighborlist = NULL;
<a name="line52"> 52: </a>  output-&gt;segmentlist = NULL;
<a name="line53"> 53: </a>  output-&gt;segmentmarkerlist = NULL;
<a name="line54"> 54: </a>  output-&gt;holelist = NULL;
<a name="line55"> 55: </a>  output-&gt;regionlist = NULL;
<a name="line56"> 56: </a>  output-&gt;edgelist = NULL;
<a name="line57"> 57: </a>  output-&gt;edgemarkerlist = NULL;
<a name="line58"> 58: </a>  output-&gt;normlist = NULL;
<a name="line59"> 59: </a>  <font color="#4169E1">return</font>;
<a name="line60"> 60: </a>}
<a name="line61"> 61: </a><font color="#A020F0">#endif</font>

<a name="line63"> 63: </a>double vertex_angle (const ALE::Obj&lt;PETSC_MESH_TYPE::real_section_type&gt; coords, int dim, PETSC_MESH_TYPE::point_type p, PETSC_MESH_TYPE::point_type q, PETSC_MESH_TYPE::point_type r) {

<a name="line65"> 65: </a>// o is our origin point, p is one endpoint, q is the other; find their angle given the coordinates
<a name="line66"> 66: </a>  double *p_coords = new double[dim], *q_coords = new double[dim], *r_coords = new double[dim], mag_q, mag_r, dot_product, angle;
<a name="line68"> 68: </a>  <A href="../../../../docs/manualpages/Sys/PetscMemcpy.html#PetscMemcpy">PetscMemcpy</A>(p_coords, coords-&gt;restrictPoint(p), dim*<font color="#4169E1">sizeof</font>(double));
<a name="line69"> 69: </a>  <A href="../../../../docs/manualpages/Sys/PetscMemcpy.html#PetscMemcpy">PetscMemcpy</A>(q_coords, coords-&gt;restrictPoint(q), dim*<font color="#4169E1">sizeof</font>(double));
<a name="line70"> 70: </a>  <A href="../../../../docs/manualpages/Sys/PetscMemcpy.html#PetscMemcpy">PetscMemcpy</A>(r_coords, coords-&gt;restrictPoint(r), dim*<font color="#4169E1">sizeof</font>(double));
<a name="line71"> 71: </a>  <font color="#4169E1">for</font> (int i = 0; i &lt; dim; i++) {
<a name="line72"> 72: </a>    mag_q += (p_coords[i] - q_coords[i])*(p_coords[i] - q_coords[i]);
<a name="line73"> 73: </a>    mag_r += (p_coords[i] - r_coords[i])*(p_coords[i] - r_coords[i]);
<a name="line74"> 74: </a>    dot_product += (p_coords[i] -q_coords[i])*(p_coords[i] - r_coords[i]);
<a name="line75"> 75: </a>  }
<a name="line76"> 76: </a>  <font color="#4169E1">if</font> (mag_q == 0 || mag_r == 0) <font color="#4169E1">return</font> 0.;
<a name="line77"> 77: </a>  angle = acos(dot_product/sqrt(mag_q*mag_r));
<a name="line78"> 78: </a>  delete [] p_coords; delete [] q_coords; delete [] r_coords;
<a name="line79"> 79: </a>  <font color="#4169E1">return</font> angle;
<a name="line80"> 80: </a>}

<a name="line82"> 82: </a>double Curvature(ALE::Obj&lt;PETSC_MESH_TYPE&gt; m, PETSC_MESH_TYPE::point_type v) {
<a name="line83"> 83: </a>  //Make it work <font color="#4169E1">for</font> 2D and 3D in an abstract fashion.  we know that the
<a name="line84"> 84: </a>  //integral of the curvature over a triangle fan in 3D is merely the sum
<a name="line85"> 85: </a>  //of the angles radiating from its centerpoint minus 2pi, and that
<a name="line86"> 86: </a>  //the point on the triangle fan will be a singularity of curvature

<a name="line88"> 88: </a>  double pi = M_PI;
<a name="line89"> 89: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::real_section_type&gt;&amp; coordinates = m-&gt;getRealSection(<font color="#666666">"coordinates"</font>);
<a name="line90"> 90: </a>  double curvature;
<a name="line92"> 92: </a>  int dim = m-&gt;getDimension();
<a name="line93"> 93: </a>  <font color="#4169E1">if</font> (m-&gt;depth(v) != 0) {
<a name="line94"> 94: </a>    throw ALE::Exception(<font color="#666666">"Curvature only defined on vertices"</font>);
<a name="line95"> 95: </a>  }

<a name="line97"> 97: </a>  double triangleSum = 0.;

<a name="line99"> 99: </a><strong><font color="#FF0000">  ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type&gt; s = m-&gt;getSieve();

<a name="line101">101: </a>  <font color="#4169E1">if</font> (dim == 3) {
<a name="line102">102: </a>    <font color="#4169E1">if</font> (m-&gt;depth() == 1) { //uninterpolated <font color="#4169E1">case</font>, we have to ID the faces
<a name="line103">103: </a><strong><font color="#FF0000">      ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::supportSequence&gt; cells = s-&gt;support(v);
<a name="line104">104: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSequence::iterator c_iter = cells-&gt;begin();
<a name="line105">105: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSequence::iterator c_iter_end = cells-&gt;end();
<a name="line106">106: </a>      <font color="#4169E1">while</font> (c_iter != c_iter_end) {
<a name="line107">107: </a>        //why must cells and corners both start with c?
<a name="line108">108: </a><strong><font color="#FF0000">        ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::coneSequence&gt; tips = s-&gt;cone(*c_iter);
<a name="line109">109: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:sieve_type::coneSequence::iterator t_iter = tips-&gt;begin();
<a name="line110">110: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:sieve_type::coneSequence::iterator t_iter_exclude = tips-&gt;begin();
<a name="line111">111: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:sieve_type::coneSequence::iterator t_iter_end = tips-&gt;end();
<a name="line112">112: </a><strong><font color="#FF0000">        ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::supportSet&gt; face = new PETSC_MESH_TYPE::sieve_type::supportSet();
<a name="line113">113: </a>        <font color="#4169E1">while</font> (t_iter_exclude != t_iter_end) {
<a name="line114">114: </a>          face-&gt;clear();
<a name="line115">115: </a>          <font color="#4169E1">if</font> (*t_iter_exclude != v) {
<a name="line116">116: </a>            t_iter = tips-&gt;begin();
<a name="line117">117: </a>            <font color="#4169E1">while</font> (t_iter != t_iter_end) {
<a name="line118">118: </a>              //make the face into a supportSet
<a name="line119">119: </a>              <font color="#4169E1">if</font> (t_iter != t_iter_exclude) {
<a name="line120">120: </a>                face-&gt;insert(*t_iter);
<a name="line121">121: </a>              }
<a name="line122">122: </a>              t_iter++;
<a name="line123">123: </a>            }
<a name="line124">124: </a>            <font color="#4169E1">if</font> (s-&gt;nJoin1(face)-&gt;size() == 1) { //face on boundary
<a name="line125">125: </a>              //compute the angle
<a name="line126">126: </a>              <font color="#4169E1">if</font> (face-&gt;size() != 3) throw ALE::Exception(<font color="#666666">"Curvature: Bad face size"</font>);
<a name="line127">127: </a><strong><font color="#FF0000">              PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSet::iterator tf_iter = face-&gt;begin();
<a name="line128">128: </a><strong><font color="#FF0000">              PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSet::iterator tf_iter_end = face-&gt;end();
<a name="line129">129: </a>
<a name="line130">130: </a><strong><font color="#FF0000">              PETSC_MESH_TYPE:</font></strong>:point_type v_op[2]; //opposing vertices
<a name="line131">131: </a>              int index = 0;
<a name="line132">132: </a>              <font color="#4169E1">while</font> (tf_iter != tf_iter_end) {
<a name="line133">133: </a>                <font color="#4169E1">if</font> (*tf_iter != v) {
<a name="line134">134: </a>                  v_op[index] = *tf_iter;
<a name="line135">135: </a>                  index++;
<a name="line136">136: </a>                }
<a name="line137">137: </a>                tf_iter++;
<a name="line138">138: </a>              }
<a name="line139">139: </a>              triangleSum += vertex_angle(coordinates, dim, v, v_op[0], v_op[1]);
<a name="line140">140: </a>            } //end face-on-boundary <font color="#4169E1">if</font>
<a name="line141">141: </a>          } //end t_iter_exclude != v <font color="#4169E1">if</font>
<a name="line142">142: </a>          t_iter_exclude++;
<a name="line143">143: </a>        }
<a name="line144">144: </a>        c_iter++;
<a name="line145">145: </a>      }
<a name="line146">146: </a>    } <font color="#4169E1">else</font> {
<a name="line147">147: </a>    //the triangles are there <font color="#4169E1">for</font> us!
<a name="line148">148: </a><strong><font color="#FF0000">      ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::supportArray&gt; faces = s-&gt;nSupport(v, 2);
<a name="line149">149: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:sieve_type::supportArray::iterator f_iter = faces-&gt;begin();
<a name="line150">150: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:sieve_type::supportArray::iterator f_iter_end = faces-&gt;end();
<a name="line151">151: </a>      <font color="#4169E1">while</font> (f_iter != f_iter_end) {
<a name="line152">152: </a>        <font color="#4169E1">if</font> (s-&gt;support(*f_iter)-&gt;size() == 1) { //boundary edge
<a name="line153">153: </a><strong><font color="#FF0000">          ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::coneArray&gt; tips = s-&gt;nCone(*f_iter, 2);
<a name="line154">154: </a>          <font color="#4169E1">if</font> (tips-&gt;size() != 3) throw ALE::Exception(<font color="#666666">"Curvature: wrong size face"</font>);
<a name="line155">155: </a><strong><font color="#FF0000">          PETSC_MESH_TYPE:</font></strong>:sieve_type::coneArray::iterator tf_iter = tips-&gt;begin();
<a name="line156">156: </a><strong><font color="#FF0000">          PETSC_MESH_TYPE:</font></strong>:sieve_type::coneArray::iterator tf_iter_end = tips-&gt;end();
<a name="line157">157: </a>          int index = 0;
<a name="line158">158: </a><strong><font color="#FF0000">          PETSC_MESH_TYPE:</font></strong>:point_type v_op[2];
<a name="line159">159: </a>          <font color="#4169E1">while</font> (tf_iter != tf_iter_end) {
<a name="line160">160: </a>                <font color="#4169E1">if</font> (*tf_iter != v) {
<a name="line161">161: </a>                  v_op[index] = *tf_iter;
<a name="line162">162: </a>                  index++;
<a name="line163">163: </a>                }
<a name="line164">164: </a>                tf_iter++;
<a name="line165">165: </a>          }
<a name="line166">166: </a>          triangleSum += vertex_angle(coordinates, dim, v, v_op[0], v_op[1]);
<a name="line167">167: </a>        }
<a name="line168">168: </a>        f_iter++;
<a name="line169">169: </a>      }
<a name="line170">170: </a>    }
<a name="line171">171: </a>    curvature = 2*pi - triangleSum;
<a name="line172">172: </a>  } <font color="#4169E1">else</font> <font color="#4169E1">if</font> (dim == 2) {
<a name="line173">173: </a><strong><font color="#FF0000">    ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::supportArray&gt; surrounding_triangles = s-&gt;nSupport(v, m-&gt;depth());
<a name="line174">174: </a><strong><font color="#FF0000">    PETSC_MESH_TYPE:</font></strong>:sieve_type::supportArray::iterator st_iter = surrounding_triangles-&gt;begin();
<a name="line175">175: </a><strong><font color="#FF0000">    PETSC_MESH_TYPE:</font></strong>:sieve_type::supportArray::iterator st_iter_end = surrounding_triangles-&gt;end();
<a name="line176">176: </a>    <font color="#4169E1">while</font> (st_iter != st_iter_end) {
<a name="line177">177: </a><strong><font color="#FF0000">      ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::coneArray&gt; tips = s-&gt;nCone(*st_iter, m-&gt;depth());
<a name="line178">178: </a>      <font color="#4169E1">if</font> (tips-&gt;size() != 3) throw ALE::Exception(<font color="#666666">"Curvature: not a triangle!"</font>);
<a name="line179">179: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:sieve_type::coneArray::iterator t_iter = tips-&gt;begin();
<a name="line180">180: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:sieve_type::coneArray::iterator t_iter_end = tips-&gt;end();
<a name="line181">181: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:point_type v_op[2];
<a name="line182">182: </a>      int index = 0;
<a name="line183">183: </a>      <font color="#4169E1">while</font> (t_iter != t_iter_end) {
<a name="line184">184: </a>        <font color="#4169E1">if</font> (*t_iter != v) {
<a name="line185">185: </a>          v_op[index] = *t_iter;
<a name="line186">186: </a>          index++;
<a name="line187">187: </a>        }
<a name="line188">188: </a>        t_iter++;
<a name="line189">189: </a>      }
<a name="line190">190: </a>      triangleSum += vertex_angle(coordinates, dim, v, v_op[0], v_op[1]);
<a name="line191">191: </a>      st_iter++;
<a name="line192">192: </a>    }
<a name="line193">193: </a>    curvature = fabs(triangleSum - pi);
<a name="line194">194: </a>  } //end of dimension 2 <font color="#4169E1">case</font>
<a name="line195">195: </a>  <font color="#4169E1">return</font> curvature;
<a name="line196">196: </a>}


<a name="line199">199: </a><font color="#A020F0">#if 0</font>

<a name="line201">201: </a>double Curvature_2D(ALE::Obj&lt;PETSC_MESH_TYPE&gt; m, PETSC_MESH_TYPE::point_type p) {
<a name="line203">203: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::real_section_type&gt;&amp; coordinates = m-&gt;getRealSection(<font color="#666666">"coordinates"</font>);
<a name="line204">204: </a><strong><font color="#FF0000">  ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::label_type&gt; boundary = m-&gt;getLabel(<font color="#666666">"marker"</font>);
<a name="line205">205: </a>  int dim = m-&gt;getDimension();
<a name="line206">206: </a>  <font color="#4169E1">if</font> (dim != 2) throw ALE::Exception(<font color="#666666">"Called the 2D curvature routine on a non-2D mesh."</font>);
<a name="line207">207: </a>  double pCoords[dim], qCoords[dim], rCoords[dim];
<a name="line208">208: </a>  double normvec[dim];
<a name="line209">209: </a>
<a name="line210">210: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::sieve_type::supportSequence&gt; neighbors = m-&gt;getSieve()-&gt;support(p); //get the set of edges with p as an endpoint
<a name="line211">211: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSequence::iterator n_iter = neighbors-&gt;begin();
<a name="line212">212: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSequence::iterator n_iter_end = neighbors-&gt;end();
<a name="line213">213: </a><strong><font color="#FF0000">  std:</font></strong>:list&lt;PETSC_MESH_TYPE::point_type&gt; edgnlist;
<a name="line214">214: </a>  <font color="#4169E1">while</font> (n_iter != n_iter_end) {
<a name="line215">215: </a>      <font color="#4169E1">if</font> (m-&gt;getSieve()-&gt;support(*n_iter)-&gt;size() == 1) {
<a name="line216">216: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:sieve_type::coneSequence::iterator npoint = m-&gt;getSieve()-&gt;cone(*n_iter)-&gt;begin();
<a name="line217">217: </a>        <font color="#4169E1">if</font> (*npoint != p) {
<a name="line218">218: </a>          edgnlist.push_front(*npoint);
<a name="line219">219: </a>        } <font color="#4169E1">else</font> {
<a name="line220">220: </a>          npoint++;
<a name="line221">221: </a>          edgnlist.push_front(*npoint);
<a name="line222">222: </a>        }
<a name="line223">223: </a>    }
<a name="line224">224: </a>    n_iter++;
<a name="line225">225: </a>  }
<a name="line226">226: </a>  <font color="#4169E1">if</font> (edgnlist.size() != 2) throw ALE::Exception(<font color="#666666">"There is either a pathological boundary here, or this algorithm is wrong!"</font>);
<a name="line227">227: </a>  //ok, we have an arc. n1 -&gt; p -&gt; n2  we want to go through the arc in order, in order to get the normal.
<a name="line228">228: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:point_type n1 = *edgnlist.begin();
<a name="line229">229: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:point_type n2 = *(++edgnlist.begin());

<a name="line231">231: </a>  <A href="../../../../docs/manualpages/Sys/PetscMemcpy.html#PetscMemcpy">PetscMemcpy</A>(pCoords, coordinates-&gt;restrictPoint(p), dim*<font color="#4169E1">sizeof</font>(double));
<a name="line232">232: </a>  <A href="../../../../docs/manualpages/Sys/PetscMemcpy.html#PetscMemcpy">PetscMemcpy</A>(qCoords, coordinates-&gt;restrictPoint(n1), dim*<font color="#4169E1">sizeof</font>(double));
<a name="line233">233: </a>  <A href="../../../../docs/manualpages/Sys/PetscMemcpy.html#PetscMemcpy">PetscMemcpy</A>(rCoords, coordinates-&gt;restrictPoint(n2), dim*<font color="#4169E1">sizeof</font>(double));

<a name="line235">235: </a>  <font color="#4169E1">if</font> (m-&gt;debug()) <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"Edges: %d--%d--%d : (%f, %f)--(%f, %f)--(%f, %f)\n"</font>, n1, p, n2, qCoords[0], qCoords[1], pCoords[0], pCoords[1], rCoords[0], rCoords[1]);

<a name="line237">237: </a>  normvec[0] = pCoords[1] - qCoords[1];
<a name="line238">238: </a>  normvec[1] = qCoords[0] - pCoords[0];

<a name="line240">240: </a>  normvec[0] += rCoords[1] - pCoords[1];
<a name="line241">241: </a>  normvec[1] += pCoords[0] - rCoords[0];
<a name="line242">242: </a>  //normalize the normal.
<a name="line243">243: </a>  double normlen = sqrt(normvec[0]*normvec[0] + normvec[1]*normvec[1]);
<a name="line244">244: </a>  <font color="#4169E1">if</font> (normlen &lt; 0.000000000001) <font color="#4169E1">return</font> 0.; //give up
<a name="line245">245: </a>  normvec[0] = normvec[0]/normlen;
<a name="line246">246: </a>  normvec[1] = normvec[1]/normlen;
<a name="line247">247: </a>  <font color="#4169E1">if</font> (m-&gt;debug()) <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"normal: (%f, %f)\n"</font>, normvec[0], normvec[1]);
<a name="line248">248: </a>  //ok, take the min dot product of this with the two edges used before.
<a name="line249">249: </a>  double qnorm = sqrt((pCoords[0] - qCoords[0])*(pCoords[0] - qCoords[0]) + (pCoords[1] - qCoords[1])*(pCoords[1] - qCoords[1]));
<a name="line250">250: </a>  double rnorm = sqrt((rCoords[0] - pCoords[0])*(rCoords[0] - pCoords[0]) + (rCoords[1] - pCoords[1])*(rCoords[1] - pCoords[1]));
<a name="line251">251: </a>  double c1 = ((qCoords[1] - pCoords[1])*normvec[1]+(qCoords[0] - pCoords[0])*normvec[0])/qnorm;
<a name="line252">252: </a>  double c2 = ((rCoords[1] - pCoords[1])*normvec[1]+(rCoords[0] - pCoords[0])*normvec[0])/rnorm;
<a name="line253">253: </a>  <font color="#4169E1">if</font> (fabs(c1) &gt; fabs(c2)) <font color="#4169E1">return</font> fabs(c2);
<a name="line254">254: </a>  <font color="#4169E1">return</font> fabs(c1);
<a name="line255">255: </a>}

<a name="line257">257: </a>double Curvature_3D(ALE::Obj&lt;PETSC_MESH_TYPE&gt; m, PETSC_MESH_TYPE::point_type p) {
<a name="line259">259: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::real_section_type&gt;&amp; coordinates = m-&gt;getRealSection(<font color="#666666">"coordinates"</font>);
<a name="line260">260: </a><strong><font color="#FF0000">  ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::label_type&gt; boundary = m-&gt;getLabel(<font color="#666666">"marker"</font>);
<a name="line261">261: </a>  int dim = m-&gt;getDimension();
<a name="line262">262: </a>  <font color="#4169E1">if</font> (dim != 3) throw ALE::Exception(<font color="#666666">"Called the 3D curvature routine on a non-3D mesh."</font>);
<a name="line263">263: </a>  <font color="#4169E1">if</font> (m-&gt;height(p) != 3) throw ALE::Exception(<font color="#666666">"Curvatures available for interpolated meshes only."</font>);
<a name="line264">264: </a>  double pCoords[dim], qCoords[dim], rCoords[dim];
<a name="line265">265: </a>  <A href="../../../../docs/manualpages/Sys/PetscMemcpy.html#PetscMemcpy">PetscMemcpy</A>(pCoords, coordinates-&gt;restrictPoint(p), dim*<font color="#4169E1">sizeof</font>(double));
<a name="line266">266: </a>  double normvec[dim];
<a name="line267">267: </a>  normvec[0] = 0.;
<a name="line268">268: </a>  normvec[1] = 0.;
<a name="line269">269: </a>  normvec[2] = 0.;
<a name="line270">270: </a>  //ok, traverse the pointface in one direction.
<a name="line271">271: </a>  //find the first exterior face
<a name="line272">272: </a><strong><font color="#FF0000">  ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::supportArray&gt; faces = m-&gt;getSieve()-&gt;nSupport(p, 2);
<a name="line273">273: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:sieve_type::supportArray::iterator f_iter = faces-&gt;begin();
<a name="line274">274: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:sieve_type::supportArray::iterator f_iter_end = faces-&gt;end();
<a name="line275">275: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:point_type curface, curpt, lastpt, firstpt;
<a name="line276">276: </a>  bool found = false;
<a name="line277">277: </a>  <font color="#4169E1">while</font> (f_iter != f_iter_end &amp;&amp; !found) {
<a name="line278">278: </a>    <font color="#4169E1">if</font> (m-&gt;getSieve()-&gt;support(*f_iter)-&gt;size() == 1) {
<a name="line279">279: </a>      curface = *f_iter;
<a name="line280">280: </a>      found = true;
<a name="line281">281: </a>    }
<a name="line282">282: </a>    f_iter++;
<a name="line283">283: </a>  }
<a name="line284">284: </a>
<a name="line285">285: </a><strong><font color="#FF0000">  ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::coneArray&gt; neighbors = m-&gt;getSieve()-&gt;nCone(curface, 2);
<a name="line286">286: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:sieve_type::coneArray::iterator n_iter = neighbors-&gt;begin();
<a name="line287">287: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:sieve_type::coneArray::iterator n_iter_end = neighbors-&gt;end();
<a name="line288">288: </a>  //set cur and lastpt as appropriate.
<a name="line289">289: </a>  <font color="#4169E1">while</font> (n_iter != n_iter_end) {
<a name="line290">290: </a>    <font color="#4169E1">if</font> (*n_iter != p) {
<a name="line291">291: </a>      lastpt = curpt;
<a name="line292">292: </a>      curpt = *n_iter;
<a name="line293">293: </a>    }
<a name="line294">294: </a>    n_iter++;
<a name="line295">295: </a>  }
<a name="line296">296: </a>  firstpt = curpt;
<a name="line297">297: </a>  //ok, proceed in the following fashion:  compute the normal of curface, add it to normvec, and move on to the next triangle.  give up when you're back at firstpt.
<a name="line298">298: </a>    //printf(<font color="#666666">"%d -&gt;"</font>, curpt);
<a name="line299">299: </a>  bool startup = true;
<a name="line300">300: </a>  <font color="#4169E1">while</font> (curpt != firstpt || startup) {
<a name="line301">301: </a>    startup = false;
<a name="line302">302: </a>    //normal computation:
<a name="line303">303: </a>    <A href="../../../../docs/manualpages/Sys/PetscMemcpy.html#PetscMemcpy">PetscMemcpy</A>(qCoords, coordinates-&gt;restrictPoint(curpt), dim*<font color="#4169E1">sizeof</font>(double));
<a name="line304">304: </a>    <A href="../../../../docs/manualpages/Sys/PetscMemcpy.html#PetscMemcpy">PetscMemcpy</A>(rCoords, coordinates-&gt;restrictPoint(lastpt), dim*<font color="#4169E1">sizeof</font>(double));
<a name="line305">305: </a>    double tmp = (qCoords[1] - pCoords[1])*(rCoords[2] - pCoords[2]) - (qCoords[2] - pCoords[2])*(rCoords[1] - pCoords[1]);
<a name="line306">306: </a>    normvec[0] += tmp;
<a name="line307">307: </a>    //printf(<font color="#666666">"%f,"</font>,tmp);
<a name="line308">308: </a>    tmp = (qCoords[2] - pCoords[2])*(rCoords[0] - pCoords[0]) - (qCoords[0] - pCoords[0])*(rCoords[2] - pCoords[2]);
<a name="line309">309: </a>    normvec[1] += tmp;
<a name="line310">310: </a>    //printf(<font color="#666666">"%f,"</font>,tmp);
<a name="line311">311: </a>    tmp = (qCoords[0] - pCoords[0])*(rCoords[1] - pCoords[1]) - (qCoords[1] - pCoords[1])*(rCoords[0] - pCoords[0]);
<a name="line312">312: </a>    normvec[2] += tmp;
<a name="line313">313: </a>    //printf(<font color="#666666">"%f\n"</font>,tmp);
<a name="line314">314: </a>    found = false;
<a name="line315">315: </a>    f_iter = faces-&gt;begin();
<a name="line316">316: </a>    f_iter_end = faces-&gt;end();
<a name="line317">317: </a>    <font color="#4169E1">while</font> (f_iter != f_iter_end &amp;&amp; !found) {
<a name="line318">318: </a>      //get the points in the cone of this face and see <font color="#4169E1">if</font> it a) isn't the current face, and b) has p, curpt, and NOT lastpt in its cone
<a name="line319">319: </a>      <font color="#4169E1">if</font> (m-&gt;getSieve()-&gt;support(*f_iter)-&gt;size() &lt; 2) {
<a name="line320">320: </a>        neighbors = m-&gt;getSieve()-&gt;nCone(*f_iter, 2);
<a name="line321">321: </a>        n_iter = neighbors-&gt;begin();
<a name="line322">322: </a>        n_iter_end = neighbors-&gt;end();
<a name="line323">323: </a>        bool containsp = false;
<a name="line324">324: </a>        bool containscurpt = false;
<a name="line325">325: </a>        bool containslastpt = false;
<a name="line326">326: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:point_type posspt;
<a name="line327">327: </a>        <font color="#4169E1">while</font> (n_iter != n_iter_end) {
<a name="line328">328: </a>          <font color="#4169E1">if</font> (*n_iter == p){ containsp = true;}
<a name="line329">329: </a>          <font color="#4169E1">else</font> <font color="#4169E1">if</font> (*n_iter == curpt) {containscurpt = true;}
<a name="line330">330: </a>          <font color="#4169E1">else</font> <font color="#4169E1">if</font> (*n_iter == lastpt) {containslastpt = true;}
<a name="line331">331: </a>          <font color="#4169E1">else</font> posspt = *n_iter;
<a name="line332">332: </a>          n_iter++;
<a name="line333">333: </a>        }
<a name="line334">334: </a>        <font color="#4169E1">if</font> (containscurpt &amp;&amp; containsp &amp;&amp; !containslastpt) {
<a name="line335">335: </a>          lastpt = curpt;
<a name="line336">336: </a>          curpt = posspt;
<a name="line337">337: </a>          found = true;
<a name="line338">338: </a>          curface = *f_iter;
<a name="line339">339: </a>        }
<a name="line340">340: </a>      }
<a name="line341">341: </a>      f_iter++;
<a name="line342">342: </a>    }
<a name="line343">343: </a>    //printf(<font color="#666666">"%d -&gt;"</font>, curpt);
<a name="line344">344: </a>  }
<a name="line345">345: </a>  //printf(<font color="#666666">"\n"</font>);
<a name="line346">346: </a>  //normalize the normal.
<a name="line347">347: </a>  double normlen = sqrt(normvec[0]*normvec[0] + normvec[1]*normvec[1] + normvec[2]*normvec[2]);
<a name="line348">348: </a>  <font color="#4169E1">if</font> (normlen &lt; 0.000000000001) <font color="#4169E1">return</font> 0.; //give up
<a name="line349">349: </a>  normvec[0] = normvec[0]/normlen;
<a name="line350">350: </a>  normvec[1] = normvec[1]/normlen;
<a name="line351">351: </a>  normvec[2] = normvec[2]/normlen;
<a name="line352">352: </a>  //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"%f, %f, %f\n"</font>, normvec[0], normvec[1], normvec[2]);
<a name="line353">353: </a>  //now go through the adjacent edges, seeing how off they are from orthogonal with the normal.
<a name="line354">354: </a>  double curvature = 1.0;
<a name="line355">355: </a><strong><font color="#FF0000">  ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::coneSet&gt; pneighbors = m-&gt;getSieve()-&gt;cone(m-&gt;getSieve()-&gt;support(p));
<a name="line356">356: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:sieve_type::coneSet::iterator p_iter = pneighbors-&gt;begin();
<a name="line357">357: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:sieve_type::coneSet::iterator p_iter_end = pneighbors-&gt;end();
<a name="line358">358: </a>  <font color="#4169E1">while</font> (p_iter != p_iter_end) {
<a name="line359">359: </a>    <font color="#4169E1">if</font> (*p_iter != p) {
<a name="line360">360: </a>      <A href="../../../../docs/manualpages/Sys/PetscMemcpy.html#PetscMemcpy">PetscMemcpy</A>(qCoords, coordinates-&gt;restrictPoint(*p_iter), dim*<font color="#4169E1">sizeof</font>(double));
<a name="line361">361: </a>      double curlen = sqrt((qCoords[0] - pCoords[0])*(qCoords[0] - pCoords[0]) + (qCoords[1] - pCoords[1])*(qCoords[1] - pCoords[1]) + (qCoords[2] - pCoords[2])*(qCoords[2] - pCoords[2]));
<a name="line362">362: </a>      double curcurve = fabs((normvec[0]*(qCoords[0] - pCoords[0]) + normvec[1]*(qCoords[1] - pCoords[1]) + normvec[2]*(qCoords[2] - pCoords[2]))/curlen);
<a name="line363">363: </a>      <font color="#4169E1">if</font> (curcurve &lt; curvature)curvature = curcurve;
<a name="line364">364: </a>    }
<a name="line365">365: </a>    p_iter++;
<a name="line366">366: </a>  }
<a name="line367">367: </a>  //printf(<font color="#666666">"Curvature: %f\n"</font>, curvature);
<a name="line368">368: </a>  <font color="#4169E1">return</font> curvature;
<a name="line369">369: </a>}

<a name="line371">371: </a>double Curvature(ALE::Obj&lt;PETSC_MESH_TYPE&gt; m, PETSC_MESH_TYPE::point_type p) {
<a name="line372">372: </a>  int dim = m-&gt;getDimension();
<a name="line373">373: </a>  <font color="#4169E1">if</font> (dim == 2) {<font color="#4169E1">return</font> Curvature_2D(m, p);}
<a name="line374">374: </a>  <font color="#4169E1">else</font> <font color="#4169E1">if</font> (dim == 3) {<font color="#4169E1">return</font> Curvature_3D(m, p);}
<a name="line375">375: </a>  <font color="#4169E1">else</font> throw ALE::Exception(<font color="#666666">"Cannot do Curvature in dimensions other than 2 and 3D."</font>);
<a name="line376">376: </a>}

<a name="line378">378: </a><font color="#A020F0">#endif</font>

<a name="line380">380: </a>//MeshSpacingFunction: Build the spacing function in the <font color="#666666">"spacing"</font> section on the mesh.

<a name="line382">382: </a><strong><font color="#4169E1"><a name="MeshSpacingFunction"></a><A href="../../../../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode">PetscErrorCode</A> MeshSpacingFunction(Mesh mesh)</font></strong> {
<a name="line383">383: </a><strong><font color="#FF0000">  ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE&gt; m;
<a name="line386">386: </a>  <A href="../../../../docs/manualpages/Mesh/MeshGetMesh.html#MeshGetMesh">MeshGetMesh</A>(mesh, m);
<a name="line387">387: </a>  int dim = m-&gt;getDimension();
<a name="line388">388: </a>  //setup the spacing section
<a name="line389">389: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::real_section_type&gt;&amp; spacing = m-&gt;getRealSection(<font color="#666666">"spacing"</font>);
<a name="line390">390: </a>  spacing-&gt;setFiberDimension(m-&gt;depthStratum(0), 1);
<a name="line391">391: </a>  m-&gt;allocate(spacing);
<a name="line392">392: </a>  //vertices
<a name="line393">393: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::real_section_type&gt;&amp;  coordinates = m-&gt;getRealSection(<font color="#666666">"coordinates"</font>);
<a name="line394">394: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::label_sequence&gt;&amp; vertices = m-&gt;depthStratum(0);
<a name="line395">395: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator v_iter = vertices-&gt;begin();
<a name="line396">396: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator v_iter_end = vertices-&gt;end();
<a name="line397">397: </a>  double vCoords[3], nCoords[3];
<a name="line398">398: </a>  <font color="#4169E1">while</font> (v_iter != v_iter_end) {
<a name="line399">399: </a>    const double * tmpCoords = coordinates-&gt;restrictPoint(*v_iter);
<a name="line400">400: </a>    <font color="#4169E1">for</font> (int i = 0; i &lt; dim; i++) {
<a name="line401">401: </a>      vCoords[i] = tmpCoords[i];
<a name="line402">402: </a>    }
<a name="line403">403: </a>    //get the neighbors
<a name="line404">404: </a><strong><font color="#FF0000">    ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::coneSet&gt; neighbors = m-&gt;getSieve()-&gt;cone(m-&gt;getSieve()-&gt;support(*v_iter));
<a name="line405">405: </a><strong><font color="#FF0000">    PETSC_MESH_TYPE:</font></strong>:sieve_type::coneSet::iterator n_iter = neighbors-&gt;begin();
<a name="line406">406: </a><strong><font color="#FF0000">    PETSC_MESH_TYPE:</font></strong>:sieve_type::coneSet::iterator n_iter_end = neighbors-&gt;end();
<a name="line407">407: </a>    //go through the neighbors
<a name="line408">408: </a>    double minDist = 0.;
<a name="line409">409: </a>    <font color="#4169E1">while</font> (n_iter != n_iter_end) {
<a name="line410">410: </a>      double dist = 0.;
<a name="line411">411: </a>      const double * rBuf = coordinates-&gt;restrictPoint(*n_iter);
<a name="line412">412: </a>      <A href="../../../../docs/manualpages/Sys/PetscMemcpy.html#PetscMemcpy">PetscMemcpy</A>(nCoords, rBuf, dim*<font color="#4169E1">sizeof</font>(double));
<a name="line413">413: </a>      double d_tmp;
<a name="line414">414: </a>      <font color="#4169E1">for</font> (int d = 0; d &lt; dim; d++) {
<a name="line415">415: </a>        d_tmp = nCoords[d] - vCoords[d];
<a name="line416">416: </a>        dist += d_tmp * d_tmp;
<a name="line417">417: </a>      }
<a name="line418">418: </a>      dist = 0.5*sqrt(dist);
<a name="line419">419: </a>      <font color="#4169E1">if</font> ((dist &lt; minDist &amp;&amp; dist &gt; 0.) || minDist == 0.) minDist = dist;
<a name="line420">420: </a>      n_iter++;
<a name="line421">421: </a>    }
<a name="line422">422: </a>    spacing-&gt;updatePoint(*v_iter, &amp;minDist);
<a name="line423">423: </a>    v_iter++;
<a name="line424">424: </a>  }
<a name="line425">425: </a>  <font color="#4169E1">return</font>(0);
<a name="line426">426: </a>}

<a name="line428">428: </a>//MeshIDBoundary: create the <font color="#666666">"marker"</font> label needed by many such things

<a name="line430">430: </a><strong><font color="#4169E1"><a name="MeshIDBoundary"></a><A href="../../../../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode">PetscErrorCode</A> MeshIDBoundary(Mesh mesh)</font></strong> {
<a name="line431">431: </a><strong><font color="#FF0000">  ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE&gt; m;
<a name="line434">434: </a>  <A href="../../../../docs/manualpages/Mesh/MeshGetMesh.html#MeshGetMesh">MeshGetMesh</A>(mesh, m);
<a name="line435">435: </a>  //int dim = m-&gt;getDimension();
<a name="line436">436: </a><strong><font color="#FF0000">  ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::label_type&gt; boundary = m-&gt;createLabel(<font color="#666666">"marker"</font>);

<a name="line438">438: </a>  int interplevels = m-&gt;height(*m-&gt;depthStratum(0)-&gt;begin());
<a name="line439">439: </a>  <font color="#4169E1">if</font> (interplevels == 1) { //noninterpolated <font color="#4169E1">case</font>
<a name="line440">440: </a><strong><font color="#FF0000">    ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::label_sequence&gt; cells = m-&gt;heightStratum(0);
<a name="line441">441: </a><strong><font color="#FF0000">    PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator c_iter = cells-&gt;begin();
<a name="line442">442: </a><strong><font color="#FF0000">    PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator c_iter_end = cells-&gt;end();
<a name="line443">443: </a>    <font color="#4169E1">while</font> (c_iter != c_iter_end) {
<a name="line444">444: </a>      //<font color="#4169E1">for</font> now just <font color="#4169E1">do</font> <font color="#4169E1">for</font> simplicial meshes
<a name="line445">445: </a><strong><font color="#FF0000">      ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::coneSequence&gt; corners = m-&gt;getSieve()-&gt;cone(*c_iter);
<a name="line446">446: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:sieve_type::coneSequence::iterator v_iter = corners-&gt;begin();
<a name="line447">447: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:sieve_type::coneSequence::iterator v_remove = corners-&gt;begin();
<a name="line448">448: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:sieve_type::coneSequence::iterator v_iter_end = corners-&gt;end();
<a name="line449">449: </a>      <font color="#4169E1">while</font> (v_remove != v_iter_end) {
<a name="line450">450: </a><strong><font color="#FF0000">        ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::supportSet&gt; face = PETSC_MESH_TYPE::sieve_type::supportSet();
<a name="line451">451: </a>        v_iter = corners-&gt;begin();
<a name="line452">452: </a>        <font color="#4169E1">while</font> (v_iter != v_iter_end) {
<a name="line453">453: </a>          <font color="#4169E1">if</font> (v_iter != v_remove) {
<a name="line454">454: </a>          face-&gt;insert(*v_iter);
<a name="line455">455: </a>          }
<a name="line456">456: </a>          v_iter++;
<a name="line457">457: </a>        }
<a name="line458">458: </a>        <font color="#4169E1">if</font> (m-&gt;getSieve()-&gt;nJoin1(face)-&gt;size() == 1) {
<a name="line459">459: </a><strong><font color="#FF0000">          PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSet::iterator f_iter = face-&gt;begin();
<a name="line460">460: </a><strong><font color="#FF0000">          PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSet::iterator f_iter_end = face-&gt;end();
<a name="line461">461: </a>          <font color="#4169E1">while</font> (f_iter != f_iter_end){
<a name="line462">462: </a>            m-&gt;setValue(boundary, *f_iter, 1);
<a name="line463">463: </a><strong><font color="#FF0000">            ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::supportSequence&gt; f_support = m-&gt;getSieve()-&gt;support(*f_iter);
<a name="line464">464: </a><strong><font color="#FF0000">            PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSequence::iterator fs_iter = f_support-&gt;begin();
<a name="line465">465: </a><strong><font color="#FF0000">            PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSequence::iterator fs_iter_end = f_support-&gt;end();
<a name="line466">466: </a>            <font color="#4169E1">while</font> (fs_iter != fs_iter_end) {
<a name="line467">467: </a>              m-&gt;setValue(boundary,*fs_iter, 2);
<a name="line468">468: </a>              fs_iter++;
<a name="line469">469: </a>            }
<a name="line470">470: </a>            f_iter++;
<a name="line471">471: </a>          }
<a name="line472">472: </a>       }
<a name="line473">473: </a>        v_remove++;
<a name="line474">474: </a>      }
<a name="line475">475: </a>      c_iter++;
<a name="line476">476: </a>    }
<a name="line477">477: </a>  } <font color="#4169E1">else</font> {
<a name="line478">478: </a>    const ALE::Obj&lt;PETSC_MESH_TYPE::label_sequence&gt;&amp; faces = m-&gt;heightStratum(1);
<a name="line479">479: </a><strong><font color="#FF0000">    PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator f_iter = faces-&gt;begin();
<a name="line480">480: </a><strong><font color="#FF0000">    PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator f_iter_end = faces-&gt;end();
<a name="line481">481: </a>    <font color="#4169E1">while</font> (f_iter != f_iter_end) {
<a name="line482">482: </a>      //mark the boundary faces and every element of their closure as <font color="#666666">"1"</font>.  Mark their support tri/tet as <font color="#666666">"2"</font> (Matt - Is this right?)
<a name="line483">483: </a><strong><font color="#FF0000">      ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::supportSequence&gt; support = m-&gt;getSieve()-&gt;support(*f_iter);
<a name="line484">484: </a>      <font color="#4169E1">if</font> (support-&gt;size() == 1) {
<a name="line485">485: </a>        m-&gt;setValue(boundary, *f_iter, 1);
<a name="line486">486: </a>        m-&gt;setValue(boundary, *support-&gt;begin(), 2);
<a name="line487">487: </a><strong><font color="#FF0000">        ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::coneArray&gt; boundclose = ALE::SieveAlg&lt;PETSC_MESH_TYPE&gt;::closure(m, *f_iter);
<a name="line488">488: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:sieve_type::coneArray::iterator bc_iter = boundclose-&gt;begin();
<a name="line489">489: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:sieve_type::coneArray::iterator bc_iter_end = boundclose-&gt;end();
<a name="line490">490: </a>        <font color="#4169E1">while</font> (bc_iter != bc_iter_end) {
<a name="line491">491: </a>          m-&gt;setValue(boundary, *bc_iter, 1);
<a name="line492">492: </a>          bc_iter++;
<a name="line493">493: </a>        }
<a name="line494">494: </a>      }
<a name="line495">495: </a>      f_iter++;
<a name="line496">496: </a>    }

<a name="line498">498: </a><font color="#B22222">/*    while (v_iter != v_iter_end) {</font>
<a name="line499">499: </a><font color="#B22222">      ALE::Obj&lt;PETSC_MESH_TYPE::sieve_type::supportArray&gt; vsupport = m-&gt;getSieve()-&gt;nSupport(*v_iter, interplevels-1); //3D faces or 2D edges</font>
<a name="line500">500: </a><font color="#B22222">      PETSC_MESH_TYPE::sieve_type::supportArray::iterator s_iter = vsupport-&gt;begin();</font>
<a name="line501">501: </a><font color="#B22222">      PETSC_MESH_TYPE::sieve_type::supportArray::iterator s_iter_end = vsupport-&gt;end();</font>
<a name="line502">502: </a><font color="#B22222">      bool isBound = false;</font>
<a name="line503">503: </a><font color="#B22222">      while (s_iter != s_iter_end) {</font>
<a name="line504">504: </a><font color="#B22222">        //check the support of each dim-1 element; if it's supported on one side it is attached to boundary nodes</font>
<a name="line505">505: </a><font color="#B22222">        ALE::Obj&lt;PETSC_MESH_TYPE::sieve_type::supportSequence&gt; fsupport = m-&gt;getSieve()-&gt;support(*s_iter);</font>
<a name="line506">506: </a><font color="#B22222">        if (fsupport-&gt;size() &lt; 2) isBound = true;</font>
<a name="line507">507: </a><font color="#B22222">        s_iter++;</font>
<a name="line508">508: </a><font color="#B22222">      }</font>
<a name="line509">509: </a><font color="#B22222">      if (isBound) m-&gt;setValue(boundary, *v_iter, 1);</font>
<a name="line510">510: </a><font color="#B22222">      v_iter++;</font>
<a name="line511">511: </a><font color="#B22222">    }</font>
<a name="line512">512: </a><font color="#B22222">*/</font>
<a name="line513">513: </a>  }
<a name="line514">514: </a>  <font color="#4169E1">return</font>(0);
<a name="line515">515: </a>}


<a name="line520">520: </a><font color="#A020F0">#if defined PETSC_HAVE_TETGEN || defined PETSC_HAVE_TRIANGLE</font>

<a name="line522">522: </a><strong><font color="#FF0000">ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE&gt; MeshCreateHierarchyMesh(ALE::Obj&lt;PETSC_MESH_TYPE&gt; m, ALE::Obj&lt;PETSC_MESH_TYPE::sieve_type::supportSet&gt; includedVertices) {
<a name="line523">523: </a>  int curmeshsize = 0;
<a name="line524">524: </a>  int dim = m-&gt;getDimension();
<a name="line525">525: </a>  //const ALE::Obj&lt;PETSC_MESH_TYPE::real_section_type&gt;&amp; coordinates = m-&gt;getRealSection(<font color="#666666">"coordinates"</font>);
<a name="line526">526: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::label_type&gt;&amp; boundary = m-&gt;getLabel(<font color="#666666">"marker"</font>);
<a name="line527">527: </a>  //const ALE::Obj&lt;PETSC_MESH_TYPE::label_type&gt; hdepth = m-&gt;getLabel(<font color="#666666">"hdepth"</font>);
<a name="line528">528: </a>  //<font color="#4169E1">for</font> (int i = curLevel; i &lt; nLevels; i++) {
<a name="line529">529: </a>  //  curmeshsize += m-&gt;getLabelStratum(<font color="#666666">"hdepth"</font>, i)-&gt;size();
<a name="line530">530: </a>  //}
<a name="line531">531: </a>  curmeshsize = includedVertices-&gt;size();
<a name="line532">532: </a>  //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"new mesh size should be %d vertices.\n"</font>, curmeshsize);
<a name="line533">533: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::label_sequence&gt;&amp; vertices = m-&gt;depthStratum(0);
<a name="line534">534: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator v_iter = vertices-&gt;begin();
<a name="line535">535: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator v_iter_end = vertices-&gt;end();
<a name="line536">536: </a>  //double coords[dim * curmeshsize];
<a name="line537">537: </a>  //int indices[dim * curmeshsize];
<a name="line538">538: </a>  //const double * tmpcoords;
<a name="line539">539: </a>  //int index = 0;
<a name="line540">540: </a>    //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"Mesh Size: %d\n"</font>, curmeshsize);
<a name="line541">541: </a>    //load the points and their names in this mesh into a list
<a name="line542">542: </a>    //triangulate/tetrahedralize
<a name="line543">543: </a>    //make into a new sieve.  place coordinates and names on the sieve.

<a name="line545">545: </a><strong><font color="#FF0000">    ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type&gt; boundary_sieve = new PETSC_MESH_TYPE::sieve_type(m-&gt;comm(), m-&gt;debug());
<a name="line546">546: </a><strong><font color="#FF0000">    ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE&gt; boundary_mesh = new PETSC_MESH_TYPE(m-&gt;comm(), m-&gt;debug());
<a name="line547">547: </a>    boundary_mesh-&gt;setSieve(boundary_sieve);
<a name="line548">548: </a><strong><font color="#FF0000">    ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::label_type&gt; boundary_marker = boundary_mesh-&gt;createLabel(<font color="#666666">"marker"</font>);
<a name="line549">549: </a>    //rebuild the boundary, then coarsen it.
<a name="line550">550: </a>    <font color="#4169E1">if</font> (dim == 2) {
<a name="line551">551: </a>      boundary_mesh-&gt;setDimension(1);
<a name="line552">552: </a><strong><font color="#FF0000">      ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::label_sequence&gt; bndPoints = m-&gt;getLabelStratum(<font color="#666666">"marker"</font>, 1);
<a name="line553">553: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator b_iter = bndPoints-&gt;begin();
<a name="line554">554: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator b_iter_end = bndPoints-&gt;end();

<a name="line556">556: </a>      //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(),<font color="#666666">"Copying the Boundary Mesh: %d items\n"</font>, bndPoints-&gt;size());
<a name="line557">557: </a>      <font color="#4169E1">while</font> (b_iter != b_iter_end) {
<a name="line558">558: </a>        <font color="#4169E1">if</font> (m-&gt;height(*b_iter) &gt; 1) {
<a name="line559">559: </a><strong><font color="#FF0000">          ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::supportSequence&gt; bnd_support = m-&gt;getSieve()-&gt;support(*b_iter);
<a name="line560">560: </a><strong><font color="#FF0000">          PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSequence::iterator bs_iter = bnd_support-&gt;begin();
<a name="line561">561: </a><strong><font color="#FF0000">          PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSequence::iterator bs_iter_end = bnd_support-&gt;end();
<a name="line562">562: </a>          <font color="#4169E1">while</font> (bs_iter != bs_iter_end) {
<a name="line563">563: </a>            <font color="#4169E1">if</font> (m-&gt;getValue(boundary, *bs_iter) == 1) {
<a name="line564">564: </a>              boundary_sieve-&gt;addArrow(*b_iter, *bs_iter);
<a name="line565">565: </a>              boundary_mesh-&gt;setValue(boundary_marker, *bs_iter, 1);
<a name="line566">566: </a>            }
<a name="line567">567: </a>            bs_iter++;
<a name="line568">568: </a>          }
<a name="line569">569: </a>        }
<a name="line570">570: </a>        b_iter++;
<a name="line571">571: </a>      }
<a name="line572">572: </a>      //coarsen the 2D boundary mesh
<a name="line573">573: </a>      v_iter = vertices-&gt;begin();
<a name="line574">574: </a>      v_iter_end = vertices-&gt;end();
<a name="line575">575: </a>      <font color="#4169E1">while</font> (v_iter != v_iter_end) {
<a name="line576">576: </a>        <font color="#4169E1">if</font> (m-&gt;getValue(boundary, *v_iter) == 1 &amp;&amp; includedVertices-&gt;find(*v_iter) == includedVertices-&gt;end()) {
<a name="line577">577: </a>          //remove this one and reconnect its sides
<a name="line578">578: </a><strong><font color="#FF0000">          ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::supportSequence&gt; rem_support = boundary_sieve-&gt;support(*v_iter);
<a name="line579">579: </a><strong><font color="#FF0000">          PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSequence::iterator rs_iter = rem_support-&gt;begin();
<a name="line580">580: </a><strong><font color="#FF0000">          PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSequence::iterator rs_iter_end = rem_support-&gt;end();
<a name="line581">581: </a><strong><font color="#FF0000">          PETSC_MESH_TYPE:</font></strong>:point_type bnd_segments [2];
<a name="line582">582: </a><strong><font color="#FF0000">          PETSC_MESH_TYPE:</font></strong>:point_type endpts [2];
<a name="line583">583: </a>          int bnd_index = 0;
<a name="line584">584: </a>          <font color="#4169E1">while</font> (rs_iter != rs_iter_end) {
<a name="line585">585: </a>            bnd_segments[bnd_index] = *rs_iter;
<a name="line586">586: </a><strong><font color="#FF0000">            ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::coneSequence&gt; rs_cone = boundary_sieve-&gt;cone(*rs_iter);
<a name="line587">587: </a><strong><font color="#FF0000">            PETSC_MESH_TYPE:</font></strong>:sieve_type::coneSequence::iterator rsc_iter = rs_cone-&gt;begin();
<a name="line588">588: </a><strong><font color="#FF0000">            PETSC_MESH_TYPE:</font></strong>:sieve_type::coneSequence::iterator rsc_iter_end = rs_cone-&gt;end();
<a name="line589">589: </a>            <font color="#4169E1">while</font> (rsc_iter != rsc_iter_end) {
<a name="line590">590: </a>              <font color="#4169E1">if</font> (*rsc_iter != *v_iter) {
<a name="line591">591: </a>                endpts[bnd_index] = *rsc_iter;
<a name="line592">592: </a>              }
<a name="line593">593: </a>              rsc_iter++;
<a name="line594">594: </a>            }
<a name="line595">595: </a>            bnd_index++;
<a name="line596">596: </a>            rs_iter++;
<a name="line597">597: </a>          }
<a name="line598">598: </a>          boundary_sieve-&gt;removeBasePoint(bnd_segments[0]);
<a name="line599">599: </a>          boundary_sieve-&gt;removeCapPoint(*v_iter);
<a name="line600">600: </a>          boundary_sieve-&gt;addArrow(endpts[0], bnd_segments[1]);
<a name="line601">601: </a>          //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"taking %d -%d- %d -%d- %d to %d -%d- %d\n"</font>, endpts[0], bnd_segments[0], *v_iter, bnd_segments[1], endpts[1], endpts[0], bnd_segments[1], endpts[1]);
<a name="line602">602: </a>          //boundary_sieve-&gt;view();
<a name="line603">603: </a>        }
<a name="line604">604: </a>        v_iter++;
<a name="line605">605: </a>      }
<a name="line606">606: </a>    } <font color="#4169E1">else</font> <font color="#4169E1">if</font> (dim == 3) {
<a name="line607">607: </a>      boundary_mesh-&gt;setDimension(2);
<a name="line608">608: </a>    }
<a name="line609">609: </a>    //insert the interior vertices
<a name="line610">610: </a>    v_iter = vertices-&gt;begin();
<a name="line611">611: </a>    v_iter_end = vertices-&gt;end();
<a name="line612">612: </a>    <font color="#4169E1">while</font> (v_iter != v_iter_end) {
<a name="line613">613: </a>      <font color="#4169E1">if</font> ((!boundary_sieve-&gt;hasPoint(*v_iter)) &amp;&amp; (includedVertices-&gt;find(*v_iter) != includedVertices-&gt;end())) {
<a name="line614">614: </a>        boundary_sieve-&gt;addCapPoint(*v_iter);
<a name="line615">615: </a>        <font color="#4169E1">if</font> (m-&gt;getValue(boundary, *v_iter) == 1) boundary_mesh-&gt;setValue(boundary_marker, *v_iter, 1);
<a name="line616">616: </a>      }
<a name="line617">617: </a>      v_iter++;
<a name="line618">618: </a>    }
<a name="line619">619: </a>    boundary_mesh-&gt;stratify();
<a name="line620">620: </a>    //set the boundary meshes coordinate section
<a name="line621">621: </a>    boundary_mesh-&gt;setRealSection(<font color="#666666">"coordinates"</font>, m-&gt;getRealSection(<font color="#666666">"coordinates"</font>));

<a name="line623">623: </a><font color="#A020F0">#if 0    </font>
<a name="line624">624: </a>    //boundary_sieve-&gt;view();
<a name="line625">625: </a>    //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(),<font color="#666666">"Copied the Boundary Mesh: %d vertices, %d edges\n"</font>, boundary_mesh-&gt;depthStratum(0)-&gt;size(), boundary_mesh-&gt;depthStratum(1)-&gt;size());
<a name="line626">626: </a>    //call triangle or tetgen: turns out the options we want on are the same
<a name="line627">627: </a>    //std::string triangleOptions = <font color="#666666">"zQp"</font>; //(z)ero indexing, output (e)dges, Quiet
<a name="line628">628: </a>    double * finalcoords;
<a name="line629">629: </a>    int * connectivity;
<a name="line630">630: </a>    int * oldpositions;
<a name="line631">631: </a>    int nelements;
<a name="line632">632: </a>    int nverts;
<a name="line633">633: </a>    <font color="#4169E1">if</font> (dim == 2) {
<a name="line634">634: </a><font color="#A020F0">#ifdef PETSC_HAVE_TRIANGLE</font>
<a name="line635">635: </a>     boundary_mesh-&gt;stratify();
<a name="line636">636: </a><strong><font color="#FF0000">     ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::label_type&gt; numbering = boundary_mesh-&gt;createLabel(<font color="#666666">"numbering"</font>);
<a name="line637">637: </a>       //now, take the edges of this sieve and use them to construct a segmentlist.
<a name="line638">638: </a>       //ALE::Obj&lt;PETSC_MESH_TYPE::numbering_type&gt; bnd_vertices_numbering  = boundary_mesh-&gt;getFactory()-&gt;getNumbering(boundary_mesh, 0);
<a name="line639">639: </a>       //ALE::Obj&lt;PETSC_MESH_TYPE::numbering_type&gt; bnd_edges_numbering = boundary_mesh-&gt;getFactory()-&gt;getNumbering(boundary_mesh, 1);
<a name="line640">640: </a>
<a name="line641">641: </a>       //copy over the boundary vertex coordinates:
<a name="line642">642: </a><strong><font color="#FF0000">       ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::label_sequence&gt; bnd_vertices = boundary_mesh-&gt;depthStratum(0);
<a name="line643">643: </a><strong><font color="#FF0000">       PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator bndv_iter = bnd_vertices-&gt;begin();
<a name="line644">644: </a><strong><font color="#FF0000">       PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator bndv_iter_end = bnd_vertices-&gt;end();
<a name="line645">645: </a>       <font color="#4169E1">while</font> (bndv_iter != bndv_iter_end) {
<a name="line646">646: </a>         tmpcoords = coordinates-&gt;restrictPoint(*bndv_iter);
<a name="line647">647: </a>         <font color="#4169E1">for</font> (int j = 0; j &lt; dim; j++) {
<a name="line648">648: </a>            coords[dim*index+j] = tmpcoords[j];
<a name="line649">649: </a>            boundary_mesh-&gt;setValue(numbering, *bndv_iter, index);
<a name="line650">650: </a>            //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"%d\n"</font>, index);
<a name="line651">651: </a>         }
<a name="line652">652: </a>         indices[index] = *bndv_iter;
<a name="line653">653: </a>         bndv_iter++;
<a name="line654">654: </a>         index++;
<a name="line655">655: </a>      }
<a name="line656">656: </a><strong><font color="#FF0000">      ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::label_sequence&gt; bnd_edges = boundary_mesh-&gt;depthStratum(1);
<a name="line657">657: </a>      int segments[2*bnd_edges-&gt;size()];
<a name="line658">658: </a>      int nSegments = bnd_edges-&gt;size();
<a name="line659">659: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator bnde_iter = bnd_edges-&gt;begin();
<a name="line660">660: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator bnde_iter_end = bnd_edges-&gt;end();
<a name="line661">661: </a>      int bnd_index = 0;
<a name="line662">662: </a>      <font color="#4169E1">while</font> (bnde_iter != bnde_iter_end) {
<a name="line663">663: </a><strong><font color="#FF0000">        ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::coneSequence&gt; bnde_cone = boundary_sieve-&gt;cone(*bnde_iter);
<a name="line664">664: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:sieve_type::coneSequence::iterator bndec_iter = bnde_cone-&gt;begin();
<a name="line665">665: </a>        segments[2*bnd_index] = boundary_mesh-&gt;getValue(numbering, *bndec_iter);
<a name="line666">666: </a>        bndec_iter++;
<a name="line667">667: </a>        segments[2*bnd_index + 1] = boundary_mesh-&gt;getValue(numbering, *bndec_iter);
<a name="line668">668: </a>        bnd_index++;
<a name="line669">669: </a>        bnde_iter++;
<a name="line670">670: </a>      }

<a name="line672">672: </a>     //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(),<font color="#666666">"Created the segmentlist\n"</font>);
<a name="line673">673: </a>      <font color="#4169E1">for</font> (int i = curLevel; i &lt; nLevels; i++) {
<a name="line674">674: </a>        //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"level %d\n"</font>, i);
<a name="line675">675: </a><strong><font color="#FF0000">        ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::label_sequence&gt; curLevVerts = m-&gt;getLabelStratum(<font color="#666666">"hdepth"</font>, i);
<a name="line676">676: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator clv_iter = curLevVerts-&gt;begin();
<a name="line677">677: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator clv_iter_end = curLevVerts-&gt;end();
<a name="line678">678: </a>          <font color="#4169E1">while</font> (clv_iter != clv_iter_end) {
<a name="line679">679: </a>            <font color="#4169E1">if</font> (m-&gt;getValue(boundary, *clv_iter) != 1) {
<a name="line680">680: </a>            tmpcoords = coordinates-&gt;restrictPoint(*clv_iter);
<a name="line681">681: </a>            <font color="#4169E1">for</font> (int j = 0; j &lt; dim; j++) {
<a name="line682">682: </a>              coords[index*dim+j] = tmpcoords[j];
<a name="line683">683: </a>            }
<a name="line684">684: </a>            indices[index] = *clv_iter;
<a name="line685">685: </a>            //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"%d\n"</font>, index);
<a name="line686">686: </a>            index++;
<a name="line687">687: </a>          }
<a name="line688">688: </a>          clv_iter++;
<a name="line689">689: </a>        }
<a name="line690">690: </a>      }
<a name="line691">691: </a>     //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(),<font color="#666666">"Triangulate\n"</font>);
<a name="line692">692: </a>      //create a segmentlist to keep triangle from doing dumb things.
<a name="line693">693: </a>      triangulateio tridata[2];
<a name="line694">694: </a>      SetupTriangulateio(&amp;tridata[0], &amp;tridata[1]);
<a name="line695">695: </a>      tridata[0].segmentlist = segments;
<a name="line696">696: </a>      tridata[0].numberofsegments = nSegments;
<a name="line697">697: </a>      tridata[0].pointlist = coords;
<a name="line698">698: </a>      tridata[0].numberofpoints = curmeshsize;
<a name="line699">699: </a>      tridata[0].pointmarkerlist = indices;
<a name="line700">700: </a>      //triangulate
<a name="line701">701: </a>      triangulate((char *)triangleOptions.c_str(), &amp;tridata[0], &amp;tridata[1], NULL);
<a name="line702">702: </a>      finalcoords = tridata[1].pointlist;
<a name="line703">703: </a>      connectivity = tridata[1].trianglelist;
<a name="line704">704: </a>      oldpositions = tridata[1].pointmarkerlist;
<a name="line705">705: </a>      nelements = tridata[1].numberoftriangles;
<a name="line706">706: </a>      nverts = tridata[1].numberofpoints;
<a name="line707">707: </a><font color="#A020F0">#else</font>
<a name="line708">708: </a>      throw ALE::Exception(<font color="#666666">"Must have Triangle installed to use this method. Reconfigure with --download-triangle"</font>);
<a name="line709">709: </a><font color="#A020F0">#endif</font>
<a name="line710">710: </a>    } <font color="#4169E1">else</font> <font color="#4169E1">if</font> (dim == 3) {
<a name="line711">711: </a><font color="#A020F0">#ifdef PETSC_HAVE_TETGEN</font>
<a name="line712">712: </a><strong><font color="#FF0000">      std:</font></strong>:string tetgenOptions = <font color="#666666">"zQe"</font>; //(z)ero indexing, output (e)dges, Quiet
<a name="line713">713: </a>      <font color="#4169E1">for</font> (int i = curLevel; i &lt; nLevels; i++) {
<a name="line714">714: </a><strong><font color="#FF0000">        ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::label_sequence&gt; curLevVerts = m-&gt;getLabelStratum(<font color="#666666">"hdepth"</font>, i);
<a name="line715">715: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator clv_iter = curLevVerts-&gt;begin();
<a name="line716">716: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator clv_iter_end = curLevVerts-&gt;end();
<a name="line717">717: </a>          <font color="#4169E1">while</font> (clv_iter != clv_iter_end) {
<a name="line718">718: </a>            tmpcoords = coordinates-&gt;restrictPoint(*clv_iter);
<a name="line719">719: </a>            <font color="#4169E1">for</font> (int j = 0; j &lt; dim; j++) {
<a name="line720">720: </a>              coords[index*dim+j] = tmpcoords[j];
<a name="line721">721: </a>            }
<a name="line722">722: </a>            indices[index] = *clv_iter;
<a name="line723">723: </a>            index++;
<a name="line724">724: </a>            clv_iter++;
<a name="line725">725: </a>        }
<a name="line726">726: </a>      }
<a name="line727">727: </a>      tetgenio * tetdata = new tetgenio[2];
<a name="line728">728: </a>      //push the points into the thing
<a name="line729">729: </a>      tetdata[0].pointlist = coords;
<a name="line730">730: </a>      tetdata[0].pointmarkerlist = indices;
<a name="line731">731: </a>      tetdata[0].numberofpoints = curmeshsize;
<a name="line732">732: </a>      //tetrahedralize
<a name="line733">733: </a>      tetrahedralize((char *)tetgenOptions.c_str(), &amp;tetdata[0], &amp;tetdata[1]);
<a name="line734">734: </a>      finalcoords = tetdata[1].pointlist;
<a name="line735">735: </a>      connectivity = tetdata[1].tetrahedronlist;
<a name="line736">736: </a>      oldpositions = tetdata[1].pointmarkerlist;
<a name="line737">737: </a>      nelements = tetdata[1].numberoftetrahedra;
<a name="line738">738: </a>      nverts = tetdata[1].numberofpoints;
<a name="line739">739: </a><font color="#A020F0">#else</font>
<a name="line740">740: </a>      throw ALE::Exception(<font color="#666666">"Must have TetGen installed to use this method. Reconfigure with --download-tetgen"</font>);
<a name="line741">741: </a><font color="#A020F0">#endif</font>
<a name="line742">742: </a>    }
<a name="line743">743: </a>    //make it into a mesh;
<a name="line744">744: </a><strong><font color="#FF0000">    ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE&gt; newmesh = new PETSC_MESH_TYPE(m-&gt;comm(), m-&gt;debug());
<a name="line745">745: </a>    newmesh-&gt;setDimension(dim);
<a name="line746">746: </a><strong><font color="#FF0000">    ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type&gt; sieve = new PETSC_MESH_TYPE::sieve_type(m-&gt;comm(), m-&gt;debug());
<a name="line747">747: </a><strong><font color="#FF0000">    ALE:</font></strong>:SieveBuilder&lt;PETSC_MESH_TYPE&gt;::buildTopology(sieve, dim, nelements, connectivity, nverts, true, dim+1, -1, newmesh-&gt;getArrowSection(<font color="#666666">"orientation"</font>));
<a name="line748">748: </a>    newmesh-&gt;setSieve(sieve);
<a name="line749">749: </a>    newmesh-&gt;stratify();
<a name="line750">750: </a>    //UPDATE THE MARKER AND FINEMESH VERTEX NUMBERING LABELS
<a name="line751">751: </a><strong><font color="#FF0000">    ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::label_type&gt; boundary_new = newmesh-&gt;createLabel(<font color="#666666">"marker"</font>);
<a name="line752">752: </a><strong><font color="#FF0000">    ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::label_type&gt; fine_corresponds = newmesh-&gt;createLabel(<font color="#666666">"fine"</font>);
<a name="line753">753: </a><strong><font color="#FF0000">    ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::label_sequence&gt; newverts = newmesh-&gt;depthStratum(0);
<a name="line754">754: </a><strong><font color="#FF0000">    PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator nv_iter = newverts-&gt;begin();
<a name="line755">755: </a><strong><font color="#FF0000">    PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator nv_iter_end = newverts-&gt;end();
<a name="line756">756: </a>    <font color="#4169E1">while</font> (nv_iter != nv_iter_end) {
<a name="line757">757: </a>      newmesh-&gt;setValue(fine_corresponds, *nv_iter, oldpositions[*nv_iter - nelements]);
<a name="line758">758: </a>      <font color="#4169E1">if</font>(m-&gt;getValue(boundary, oldpositions[*nv_iter - nelements]) == 1) newmesh-&gt;setValue(boundary_new, *nv_iter, 1);
<a name="line759">759: </a>      nv_iter++;
<a name="line760">760: </a>    }
<a name="line761">761: </a><font color="#A020F0">#endif //end of LONG if 0</font>
<a name="line762">762: </a>    <font color="#4169E1">if</font> (dim == 3) {// HACKED UP: set the height of the vertices to be <font color="#666666">"1"</font>
<a name="line763">763: </a><strong><font color="#FF0000">      ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::label_sequence&gt; bound_verts = boundary_mesh-&gt;depthStratum(0);
<a name="line764">764: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator bv_iter = bound_verts-&gt;begin();
<a name="line765">765: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator bv_iter_end = bound_verts-&gt;end();
<a name="line766">766: </a><strong><font color="#FF0000">      ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::label_type&gt; bound_height = boundary_mesh-&gt;getLabel(<font color="#666666">"height"</font>);
<a name="line767">767: </a>      <font color="#4169E1">while</font> (bv_iter != bv_iter_end) {
<a name="line768">768: </a>        boundary_mesh-&gt;setValue(bound_height, *bv_iter, 1);
<a name="line769">769: </a>        bv_iter++;
<a name="line770">770: </a>      }
<a name="line771">771: </a>    }
<a name="line772">772: </a>    //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"%d, %d\n"</font>, boundary_mesh-&gt;depthStratum(0)-&gt;size(), boundary_mesh-&gt;heightStratum(0)-&gt;size());
<a name="line773">773: </a><strong><font color="#FF0000">    ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE&gt; newmesh = ALE::Generator&lt;PETSC_MESH_TYPE&gt;::generateMesh(boundary_mesh, (m-&gt;depth() != 1), true);
<a name="line774">774: </a>    //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"%d, %d\n"</font>, newmesh-&gt;depthStratum(0)-&gt;size(), newmesh-&gt;heightStratum(0)-&gt;size());
<a name="line775">775: </a><strong><font color="#FF0000">    ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::real_section_type&gt; s = newmesh-&gt;getRealSection(<font color="#666666">"</font><font color="#4169E1">default</font>");
<a name="line776">776: </a>    const Obj&lt;std::set&lt;std::string&gt; &gt;&amp; discs = m-&gt;getDiscretizations();
<a name="line777">777: </a>    //set up the <font color="#4169E1">default</font> section
<a name="line778">778: </a>    <font color="#4169E1">for</font>(std::set&lt;std::string&gt;::const_iterator f_iter = discs-&gt;begin(); f_iter != discs-&gt;end(); ++f_iter) {
<a name="line779">779: </a>      newmesh-&gt;setDiscretization(*f_iter, m-&gt;getDiscretization(*f_iter));
<a name="line780">780: </a>     }
<a name="line781">781: </a>    newmesh-&gt;setupField(s);
<a name="line782">782: </a>    newmesh-&gt;markBoundaryCells(<font color="#666666">"marker"</font>, 1, 2, true);
<a name="line783">783: </a>    <font color="#4169E1">return</font> newmesh;
<a name="line784">784: </a>}

<a name="line786">786: </a><font color="#A020F0">#else</font>


<a name="line789">789: </a><strong><font color="#FF0000">ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE&gt; MeshCreateHierarchyMesh(ALE::Obj&lt;PETSC_MESH_TYPE&gt; m, ALE::Obj&lt;PETSC_MESH_TYPE::sieve_type::supportSet&gt; includedVertices) {
<a name="line790">790: </a>  throw ALE::Exception(<font color="#666666">"reconfigure PETSc with --download-triangle and --download-tetgen to use this method."</font>);
<a name="line791">791: </a>  <font color="#4169E1">return</font> m;
<a name="line792">792: </a>}

<a name="line794">794: </a><font color="#A020F0">#endif</font>


<a name="line799">799: </a><A href="../../../../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode">PetscErrorCode</A> MeshCreateHierarchyLabel_Link(Mesh finemesh, double beta, int nLevels, Mesh * outmeshes, <A href="../../../../docs/manualpages/Mat/Mat.html#Mat">Mat</A> * outmats = <A href="../../../../docs/manualpages/Sys/PETSC_NULL.html#PETSC_NULL">PETSC_NULL</A>, double curvatureCutoff = 1.0) {
<a name="line801">801: </a>

<a name="line804">804: </a>  //initialization
<a name="line805">805: </a><strong><font color="#FF0000">  ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE&gt; m;
<a name="line806">806: </a><strong><font color="#FF0000">  ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::supportSet&gt; includedVertices = new PETSC_MESH_TYPE::sieve_type::supportSet();
<a name="line807">807: </a>  includedVertices-&gt;clear();
<a name="line808">808: </a>  int nComparisons;
<a name="line809">809: </a>  <A href="../../../../docs/manualpages/Sys/PetscTruth.html#PetscTruth">PetscTruth</A> info;
<a name="line810">810: </a>  <A href="../../../../docs/manualpages/Sys/PetscOptionsHasName.html#PetscOptionsHasName">PetscOptionsHasName</A>(<A href="../../../../docs/manualpages/Sys/PETSC_NULL.html#PETSC_NULL">PETSC_NULL</A>, <font color="#666666">"-dmmg_coarsen_info"</font>, &amp;info);
<a name="line811">811: </a>  double nComparisons_perPoint_Total = 0.;
<a name="line812">812: </a>  double maxspace = -1., minspace = -1., dist, current_beta;
<a name="line813">813: </a>  double n_space, c_space, v_space;
<a name="line814">814: </a>  double n_coords[3], c_coords[3];
<a name="line815">815: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:point_type v_point;
<a name="line816">816: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:point_type c_point, n_point;
<a name="line817">817: </a>  int v_bound;
<a name="line818">818: </a>
<a name="line819">819: </a><strong><font color="#FF0000">  std:</font></strong>:list&lt;PETSC_MESH_TYPE::point_type&gt; comparison_list;
<a name="line820">820: </a><strong><font color="#FF0000">  std:</font></strong>:list&lt;PETSC_MESH_TYPE::point_type&gt; coarsen_candidates;
<a name="line821">821: </a><strong><font color="#FF0000">  std:</font></strong>:list&lt;PETSC_MESH_TYPE::point_type&gt; support_list;
<a name="line822">822: </a>
<a name="line823">823: </a>  <A href="../../../../docs/manualpages/Mesh/MeshGetMesh.html#MeshGetMesh">MeshGetMesh</A>(finemesh, m);
<a name="line824">824: </a>  int interplevels = m-&gt;height(*m-&gt;depthStratum(0)-&gt;begin());
<a name="line825">825: </a>  //<font color="#4169E1">if</font> (interplevels == 1) { //noninterpolated <font color="#4169E1">case</font> -- fix later as join is broken
<a name="line826">826: </a>  //  throw ALE::Exception(<font color="#666666">"Cannot Coarsen a Non-Interpolated Mesh (for now, fix is easy)"</font>);
<a name="line827">827: </a>  //}
<a name="line828">828: </a>  int dim = m-&gt;getDimension();

<a name="line830">830: </a>  <font color="#4169E1">if</font> (!m-&gt;hasLabel(<font color="#666666">"marker"</font>))MeshIDBoundary(finemesh);
<a name="line831">831: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::label_type&gt;&amp; boundary = m-&gt;getLabel(<font color="#666666">"marker"</font>);

<a name="line833">833: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::real_section_type&gt;&amp; coordinates = m-&gt;getRealSection(<font color="#666666">"coordinates"</font>);
<a name="line834">834: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::real_section_type&gt;&amp; spacing = m-&gt;getRealSection(<font color="#666666">"spacing"</font>);
<a name="line835">835: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::int_section_type&gt;&amp; seen = m-&gt;getIntSection(<font color="#666666">"seen"</font>);
<a name="line836">836: </a>  seen-&gt;setFiberDimension(m-&gt;depthStratum(0), 1);
<a name="line837">837: </a>  m-&gt;allocate(seen);
<a name="line838">838: </a>  //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"allocated seen"</font>);
<a name="line839">839: </a>  //const ALE::Obj&lt;PETSC_MESH_TYPE::label_type&gt; hdepth = m-&gt;createLabel(<font color="#666666">"hdepth"</font>);
<a name="line840">840: </a>  <font color="#4169E1">if</font> (info)<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"Original Mesh: %d vertices, %d elements\n"</font>, m-&gt;depthStratum(0)-&gt;size(), m-&gt;heightStratum(0)-&gt;size());
<a name="line841">841: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::sieve_type&gt; sieve = m-&gt;getSieve();
<a name="line842">842: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::label_sequence&gt;&amp; vertices = m-&gt;depthStratum(0);
<a name="line843">843: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator v_iter = vertices-&gt;begin();
<a name="line844">844: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator v_iter_end = vertices-&gt;end();
<a name="line845">845: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:point_type max_vertex_index = -1;

<a name="line847">847: </a>  //Setup, find the minimum and maximum spacing values and force in high-curvature nodes.

<a name="line849">849: </a>  <font color="#4169E1">while</font>(v_iter != v_iter_end) {

<a name="line851">851: </a>    v_point = *v_iter;
<a name="line852">852: </a>    v_bound = m-&gt;getValue(boundary, v_point);
<a name="line853">853: </a>    //m-&gt;setValue(hdepth, v_point, 0);
<a name="line854">854: </a>    v_space = *spacing-&gt;restrictPoint(v_point);
<a name="line855">855: </a>    <font color="#4169E1">if</font> (*v_iter &gt; max_vertex_index) max_vertex_index = *v_iter;
<a name="line856">856: </a>    <font color="#4169E1">if</font> ((v_space &gt; maxspace) || (maxspace == -1.)) maxspace = v_space;
<a name="line857">857: </a>    <font color="#4169E1">if</font> ((v_space &lt; minspace) || (minspace == -1.)) minspace = v_space;
<a name="line858">858: </a>    <font color="#4169E1">if</font> (m-&gt;depth(v_point) == 0 &amp;&amp; v_bound == 1) {
<a name="line859">859: </a>        double cur_curvature = Curvature(m, v_point);
<a name="line860">860: </a>        <font color="#4169E1">if</font> (info &amp;&amp; fabs(cur_curvature) &gt; curvatureCutoff) <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"Curvy point: %f\n"</font>, cur_curvature);
<a name="line861">861: </a>        <font color="#4169E1">if</font> (fabs(cur_curvature) &gt; curvatureCutoff) includedVertices-&gt;insert(*v_iter);
<a name="line862">862: </a>    }
<a name="line863">863: </a>    int pt_val = 0;
<a name="line864">864: </a>    seen-&gt;updatePoint(*v_iter, &amp;pt_val);
<a name="line865">865: </a>    v_iter++;
<a name="line866">866: </a>  }
<a name="line867">867: </a>  <font color="#4169E1">for</font> (int curLevel = nLevels-1; curLevel &gt; 0; curLevel--) {
<a name="line868">868: </a>    coarsen_candidates.clear();
<a name="line869">869: </a>    nComparisons = 0;
<a name="line870">870: </a>    current_beta = pow(beta, curLevel);
<a name="line871">871: </a>    <font color="#4169E1">if</font> (info) <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"coarsening by %f\n"</font>, current_beta);
<a name="line872">872: </a>    //recopy the first two levels of the sieve into a new sieve.
<a name="line873">873: </a><strong><font color="#FF0000">    ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type&gt; coarsen_sieve = new PETSC_MESH_TYPE::sieve_type(m-&gt;comm(), m-&gt;debug());
<a name="line874">874: </a><strong><font color="#FF0000">    ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE&gt; coarsen_mesh = new PETSC_MESH_TYPE(m-&gt;comm(), m-&gt;debug());
<a name="line875">875: </a>    coarsen_mesh-&gt;setSieve(coarsen_sieve);
<a name="line876">876: </a>    //INEFFICIENT!
<a name="line877">877: </a>    coarsen_candidates.clear();
<a name="line878">878: </a>    //ALE::Obj&lt;PETSC_MESH_TYPE::label_type&gt; coarsen_candidates = m-&gt;createLabel(<font color="#666666">"candidates"</font>);
<a name="line879">879: </a>    v_iter = vertices-&gt;begin();
<a name="line880">880: </a>    v_iter_end = vertices-&gt;end();
<a name="line881">881: </a>    <font color="#4169E1">if</font> (interplevels &gt; 1) { //interpolated <font color="#4169E1">case</font>; merely copy the edges out
<a name="line882">882: </a>      <font color="#4169E1">while</font> (v_iter != v_iter_end) {
<a name="line883">883: </a><strong><font color="#FF0000">        ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::supportSequence&gt; adjacent_edges = sieve-&gt;support(*v_iter);
<a name="line884">884: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSequence::iterator ae_iter = adjacent_edges-&gt;begin();
<a name="line885">885: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSequence::iterator ae_iter_end = adjacent_edges-&gt;end();
<a name="line886">886: </a>        <font color="#4169E1">while</font> (ae_iter != ae_iter_end) {
<a name="line887">887: </a>          coarsen_sieve-&gt;addArrow(*v_iter, *ae_iter);
<a name="line888">888: </a>          ae_iter++;
<a name="line889">889: </a>        }
<a name="line890">890: </a>        v_iter++;
<a name="line891">891: </a>      }
<a name="line892">892: </a>    } <font color="#4169E1">else</font> { //noninterpolated <font color="#4169E1">case</font>, build the edges
<a name="line893">893: </a>      //PETSC_MESH_TYPE::sieve_type::supportSet seen; sets have logarithmic complexity
<a name="line894">894: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:point_type min_coarsen_edge_index = max_vertex_index + 1;
<a name="line895">895: </a>      <font color="#4169E1">while</font> (v_iter != v_iter_end) {
<a name="line896">896: </a>        //get the neighbors of this point
<a name="line897">897: </a><strong><font color="#FF0000">        ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::coneSet&gt; mockup_edge_endpoints = sieve-&gt;cone(sieve-&gt;support(*v_iter));
<a name="line898">898: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:sieve_type::coneSet::iterator m_iter = mockup_edge_endpoints-&gt;begin();
<a name="line899">899: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:sieve_type::coneSet::iterator m_iter_end = mockup_edge_endpoints-&gt;end();
<a name="line900">900: </a>        <font color="#4169E1">while</font> (m_iter != m_iter_end) {
<a name="line901">901: </a>          <font color="#4169E1">if</font> (*m_iter != *v_iter &amp;&amp; *seen-&gt;restrictPoint(*m_iter) == 0) {
<a name="line902">902: </a>            coarsen_sieve-&gt;addArrow(*v_iter, min_coarsen_edge_index);
<a name="line903">903: </a>            coarsen_sieve-&gt;addArrow(*m_iter, min_coarsen_edge_index);
<a name="line904">904: </a>            min_coarsen_edge_index++;
<a name="line905">905: </a>          }
<a name="line906">906: </a>          m_iter++;
<a name="line907">907: </a>        }
<a name="line908">908: </a>        int pt_val = 1;
<a name="line909">909: </a>        seen-&gt;updatePoint(*v_iter, &amp;pt_val);
<a name="line910">910: </a>        v_iter++;
<a name="line911">911: </a>      }
<a name="line912">912: </a>    }
<a name="line913">913: </a>    coarsen_mesh-&gt;stratify();
<a name="line914">914: </a>    //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(coarsen_mesh-&gt;comm(), <font color="#666666">"%d vertices, %d edges in the coarsen structure\n"</font>, coarsen_mesh-&gt;depthStratum(0)-&gt;size(), coarsen_mesh-&gt;heightStratum(0)-&gt;size());
<a name="line915">915: </a>    //Interior Pass: Eliminate Nodes that collide with already included nodes or the boundary.
<a name="line916">916: </a>    //now, take the points that neighbor the already included points in the main sieve AND THE BOUNDARY:
<a name="line917">917: </a>    //<font color="#4169E1">for</font> (int compare_marker = 1; compare_marker &lt;= 2; compare_marker++) { //two passes, interior and boundary
<a name="line918">918: </a>    v_iter = vertices-&gt;begin();
<a name="line919">919: </a>    v_iter_end = vertices-&gt;end();
<a name="line920">920: </a>    <font color="#4169E1">while</font> (v_iter != v_iter_end) {
<a name="line921">921: </a>      <font color="#4169E1">if</font> ((includedVertices-&gt;find(*v_iter) != includedVertices-&gt;end()) || (m-&gt;getValue(boundary, *v_iter) == 1)) {
<a name="line922">922: </a><strong><font color="#FF0000">        ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::supportSequence&gt; tangent_edges = coarsen_sieve-&gt;support(*v_iter);
<a name="line923">923: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSequence::iterator te_iter = tangent_edges-&gt;begin();
<a name="line924">924: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSequence::iterator te_iter_end = tangent_edges-&gt;end();
<a name="line925">925: </a>        <font color="#4169E1">while</font> (te_iter != te_iter_end) {
<a name="line926">926: </a>          <font color="#4169E1">if</font> ((m-&gt;getValue(boundary, *te_iter) == 0)) {
<a name="line927">927: </a>            comparison_list.push_back(*te_iter);
<a name="line928">928: </a>          }
<a name="line929">929: </a>          te_iter++;
<a name="line930">930: </a>        }
<a name="line931">931: </a>      }
<a name="line932">932: </a>      <font color="#4169E1">if</font> ((includedVertices-&gt;find(*v_iter) == includedVertices-&gt;end()) &amp;&amp; (m-&gt;getValue(boundary, *v_iter) == 0)) {
<a name="line933">933: </a>        //m-&gt;setValue(coarsen_candidates, *v_iter, 1);
<a name="line934">934: </a>        coarsen_candidates.push_front(*v_iter);
<a name="line935">935: </a>      }
<a name="line936">936: </a>      v_iter++;
<a name="line937">937: </a>    }
<a name="line938">938: </a>    //Interior Run: Treat the boundaries as barriers
<a name="line939">939: </a>    bool notDone = true;
<a name="line940">940: </a>    <font color="#4169E1">while</font> (notDone) {
<a name="line941">941: </a>    <font color="#4169E1">while</font> (!comparison_list.empty()){
<a name="line942">942: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:point_type c_edge = *comparison_list.begin();
<a name="line943">943: </a>      comparison_list.pop_front();
<a name="line944">944: </a>      //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"comparing across edge %d\n"</font>, c_edge);
<a name="line945">945: </a><strong><font color="#FF0000">      ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::coneSequence&gt; end_points = coarsen_sieve-&gt;cone(c_edge);
<a name="line946">946: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:sieve_type::coneSequence::iterator ep_iter = end_points-&gt;begin();
<a name="line947">947: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:point_type ep_1 = *ep_iter;
<a name="line948">948: </a>      ep_iter++;
<a name="line949">949: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:point_type  ep_2 = *ep_iter;
<a name="line950">950: </a>      bool ep_1_hdepth = (includedVertices-&gt;find(ep_1) != includedVertices-&gt;end()); //m-&gt;getValue(hdepth, ep_1);
<a name="line951">951: </a>      bool ep_2_hdepth = (includedVertices-&gt;find(ep_2) != includedVertices-&gt;end());//m-&gt;getValue(hdepth, ep_2);
<a name="line952">952: </a>      int ep_1_bound = m-&gt;getValue(boundary, ep_1);
<a name="line953">953: </a>      int ep_2_bound = m-&gt;getValue(boundary, ep_2);
<a name="line954">954: </a>      bool ep_1_dominates = ((ep_1_hdepth == true)  || ((ep_1_bound == 1)));
<a name="line955">955: </a>      bool ep_2_dominates = ((ep_2_hdepth == true)  || ((ep_2_bound == 1)));
<a name="line956">956: </a>      //<font color="#4169E1">if</font> ((!ep_1_dominates) &amp;&amp; (!ep_2_dominates)) {
<a name="line957">957: </a>      //  <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(),<font color="#666666">"%d, %d\n"</font>, ep_1_bound, ep_2_bound);
<a name="line958">958: </a>      //  throw ALE::Exception(<font color="#666666">"Coarse To Coarse Comparison: This Should Not Have Happened"</font>);
<a name="line959">959: </a>      //}
<a name="line960">960: </a>      <font color="#4169E1">if</font> ((!ep_1_dominates &amp;&amp; ep_2_dominates) || (ep_1_dominates &amp;&amp; !ep_2_dominates)) {
<a name="line961">961: </a>        <font color="#4169E1">if</font> (ep_1_dominates) {
<a name="line962">962: </a>        c_point = ep_2;
<a name="line963">963: </a>        n_point = ep_1;
<a name="line964">964: </a>        } <font color="#4169E1">else</font> {
<a name="line965">965: </a>         c_point = ep_1;
<a name="line966">966: </a>         n_point = ep_2;
<a name="line967">967: </a>        }
<a name="line968">968: </a>        nComparisons++;
<a name="line969">969: </a>        <A href="../../../../docs/manualpages/Sys/PetscMemcpy.html#PetscMemcpy">PetscMemcpy</A>(c_coords, coordinates-&gt;restrictPoint(c_point), dim*<font color="#4169E1">sizeof</font>(double));
<a name="line970">970: </a>        c_space = *spacing-&gt;restrictPoint(c_point);
<a name="line971">971: </a>        <A href="../../../../docs/manualpages/Sys/PetscMemcpy.html#PetscMemcpy">PetscMemcpy</A>(n_coords, coordinates-&gt;restrictPoint(n_point), dim*<font color="#4169E1">sizeof</font>(double));
<a name="line972">972: </a>        n_space = *spacing-&gt;restrictPoint(n_point);
<a name="line973">973: </a>        dist = 0.;
<a name="line974">974: </a>        <font color="#4169E1">for</font> (int i = 0; i &lt; dim; i++) {
<a name="line975">975: </a>            dist += (n_coords[i] - c_coords[i])*(n_coords[i] - c_coords[i]);
<a name="line976">976: </a>        }
<a name="line977">977: </a>        dist = sqrt(dist);
<a name="line978">978: </a>        <font color="#4169E1">if</font> (dist &lt; current_beta*(n_space + c_space)) {
<a name="line979">979: </a>          //remove the point and this edge from existence and link its neighbors up with the eliminating point, adding the neighboring edges to THE LIST.
<a name="line980">980: </a>          //m-&gt;setValue(coarsen_candidates, c_point, 0);

<a name="line982">982: </a>          //Replace this with a more intelligent topology reconnection eventually.

<a name="line984">984: </a><strong><font color="#FF0000">          ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::supportSequence&gt; move_these_edges = coarsen_sieve-&gt;support(c_point);
<a name="line985">985: </a><strong><font color="#FF0000">          PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSequence::iterator mte_iter = move_these_edges-&gt;begin();
<a name="line986">986: </a><strong><font color="#FF0000">          PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSequence::iterator mte_iter_end = move_these_edges-&gt;end();

<a name="line988">988: </a>          <font color="#4169E1">while</font> (mte_iter != mte_iter_end) {
<a name="line989">989: </a>            <font color="#4169E1">if</font> (*mte_iter != c_edge) {
<a name="line990">990: </a>              coarsen_sieve-&gt;addArrow(n_point, *mte_iter);
<a name="line991">991: </a>              <font color="#4169E1">if</font> (coarsen_sieve-&gt;cone(*mte_iter)-&gt;size() == 2) {  //it's one of the edges that should be eliminated here, don't compare across it.
<a name="line992">992: </a>                support_list.push_front(*mte_iter); //save <font color="#4169E1">for</font> elimination because we don't want to screw up the iterator
<a name="line993">993: </a>              } <font color="#4169E1">else</font> { //compare across the just-changed edge
<a name="line994">994: </a>                comparison_list.push_back(*mte_iter);
<a name="line995">995: </a>              }
<a name="line996">996: </a>            }
<a name="line997">997: </a>            mte_iter++;
<a name="line998">998: </a>          }
<a name="line999">999: </a>          <font color="#4169E1">while</font> (!support_list.empty()) {
<a name="line1000">1000: </a><strong><font color="#FF0000">            PETSC_MESH_TYPE:</font></strong>:point_type delete_this_point = *support_list.begin();
<a name="line1001">1001: </a>            support_list.pop_front();
<a name="line1002">1002: </a>            coarsen_sieve-&gt;removeBasePoint(delete_this_point);
<a name="line1003">1003: </a>          }
<a name="line1004">1004: </a>          coarsen_sieve-&gt;removeBasePoint(c_edge);
<a name="line1005">1005: </a>          coarsen_sieve-&gt;removeCapPoint(c_point);

<a name="line1007">1007: </a>        }
<a name="line1008">1008: </a>      } <font color="#4169E1">else</font> {
<a name="line1009">1009: </a>        //<font color="#4169E1">do</font> nothing .. this edge will never be bothered again save <font color="#4169E1">for</font> the difference between the boundary and non-boundary passes.
<a name="line1010">1010: </a>      }
<a name="line1011">1011: </a>    }


<a name="line1014">1014: </a>    //KILL THIS IT'S INEFFICENT
<a name="line1015">1015: </a>    //ALE::Obj&lt;PETSC_MESH_TYPE::label_sequence&gt; new_candidate_options = m-&gt;getLabelStratum(<font color="#666666">"candidates"</font>, 1);
<a name="line1016">1016: </a><strong><font color="#FF0000">    PETSC_MESH_TYPE:</font></strong>:point_type new_candidate_point = *coarsen_candidates.begin();
<a name="line1017">1017: </a>    coarsen_candidates.pop_front();
<a name="line1018">1018: </a>    <font color="#4169E1">while</font> (!coarsen_sieve-&gt;hasPoint(new_candidate_point) &amp;&amp; coarsen_candidates.size() &gt; 0) {
<a name="line1019">1019: </a>      new_candidate_point = *coarsen_candidates.begin();
<a name="line1020">1020: </a>      coarsen_candidates.pop_front();
<a name="line1021">1021: </a>    }
<a name="line1022">1022: </a>    <font color="#4169E1">if</font> (coarsen_candidates.size() == 0) {
<a name="line1023">1023: </a>      notDone = false;
<a name="line1024">1024: </a>    } <font color="#4169E1">else</font> { //add this point to the mesh, adding its neighbors to the comparison queue.
<a name="line1025">1025: </a>      //m-&gt;setValue(coarsen_candidates, new_candidate_point, 0);
<a name="line1026">1026: </a>      //      m-&gt;setValue(hdepth, new_candidate_point, curLevel);
<a name="line1027">1027: </a>      includedVertices-&gt;insert(new_candidate_point);
<a name="line1028">1028: </a><strong><font color="#FF0000">      ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::supportSequence&gt; neighbor_edges = coarsen_sieve-&gt;support(new_candidate_point);
<a name="line1029">1029: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSequence::iterator ne_iter = neighbor_edges-&gt;begin();
<a name="line1030">1030: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSequence::iterator ne_iter_end = neighbor_edges-&gt;end();
<a name="line1031">1031: </a>      //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(coarsen_mesh-&gt;comm(), <font color="#666666">"%d edges added to the comparison queue for vertex %d.\n"</font>, neighbor_edges-&gt;size(), new_candidate_point);
<a name="line1032">1032: </a>      <font color="#4169E1">while</font> (ne_iter != ne_iter_end) {
<a name="line1033">1033: </a>        <font color="#4169E1">if</font> ((m-&gt;getValue(boundary, *ne_iter) == 0)) {
<a name="line1034">1034: </a>          comparison_list.push_back(*ne_iter);
<a name="line1035">1035: </a>        }
<a name="line1036">1036: </a>        ne_iter++;
<a name="line1037">1037: </a>      }
<a name="line1038">1038: </a>    }
<a name="line1039">1039: </a>    }
<a name="line1040">1040: </a>    //Boundary Run: ONLY treat the boundary.
<a name="line1041">1041: </a><strong><font color="#FF0000">    ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::label_sequence&gt; bound_points = m-&gt;getLabelStratum(<font color="#666666">"marker"</font>, 1);
<a name="line1042">1042: </a>    v_iter = bound_points-&gt;begin();
<a name="line1043">1043: </a>    v_iter_end = bound_points-&gt;end();
<a name="line1044">1044: </a>    <font color="#4169E1">while</font> (v_iter != v_iter_end) {
<a name="line1045">1045: </a>      <font color="#4169E1">if</font> ((m-&gt;depth(*v_iter) == 0)&amp;&amp;(includedVertices-&gt;find(*v_iter) != includedVertices-&gt;end())) {
<a name="line1046">1046: </a><strong><font color="#FF0000">        ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::supportSequence&gt; tangent_edges = coarsen_sieve-&gt;support(*v_iter);
<a name="line1047">1047: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSequence::iterator te_iter = tangent_edges-&gt;begin();
<a name="line1048">1048: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSequence::iterator te_iter_end = tangent_edges-&gt;end();
<a name="line1049">1049: </a>        <font color="#4169E1">while</font> (te_iter != te_iter_end) {
<a name="line1050">1050: </a>          <font color="#4169E1">if</font> ((m-&gt;getValue(boundary, *te_iter) == 1)) {
<a name="line1051">1051: </a>            comparison_list.push_back(*te_iter);
<a name="line1052">1052: </a>          }
<a name="line1053">1053: </a>          te_iter++;
<a name="line1054">1054: </a>        }
<a name="line1055">1055: </a>      }
<a name="line1056">1056: </a>      <font color="#4169E1">if</font> ((includedVertices-&gt;find(*v_iter) == includedVertices-&gt;end()) &amp;&amp; (m-&gt;getValue(boundary, *v_iter) == 1) &amp;&amp; (m-&gt;depth(*v_iter) == 0)) {
<a name="line1057">1057: </a>        //m-&gt;setValue(coarsen_candidates, *v_iter, 1);
<a name="line1058">1058: </a>        coarsen_candidates.push_front(*v_iter);
<a name="line1059">1059: </a>        //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(coarsen_mesh-&gt;comm(), <font color="#666666">"Size of the support of %d is %d\n"</font>, *v_iter, coarsen_sieve-&gt;support(*v_iter)-&gt;size());
<a name="line1060">1060: </a>      }
<a name="line1061">1061: </a>      v_iter++;
<a name="line1062">1062: </a>    }
<a name="line1063">1063: </a>    //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"Comparison_queue size: %d, Candidate_list size %d\n"</font>, comparison_list.size(), coarsen_candidates.size());
<a name="line1064">1064: </a>    notDone = true;
<a name="line1065">1065: </a>    <font color="#4169E1">while</font> (notDone) {
<a name="line1066">1066: </a>    <font color="#4169E1">while</font> (!comparison_list.empty()){
<a name="line1067">1067: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:point_type c_edge = *comparison_list.begin();
<a name="line1068">1068: </a>      comparison_list.pop_front();
<a name="line1069">1069: </a>      //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"comparing across edge %d\n"</font>, c_edge);
<a name="line1070">1070: </a><strong><font color="#FF0000">      ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::coneSequence&gt; end_points = coarsen_sieve-&gt;cone(c_edge);
<a name="line1071">1071: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:sieve_type::coneSequence::iterator ep_iter = end_points-&gt;begin();
<a name="line1072">1072: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:point_type ep_1 = *ep_iter;
<a name="line1073">1073: </a>      ep_iter++;
<a name="line1074">1074: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:point_type  ep_2 = *ep_iter;
<a name="line1075">1075: </a>      //int ep_1_hdepth = m-&gt;getValue(hdepth, ep_1);
<a name="line1076">1076: </a>      //int ep_2_hdepth = m-&gt;getValue(hdepth, ep_2);
<a name="line1077">1077: </a>      bool ep_1_dominates = (includedVertices-&gt;find(ep_1) != includedVertices-&gt;end()); //((ep_1_hdepth != 0));
<a name="line1078">1078: </a>      bool ep_2_dominates = (includedVertices-&gt;find(ep_2) != includedVertices-&gt;end()); //((ep_2_hdepth != 0));
<a name="line1079">1079: </a>      //<font color="#4169E1">if</font> ((!ep_1_dominates) &amp;&amp; (!ep_2_dominates)) {
<a name="line1080">1080: </a>      //  <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(),<font color="#666666">"%d, %d\n"</font>, ep_1_bound, ep_2_bound);
<a name="line1081">1081: </a>      //  throw ALE::Exception(<font color="#666666">"Coarse To Coarse Comparison: This Should Not Have Happened"</font>);
<a name="line1082">1082: </a>      //}
<a name="line1083">1083: </a>      <font color="#4169E1">if</font> ((!ep_1_dominates &amp;&amp; ep_2_dominates) || (ep_1_dominates &amp;&amp; !ep_2_dominates)) {
<a name="line1084">1084: </a>        <font color="#4169E1">if</font> (ep_1_dominates) {
<a name="line1085">1085: </a>        c_point = ep_2;
<a name="line1086">1086: </a>        n_point = ep_1;
<a name="line1087">1087: </a>        } <font color="#4169E1">else</font> {
<a name="line1088">1088: </a>         c_point = ep_1;
<a name="line1089">1089: </a>         n_point = ep_2;
<a name="line1090">1090: </a>        }
<a name="line1091">1091: </a>        nComparisons++;
<a name="line1092">1092: </a>        <A href="../../../../docs/manualpages/Sys/PetscMemcpy.html#PetscMemcpy">PetscMemcpy</A>(c_coords, coordinates-&gt;restrictPoint(c_point), dim*<font color="#4169E1">sizeof</font>(double));
<a name="line1093">1093: </a>        c_space = *spacing-&gt;restrictPoint(c_point);
<a name="line1094">1094: </a>        <A href="../../../../docs/manualpages/Sys/PetscMemcpy.html#PetscMemcpy">PetscMemcpy</A>(n_coords, coordinates-&gt;restrictPoint(n_point), dim*<font color="#4169E1">sizeof</font>(double));
<a name="line1095">1095: </a>        n_space = *spacing-&gt;restrictPoint(n_point);
<a name="line1096">1096: </a>        dist = 0.;
<a name="line1097">1097: </a>        <font color="#4169E1">for</font> (int i = 0; i &lt; dim; i++) {
<a name="line1098">1098: </a>            dist += (n_coords[i] - c_coords[i])*(n_coords[i] - c_coords[i]);
<a name="line1099">1099: </a>        }
<a name="line1100">1100: </a>        dist = sqrt(dist);
<a name="line1101">1101: </a>        <font color="#4169E1">if</font> (dist &lt; current_beta*(n_space + c_space)) {
<a name="line1102">1102: </a>          //remove the point and this edge from existence and link its neighbors up with the eliminating point, adding the neighboring edges to THE LIST.
<a name="line1103">1103: </a>          //m-&gt;setValue(coarsen_candidates, c_point, 0);
<a name="line1104">1104: </a><strong><font color="#FF0000">          ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::supportSequence&gt; move_these_edges = coarsen_sieve-&gt;support(c_point);
<a name="line1105">1105: </a><strong><font color="#FF0000">          PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSequence::iterator mte_iter = move_these_edges-&gt;begin();
<a name="line1106">1106: </a><strong><font color="#FF0000">          PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSequence::iterator mte_iter_end = move_these_edges-&gt;end();
<a name="line1107">1107: </a>          <font color="#4169E1">while</font> (mte_iter != mte_iter_end) {
<a name="line1108">1108: </a>            <font color="#4169E1">if</font> (*mte_iter != c_edge) {
<a name="line1109">1109: </a>              coarsen_sieve-&gt;addArrow(n_point, *mte_iter);
<a name="line1110">1110: </a>              <font color="#4169E1">if</font> (coarsen_sieve-&gt;cone(*mte_iter)-&gt;size() == 2) {  //it's one of the edges that should be eliminated here, don't compare across it.
<a name="line1111">1111: </a>                support_list.push_front(*mte_iter); //save <font color="#4169E1">for</font> elimination because we don't want to screw up the iterator
<a name="line1112">1112: </a>              } <font color="#4169E1">else</font> { //compare across the just-changed edge
<a name="line1113">1113: </a>                <font color="#4169E1">if</font> (m-&gt;getValue(boundary, *mte_iter) == 1)
<a name="line1114">1114: </a>                comparison_list.push_back(*mte_iter);
<a name="line1115">1115: </a>              }
<a name="line1116">1116: </a>            }
<a name="line1117">1117: </a>            mte_iter++;
<a name="line1118">1118: </a>          }
<a name="line1119">1119: </a>          <font color="#4169E1">while</font> (!support_list.empty()) {
<a name="line1120">1120: </a><strong><font color="#FF0000">            PETSC_MESH_TYPE:</font></strong>:point_type delete_this_point = *support_list.begin();
<a name="line1121">1121: </a>            support_list.pop_front();
<a name="line1122">1122: </a>            coarsen_sieve-&gt;removeBasePoint(delete_this_point);
<a name="line1123">1123: </a>          }
<a name="line1124">1124: </a>          coarsen_sieve-&gt;removeBasePoint(c_edge);
<a name="line1125">1125: </a>          coarsen_sieve-&gt;removeCapPoint(c_point);
<a name="line1126">1126: </a>          //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"Removed %d\n"</font>, c_point);
<a name="line1127">1127: </a>        }
<a name="line1128">1128: </a>      } <font color="#4169E1">else</font> {
<a name="line1129">1129: </a>        //<font color="#4169E1">do</font> nothing .. this edge will never be bothered again save <font color="#4169E1">for</font> the difference between the boundary and non-boundary passes.
<a name="line1130">1130: </a>      }
<a name="line1131">1131: </a>    }

<a name="line1133">1133: </a>    //ALE::Obj&lt;PETSC_MESH_TYPE::label_sequence&gt; new_candidate_options = m-&gt;getLabelStratum(<font color="#666666">"candidates"</font>, 1);

<a name="line1135">1135: </a><strong><font color="#FF0000">    PETSC_MESH_TYPE:</font></strong>:point_type new_candidate_point = *coarsen_candidates.begin();
<a name="line1136">1136: </a>    coarsen_candidates.pop_front();
<a name="line1137">1137: </a>    <font color="#4169E1">while</font> (!coarsen_sieve-&gt;hasPoint(new_candidate_point) &amp;&amp; coarsen_candidates.size() &gt; 0) {
<a name="line1138">1138: </a>      new_candidate_point = *coarsen_candidates.begin();
<a name="line1139">1139: </a>      coarsen_candidates.pop_front();
<a name="line1140">1140: </a>      //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(coarsen_mesh-&gt;comm(), <font color="#666666">"%d edges in the support of the current coarsen candidate; %d somethings in the cone\n"</font>, coarsen_sieve-&gt;support(new_candidate_point)-&gt;size(), coarsen_sieve-&gt;cone(new_candidate_point)-&gt;size());
<a name="line1141">1141: </a>    }
<a name="line1142">1142: </a>    <font color="#4169E1">if</font> (coarsen_candidates.size() == 0) {
<a name="line1143">1143: </a>      notDone = false;
<a name="line1144">1144: </a>    } <font color="#4169E1">else</font> { //add this point to the mesh, adding its neighbors to the comparison queue.
<a name="line1145">1145: </a>      //m-&gt;setValue(coarsen_candidates, *new_candidate, 0);
<a name="line1146">1146: </a>      //m-&gt;setValue(hdepth, new_candidate_point, curLevel);
<a name="line1147">1147: </a>      includedVertices-&gt;insert(new_candidate_point);
<a name="line1148">1148: </a><strong><font color="#FF0000">      ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::supportSequence&gt; neighbor_edges = coarsen_sieve-&gt;support(new_candidate_point);
<a name="line1149">1149: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSequence::iterator ne_iter = neighbor_edges-&gt;begin();
<a name="line1150">1150: </a><strong><font color="#FF0000">      PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSequence::iterator ne_iter_end = neighbor_edges-&gt;end();
<a name="line1151">1151: </a>      //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(coarsen_mesh-&gt;comm(), <font color="#666666">"%d edges added to the comparison queue for vertex %d.\n"</font>, neighbor_edges-&gt;size(), new_candidate_point);
<a name="line1152">1152: </a>      <font color="#4169E1">if</font> (neighbor_edges-&gt;size() == 0) throw ALE::Exception(<font color="#666666">"bad vertex."</font>);
<a name="line1153">1153: </a>      <font color="#4169E1">while</font> (ne_iter != ne_iter_end) {
<a name="line1154">1154: </a>        <font color="#4169E1">if</font> (m-&gt;getValue(boundary, *ne_iter) == 1) {
<a name="line1155">1155: </a>          comparison_list.push_back(*ne_iter);
<a name="line1156">1156: </a>        }
<a name="line1157">1157: </a>        ne_iter++;
<a name="line1158">1158: </a>      }
<a name="line1159">1159: </a>    }
<a name="line1160">1160: </a>    }


<a name="line1163">1163: </a>    //}
<a name="line1164">1164: </a>    coarsen_mesh-&gt;stratify();
<a name="line1165">1165: </a><strong><font color="#FF0000">    ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::label_sequence&gt; coarsen_vertices = coarsen_mesh-&gt;depthStratum(0);
<a name="line1166">1166: </a><strong><font color="#FF0000">    PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator cv_iter = coarsen_vertices-&gt;begin();
<a name="line1167">1167: </a><strong><font color="#FF0000">    PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator cv_iter_end = coarsen_vertices-&gt;end();
<a name="line1168">1168: </a>    //what does this part <font color="#4169E1">do</font> again?
<a name="line1169">1169: </a>    includedVertices-&gt;clear();
<a name="line1170">1170: </a>    <font color="#4169E1">while</font> (cv_iter != cv_iter_end) {
<a name="line1171">1171: </a>      // m-&gt;setValue(hdepth, *cv_iter, curLevel);
<a name="line1172">1172: </a>      includedVertices-&gt;insert(*cv_iter);
<a name="line1173">1173: </a>      cv_iter++;
<a name="line1174">1174: </a>    }
<a name="line1175">1175: </a>  <font color="#4169E1">if</font>(info) <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"%d points in %d comparisons\n"</font>, coarsen_mesh-&gt;depthStratum(0)-&gt;size(), nComparisons);
<a name="line1176">1176: </a>  nComparisons_perPoint_Total += nComparisons;
<a name="line1177">1177: </a><strong><font color="#FF0000">  ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE&gt; newmesh = MeshCreateHierarchyMesh(m, includedVertices);
<a name="line1178">1178: </a>  <font color="#4169E1">if</font>(info) <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"%d: %d vertices, %d elements\n"</font>, curLevel, newmesh-&gt;depthStratum(0)-&gt;size(), newmesh-&gt;heightStratum(0)-&gt;size());
<a name="line1179">1179: </a>  <A href="../../../../docs/manualpages/Mesh/MeshSetMesh.html#MeshSetMesh">MeshSetMesh</A>(outmeshes[curLevel-1], newmesh);
<a name="line1180">1180: </a>  }
<a name="line1181">1181: </a>  nComparisons_perPoint_Total = nComparisons_perPoint_Total/((double)m-&gt;depthStratum(0)-&gt;size());
<a name="line1182">1182: </a>  <font color="#4169E1">if</font>(info) <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"Comparisons Per Point: %f\n"</font>, nComparisons_perPoint_Total);
<a name="line1183">1183: </a>  <font color="#4169E1">return</font>(0);
<a name="line1184">1184: </a>}


<a name="line1189">1189: </a>//MeshCreateHierarchyLabel: Create a label that tells what the highest level a given vertex appears in where 0 is fine and n is coarsest.
<a name="line1190">1190: </a><A href="../../../../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode">PetscErrorCode</A> MeshCreateHierarchyLabel(Mesh finemesh, double beta, int nLevels, Mesh * outmeshes, <A href="../../../../docs/manualpages/Mat/Mat.html#Mat">Mat</A> * outmats = <A href="../../../../docs/manualpages/Sys/PETSC_NULL.html#PETSC_NULL">PETSC_NULL</A>) {
<a name="line1192">1192: </a><strong><font color="#FF0000">  ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE&gt; m;
<a name="line1194">1194: </a>  <A href="../../../../docs/manualpages/Sys/PetscTruth.html#PetscTruth">PetscTruth</A> info;
<a name="line1195">1195: </a>  int overallComparisons = 0;
<a name="line1196">1196: </a>  <A href="../../../../docs/manualpages/Sys/PetscOptionsHasName.html#PetscOptionsHasName">PetscOptionsHasName</A>(<A href="../../../../docs/manualpages/Sys/PETSC_NULL.html#PETSC_NULL">PETSC_NULL</A>, <font color="#666666">"-dmmg_coarsen_info"</font>, &amp;info);
<a name="line1197">1197: </a>  <A href="../../../../docs/manualpages/Mesh/MeshGetMesh.html#MeshGetMesh">MeshGetMesh</A>(finemesh, m);
<a name="line1198">1198: </a>  int dim = m-&gt;getDimension();
<a name="line1199">1199: </a>  <font color="#4169E1">if</font> (info)<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"Original Mesh: %d vertices, %d elements\n"</font>, m-&gt;depthStratum(0)-&gt;size(), m-&gt;heightStratum(0)-&gt;size());
<a name="line1200">1200: </a>  <font color="#4169E1">if</font> (!m-&gt;hasLabel(<font color="#666666">"marker"</font>))MeshIDBoundary(finemesh);
<a name="line1201">1201: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::real_section_type&gt;&amp; coordinates = m-&gt;getRealSection(<font color="#666666">"coordinates"</font>);
<a name="line1202">1202: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::real_section_type&gt;&amp; spacing = m-&gt;getRealSection(<font color="#666666">"spacing"</font>);
<a name="line1203">1203: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::label_type&gt; hdepth = m-&gt;createLabel(<font color="#666666">"hdepth"</font>);
<a name="line1204">1204: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::label_type&gt; dompoint = m-&gt;createLabel(<font color="#666666">"dompoint"</font>);
<a name="line1205">1205: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::label_type&gt; traversal = m-&gt;createLabel(<font color="#666666">"traversal"</font>);
<a name="line1206">1206: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::label_type&gt;&amp; boundary = m-&gt;getLabel(<font color="#666666">"marker"</font>);
<a name="line1207">1207: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::label_sequence&gt;&amp; vertices = m-&gt;depthStratum(0);
<a name="line1208">1208: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator v_iter = vertices-&gt;begin();
<a name="line1209">1209: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator v_iter_end = vertices-&gt;end();
<a name="line1210">1210: </a>  double maxspace = -1., minspace = -1., dist;
<a name="line1211">1211: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:point_type max_vertex_index = -1;
<a name="line1212">1212: </a>  <font color="#4169E1">while</font>(v_iter != v_iter_end) {
<a name="line1213">1213: </a>    //initialize the label to 0.
<a name="line1214">1214: </a>    m-&gt;setValue(hdepth, *v_iter, 0);
<a name="line1215">1215: </a>    //discover the maximum and minimum spacing functions in the mesh.
<a name="line1216">1216: </a>    double vspace = *spacing-&gt;restrictPoint(*v_iter);
<a name="line1217">1217: </a>    <font color="#4169E1">if</font> ((vspace &gt; maxspace) || (maxspace == -1.)) maxspace = vspace;
<a name="line1218">1218: </a>    <font color="#4169E1">if</font> ((vspace &lt; minspace) || (minspace == -1.)) minspace = vspace;
<a name="line1219">1219: </a>    <font color="#4169E1">if</font> (*v_iter &gt; max_vertex_index) max_vertex_index = *v_iter;
<a name="line1220">1220: </a>    v_iter++;
<a name="line1221">1221: </a>  }
<a name="line1222">1222: </a>  //PUT IN PART FOR AUTOMATICALLY ADDING HIGH-CURVATURE BOUNDARY NODES
<a name="line1223">1223: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::label_sequence&gt;&amp; boundaryvertices = m-&gt;getLabelStratum(<font color="#666666">"marker"</font>, 1); //boundary
<a name="line1224">1224: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator bv_iter = boundaryvertices-&gt;begin();
<a name="line1225">1225: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator bv_iter_end = boundaryvertices-&gt;end();
<a name="line1226">1226: </a> // <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"NUMBER OF BOUNDARY POINTS: %d\n"</font>, boundaryvertices-&gt;size());
<a name="line1227">1227: </a>  <font color="#4169E1">while</font> (bv_iter != bv_iter_end) {
<a name="line1228">1228: </a>    <font color="#4169E1">if</font> (m-&gt;depth(*bv_iter) == 0) <font color="#4169E1">if</font> (Curvature(m, *bv_iter) &gt; 0.1) {
<a name="line1229">1229: </a>      m-&gt;setValue(hdepth, *bv_iter, nLevels-1);
<a name="line1230">1230: </a>    }
<a name="line1231">1231: </a>    bv_iter++;
<a name="line1232">1232: </a>  }
<a name="line1233">1233: </a> // <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"Forced in %d especially curved boundary nodes.\n"</font>, m-&gt;getLabelStratum(<font color="#666666">"hdepth"</font>, nLevels-1)-&gt;size());
<a name="line1234">1234: </a>  double *bvCoords = new double[dim];
<a name="line1235">1235: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:point_type bvdom;
<a name="line1236">1236: </a><strong><font color="#FF0000">  std:</font></strong>:list&lt;PETSC_MESH_TYPE::point_type&gt; complist;
<a name="line1237">1237: </a><strong><font color="#FF0000">  std:</font></strong>:list&lt;PETSC_MESH_TYPE::point_type&gt; domlist; //stores the points dominated by the current point.
<a name="line1238">1238: </a>  <font color="#4169E1">for</font> (int curLevel = nLevels-1; curLevel &gt; 0; curLevel--) {
<a name="line1239">1239: </a>    double curBeta = pow(beta, curLevel);
<a name="line1240">1240: </a>   //OUR MODUS OPERANDI:
<a name="line1241">1241: </a>    //1. <font color="#4169E1">do</font> the boundary and the interior identically but separately
<a name="line1242">1242: </a>    //2. keep track of the point that eliminates each point on each level.  This should work sort of like an approximation to the voronoi partitions.  Compare against these first as they're more likely to collide than neighbors.  Also compare to the points that eliminate the neighbors in the same fashion.
<a name="line1243">1243: </a>    //3. If the point is not eliminated by its old eliminator we must traverse out to max(space(v)) + space(i).
<a name="line1244">1244: </a>    //GOAL: only eliminate each point once! <font color="#4169E1">if</font> we add a point that eliminates other points get rid of them in the traversal! (and set their elimination marker appropriately.)
<a name="line1245">1245: </a>    double comparison_const;
<a name="line1246">1246: </a><strong><font color="#FF0000">    PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator bv_iter = boundaryvertices-&gt;begin();
<a name="line1247">1247: </a><strong><font color="#FF0000">    PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator bv_iter_end = boundaryvertices-&gt;end();
<a name="line1248">1248: </a><strong><font color="#FF0000">    ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::coneSet&gt; neighbors = m-&gt;getSieve()-&gt;cone(m-&gt;getSieve()-&gt;support(*bv_iter));
<a name="line1249">1249: </a><strong><font color="#FF0000">    PETSC_MESH_TYPE:</font></strong>:sieve_type::coneSet::iterator n_iter = neighbors-&gt;begin();
<a name="line1250">1250: </a><strong><font color="#FF0000">    PETSC_MESH_TYPE:</font></strong>:sieve_type::coneSet::iterator n_iter_end = neighbors-&gt;end();
<a name="line1251">1251: </a>    int nComparisonsTotal = 0;
<a name="line1252">1252: </a>    <font color="#4169E1">while</font> (bv_iter != bv_iter_end) {
<a name="line1253">1253: </a>      bvdom = m-&gt;getValue(dompoint, *bv_iter);
<a name="line1254">1254: </a>      bool skip = false;
<a name="line1255">1255: </a>      <font color="#4169E1">if</font> (bvdom != -1) {
<a name="line1256">1256: </a>        <font color="#4169E1">if</font> (m-&gt;getValue(hdepth, bvdom) == curLevel) skip = true;
<a name="line1257">1257: </a>      }
<a name="line1258">1258: </a>      bool canAdd = true;
<a name="line1259">1259: </a>      <font color="#4169E1">if</font> (m-&gt;getValue(hdepth, *bv_iter) == 0 &amp;&amp; !skip &amp;&amp; m-&gt;depth(*bv_iter) == 0) { //<font color="#4169E1">if</font> not yet included or invalidated
<a name="line1260">1260: </a>        m-&gt;setValue(traversal, *bv_iter, 1);
<a name="line1261">1261: </a>        double bvSpace = *spacing-&gt;restrictPoint(*bv_iter);
<a name="line1262">1262: </a>        <A href="../../../../docs/manualpages/Sys/PetscMemcpy.html#PetscMemcpy">PetscMemcpy</A>(bvCoords, coordinates-&gt;restrictPoint(*bv_iter), dim*<font color="#4169E1">sizeof</font>(double));
<a name="line1263">1263: </a>        //get its neighbors and add them to the comparison queue.
<a name="line1264">1264: </a>        neighbors = m-&gt;getSieve()-&gt;cone(m-&gt;getSieve()-&gt;support(*bv_iter));
<a name="line1265">1265: </a>        n_iter = neighbors-&gt;begin();
<a name="line1266">1266: </a>        n_iter_end = neighbors-&gt;end();
<a name="line1267">1267: </a>        <font color="#4169E1">while</font> (n_iter != n_iter_end) {
<a name="line1268">1268: </a>          <font color="#4169E1">if</font> (m-&gt;getValue(boundary, *n_iter) == 1) {
<a name="line1269">1269: </a>            m-&gt;setValue(traversal, *n_iter, 1);
<a name="line1270">1270: </a>            complist.push_front(*n_iter);
<a name="line1271">1271: </a>          }
<a name="line1272">1272: </a>          n_iter++;
<a name="line1273">1273: </a>        }
<a name="line1274">1274: </a>        //push the last point to invalidate the current point to the front of the list of comparisons.
<a name="line1275">1275: </a>        bool setDist = false;
<a name="line1276">1276: </a>        <font color="#4169E1">if</font> (bvdom != -1) {
<a name="line1277">1277: </a>           setDist = true;
<a name="line1278">1278: </a>           complist.push_front(bvdom);
<a name="line1279">1279: </a>        }

<a name="line1281">1281: </a>        <font color="#4169E1">while</font> ((!complist.empty()) &amp;&amp; canAdd) {
<a name="line1282">1282: </a>          nComparisonsTotal++;
<a name="line1283">1283: </a><strong><font color="#FF0000">          PETSC_MESH_TYPE:</font></strong>:point_type curpt = *complist.begin();
<a name="line1284">1284: </a>          complist.pop_front();
<a name="line1285">1285: </a>          dist = 0.;
<a name="line1286">1286: </a>          double curSpace = *spacing-&gt;restrictPoint(curpt);
<a name="line1287">1287: </a>          const double * curCoords = coordinates-&gt;restrictPoint(curpt);
<a name="line1288">1288: </a>          <font color="#4169E1">for</font> (int i = 0; i &lt; dim; i++) {
<a name="line1289">1289: </a>            dist += (curCoords[i] - bvCoords[i])*(curCoords[i] - bvCoords[i]);
<a name="line1290">1290: </a>          }
<a name="line1291">1291: </a>          //gets the distance to bvdom as the maximum radius to compare out
<a name="line1292">1292: </a>          dist = sqrt(dist);
<a name="line1293">1293: </a>          comparison_const = 0.5*curBeta;
<a name="line1294">1294: </a>          <font color="#4169E1">if</font> (setDist == true) {
<a name="line1295">1295: </a>            maxspace = dist;
<a name="line1296">1296: </a>            setDist = false;
<a name="line1297">1297: </a>          } <font color="#4169E1">else</font> {
<a name="line1298">1298: </a>            maxspace = 3.*curSpace*comparison_const;
<a name="line1299">1299: </a>          }
<a name="line1300">1300: </a><strong><font color="#FF0000">          PETSC_MESH_TYPE:</font></strong>:point_type curpt_dom = m-&gt;getValue(dompoint, curpt);
<a name="line1301">1301: </a>          int curpt_depth = m-&gt;getValue(hdepth, curpt);
<a name="line1302">1302: </a>          int curpt_bound = m-&gt;getValue(boundary, curpt);
<a name="line1303">1303: </a>          <font color="#4169E1">if</font> ((dist &lt; comparison_const*(bvSpace + curSpace))&amp;&amp;(curpt_depth &gt; 0)) { //collision with an already added node
<a name="line1304">1304: </a>            canAdd = false;
<a name="line1305">1305: </a>            m-&gt;setValue(dompoint, *bv_iter, curpt);
<a name="line1306">1306: </a>          } <font color="#4169E1">else</font> <font color="#4169E1">if</font> (dist &lt; maxspace) { //go out to the dompoint
<a name="line1307">1307: </a>            neighbors = m-&gt;getSieve()-&gt;cone(m-&gt;getSieve()-&gt;support(curpt));
<a name="line1308">1308: </a>            n_iter = neighbors-&gt;begin();
<a name="line1309">1309: </a>            n_iter_end = neighbors-&gt;end();
<a name="line1310">1310: </a>            <font color="#4169E1">while</font> (n_iter != n_iter_end) {
<a name="line1311">1311: </a>              <font color="#4169E1">if</font> ((m-&gt;getValue(traversal, *n_iter) == 0)) {
<a name="line1312">1312: </a>                m-&gt;setValue(traversal, *n_iter, 1);
<a name="line1313">1313: </a>                complist.push_back(*n_iter);
<a name="line1314">1314: </a>              }
<a name="line1315">1315: </a>              n_iter++;
<a name="line1316">1316: </a>            }
<a name="line1317">1317: </a>          }
<a name="line1318">1318: </a>          <font color="#4169E1">if</font> ((dist &lt; comparison_const*(bvSpace + curSpace)) &amp;&amp; (curpt_depth == 0)) { //add the point to the list of points dominated by this node; points eliminated in one step later
<a name="line1319">1319: </a>            domlist.push_front(curpt);
<a name="line1320">1320: </a>            <font color="#4169E1">if</font> (curpt_bound == 0) {
<a name="line1321">1321: </a>              m-&gt;setValue(dompoint, curpt, *bv_iter);
<a name="line1322">1322: </a>            }
<a name="line1323">1323: </a>          }
<a name="line1324">1324: </a>          <font color="#4169E1">if</font> ((dist &lt; maxspace) &amp;&amp; (curpt_depth == 0)) {
<a name="line1325">1325: </a>            <font color="#4169E1">if</font> (curpt_dom != -1) {
<a name="line1326">1326: </a>              <font color="#4169E1">if</font> (m-&gt;getValue(traversal, curpt_dom) == 0) {
<a name="line1327">1327: </a>                complist.push_front(curpt_dom);
<a name="line1328">1328: </a>                m-&gt;setValue(traversal, curpt_dom, 1);
<a name="line1329">1329: </a>              }
<a name="line1330">1330: </a>            }
<a name="line1331">1331: </a>          }
<a name="line1332">1332: </a>        }  //end of complist deal
<a name="line1333">1333: </a>        complist.clear();
<a name="line1334">1334: </a>        <font color="#4169E1">if</font> (canAdd == true) {
<a name="line1335">1335: </a>          m-&gt;setValue(hdepth, *bv_iter, curLevel);
<a name="line1336">1336: </a><strong><font color="#FF0000">          std:</font></strong>:list&lt;PETSC_MESH_TYPE::point_type&gt;::iterator dom_iter = domlist.begin();
<a name="line1337">1337: </a><strong><font color="#FF0000">          std:</font></strong>:list&lt;PETSC_MESH_TYPE::point_type&gt;::iterator dom_iter_end = domlist.end();
<a name="line1338">1338: </a>          <font color="#4169E1">while</font> (dom_iter != dom_iter_end) {
<a name="line1339">1339: </a>            m-&gt;setValue(dompoint, *dom_iter, *bv_iter);
<a name="line1340">1340: </a>            dom_iter++;
<a name="line1341">1341: </a>          }
<a name="line1342">1342: </a>        }
<a name="line1343">1343: </a>        domlist.clear();
<a name="line1344">1344: </a>        //unset the traversal listing
<a name="line1345">1345: </a><strong><font color="#FF0000">        ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::label_sequence&gt; travnodes = m-&gt;getLabelStratum(<font color="#666666">"traversal"</font>, 1);
<a name="line1346">1346: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator tn_iter = travnodes-&gt;begin();
<a name="line1347">1347: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator tn_iter_end = travnodes-&gt;end();
<a name="line1348">1348: </a>        <font color="#4169E1">while</font> (tn_iter != tn_iter_end) {
<a name="line1349">1349: </a>          complist.push_front(*tn_iter);
<a name="line1350">1350: </a>          tn_iter++;
<a name="line1351">1351: </a>        }
<a name="line1352">1352: </a>        <font color="#4169E1">while</font> (!complist.empty()) {
<a name="line1353">1353: </a><strong><font color="#FF0000">          PETSC_MESH_TYPE:</font></strong>:point_type emptpt = *complist.begin();
<a name="line1354">1354: </a>          complist.pop_front();
<a name="line1355">1355: </a>          m-&gt;setValue(traversal, emptpt, 0);
<a name="line1356">1356: </a>        }
<a name="line1357">1357: </a>      }
<a name="line1358">1358: </a>      bv_iter++;
<a name="line1359">1359: </a>    }
<a name="line1360">1360: </a> //   <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"Added %d new boundary vertices\n"</font>, m-&gt;getLabelStratum(<font color="#666666">"hdepth"</font>, curLevel)-&gt;size());
<a name="line1361">1361: </a>    //INTERIOR NODES:
<a name="line1362">1362: </a>    complist.clear();
<a name="line1363">1363: </a><strong><font color="#FF0000">    ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::label_sequence&gt; intverts = m-&gt;depthStratum(0);
<a name="line1364">1364: </a>    bv_iter = intverts-&gt;begin();
<a name="line1365">1365: </a>    bv_iter_end = intverts-&gt;end();
<a name="line1366">1366: </a>    <font color="#4169E1">while</font> (bv_iter != bv_iter_end) {
<a name="line1367">1367: </a>      bvdom = m-&gt;getValue(dompoint, *bv_iter);
<a name="line1368">1368: </a>      bool skip = false;
<a name="line1369">1369: </a>      <font color="#4169E1">if</font> (bvdom != -1) {
<a name="line1370">1370: </a>        <font color="#4169E1">if</font> (m-&gt;getValue(hdepth, bvdom) == curLevel) skip = true;
<a name="line1371">1371: </a>      }
<a name="line1372">1372: </a>      bool canAdd = true;
<a name="line1373">1373: </a>      <font color="#4169E1">if</font> ((m-&gt;getValue(boundary, *bv_iter) != 1) &amp;&amp; (m-&gt;getValue(hdepth, *bv_iter) == 0) &amp;&amp; !skip) { //<font color="#4169E1">if</font> not in the boundary and not included (or excluded)
<a name="line1374">1374: </a>        double bvSpace = *spacing-&gt;restrictPoint(*bv_iter);
<a name="line1375">1375: </a>        <A href="../../../../docs/manualpages/Sys/PetscMemcpy.html#PetscMemcpy">PetscMemcpy</A>(bvCoords, coordinates-&gt;restrictPoint(*bv_iter), dim*<font color="#4169E1">sizeof</font>(double));
<a name="line1376">1376: </a>        //get its neighbors and add them to the comparison queue.
<a name="line1377">1377: </a>        neighbors = m-&gt;getSieve()-&gt;cone(m-&gt;getSieve()-&gt;support(*bv_iter));
<a name="line1378">1378: </a>        n_iter = neighbors-&gt;begin();
<a name="line1379">1379: </a>        n_iter_end = neighbors-&gt;end();
<a name="line1380">1380: </a>        m-&gt;setValue(traversal, *bv_iter, 1);
<a name="line1381">1381: </a>        <font color="#4169E1">while</font> (n_iter != n_iter_end) {
<a name="line1382">1382: </a>          <font color="#4169E1">if</font> (*n_iter != *bv_iter) {
<a name="line1383">1383: </a>            //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"Added %d to the list\n"</font>, *n_iter);
<a name="line1384">1384: </a>            m-&gt;setValue(traversal, *n_iter, 1);
<a name="line1385">1385: </a>            complist.push_front(*n_iter);
<a name="line1386">1386: </a>          }
<a name="line1387">1387: </a>          n_iter++;
<a name="line1388">1388: </a>        }
<a name="line1389">1389: </a>        maxspace = 0.5*bvSpace*curBeta;
<a name="line1390">1390: </a>        bool setDist = false;
<a name="line1391">1391: </a>        <font color="#4169E1">if</font> (bvdom != -1) {
<a name="line1392">1392: </a>           setDist = true;
<a name="line1393">1393: </a>           complist.push_front(bvdom);
<a name="line1394">1394: </a>        }
<a name="line1395">1395: </a>        <font color="#4169E1">while</font> ((!complist.empty()) &amp;&amp; canAdd) {
<a name="line1396">1396: </a>          nComparisonsTotal++;
<a name="line1397">1397: </a><strong><font color="#FF0000">          PETSC_MESH_TYPE:</font></strong>:point_type curpt = *complist.begin();
<a name="line1398">1398: </a>          complist.pop_front();
<a name="line1399">1399: </a>          //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"Comparing %d to %d\n"</font>, *bv_iter, curpt);
<a name="line1400">1400: </a>          dist = 0.;
<a name="line1401">1401: </a>          double curSpace = *spacing-&gt;restrictPoint(curpt);
<a name="line1402">1402: </a>          const double * curCoords = coordinates-&gt;restrictPoint(curpt);
<a name="line1403">1403: </a>          <font color="#4169E1">for</font> (int i = 0; i &lt; dim; i++) {
<a name="line1404">1404: </a>            dist += (curCoords[i] - bvCoords[i])*(curCoords[i] - bvCoords[i]);
<a name="line1405">1405: </a>          }
<a name="line1406">1406: </a>          comparison_const = 0.5*curBeta;
<a name="line1407">1407: </a>          dist = sqrt(dist);
<a name="line1408">1408: </a>          <font color="#4169E1">if</font> (setDist == true) {
<a name="line1409">1409: </a>            maxspace = dist;
<a name="line1410">1410: </a>            setDist = false;
<a name="line1411">1411: </a>          } <font color="#4169E1">else</font> {
<a name="line1412">1412: </a>            maxspace = 3.*curSpace*comparison_const;
<a name="line1413">1413: </a>          }
<a name="line1414">1414: </a>          int curpt_depth = m-&gt;getValue(hdepth, curpt);
<a name="line1415">1415: </a>          int curpt_bound = m-&gt;getValue(boundary, curpt);
<a name="line1416">1416: </a><strong><font color="#FF0000">          PETSC_MESH_TYPE:</font></strong>:point_type curpt_dom = m-&gt;getValue(dompoint, curpt);
<a name="line1417">1417: </a>          <font color="#4169E1">if</font> ((dist &lt; comparison_const*(bvSpace + curSpace))&amp;&amp;(curpt_depth &gt; 0)) {
<a name="line1418">1418: </a>            canAdd = false;
<a name="line1419">1419: </a>            m-&gt;setValue(dompoint, *bv_iter, curpt);
<a name="line1420">1420: </a>          } <font color="#4169E1">else</font> <font color="#4169E1">if</font> ((dist &lt; comparison_const*(bvSpace+curSpace)) &amp;&amp; (curpt_bound == 1)) {
<a name="line1421">1421: </a>            canAdd = false;
<a name="line1422">1422: </a>            m-&gt;setValue(dompoint, *bv_iter, curpt);
<a name="line1423">1423: </a>          } <font color="#4169E1">else</font> <font color="#4169E1">if</font> (dist &lt; maxspace) {
<a name="line1424">1424: </a>            neighbors = m-&gt;getSieve()-&gt;cone(m-&gt;getSieve()-&gt;support(curpt));
<a name="line1425">1425: </a>            n_iter = neighbors-&gt;begin();
<a name="line1426">1426: </a>            n_iter_end = neighbors-&gt;end();
<a name="line1427">1427: </a>            <font color="#4169E1">while</font> (n_iter != n_iter_end) {
<a name="line1428">1428: </a>              <font color="#4169E1">if</font> ((m-&gt;getValue(boundary, *n_iter) != 1) &amp;&amp; (m-&gt;getValue(traversal, *n_iter) != 1)) {
<a name="line1429">1429: </a>                m-&gt;setValue(traversal, *n_iter, 1);
<a name="line1430">1430: </a>                complist.push_back(*n_iter);
<a name="line1431">1431: </a>              }
<a name="line1432">1432: </a>              n_iter++;
<a name="line1433">1433: </a>            }
<a name="line1434">1434: </a>          }
<a name="line1435">1435: </a>          <font color="#4169E1">if</font> ((dist &lt; comparison_const*(bvSpace + curSpace)) &amp;&amp; (curpt_depth == 0)) {
<a name="line1436">1436: </a>            domlist.push_front(curpt);
<a name="line1437">1437: </a>          }
<a name="line1438">1438: </a>          <font color="#4169E1">if</font> ((dist &lt; maxspace) &amp;&amp; (curpt_depth == 0)) {
<a name="line1439">1439: </a>            <font color="#4169E1">if</font> (curpt_dom != -1) {
<a name="line1440">1440: </a>              <font color="#4169E1">if</font> (m-&gt;getValue(traversal, curpt_dom) == 0) {
<a name="line1441">1441: </a>                complist.push_front(curpt_dom);
<a name="line1442">1442: </a>                m-&gt;setValue(traversal, curpt_dom, 1);
<a name="line1443">1443: </a>              }
<a name="line1444">1444: </a>            }
<a name="line1445">1445: </a>          }
<a name="line1446">1446: </a>        }  //end of complist deal
<a name="line1447">1447: </a>        complist.clear();
<a name="line1448">1448: </a>        <font color="#4169E1">if</font> (canAdd == true) {
<a name="line1449">1449: </a>          m-&gt;setValue(hdepth, *bv_iter, curLevel);
<a name="line1450">1450: </a><strong><font color="#FF0000">          std:</font></strong>:list&lt;PETSC_MESH_TYPE::point_type&gt;::iterator dom_iter = domlist.begin();
<a name="line1451">1451: </a><strong><font color="#FF0000">          std:</font></strong>:list&lt;PETSC_MESH_TYPE::point_type&gt;::iterator dom_iter_end = domlist.end();
<a name="line1452">1452: </a>          <font color="#4169E1">while</font> (dom_iter != dom_iter_end) {
<a name="line1453">1453: </a>            m-&gt;setValue(dompoint, *dom_iter, *bv_iter);
<a name="line1454">1454: </a>            dom_iter++;
<a name="line1455">1455: </a>          }
<a name="line1456">1456: </a>        }
<a name="line1457">1457: </a>        domlist.clear();
<a name="line1458">1458: </a>        complist.clear();
<a name="line1459">1459: </a>        //unset the traversal listing
<a name="line1460">1460: </a><strong><font color="#FF0000">        ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::label_sequence&gt; travnodes = m-&gt;getLabelStratum(<font color="#666666">"traversal"</font>, 1);
<a name="line1461">1461: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator tn_iter = travnodes-&gt;begin();
<a name="line1462">1462: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator tn_iter_end = travnodes-&gt;end();
<a name="line1463">1463: </a>        <font color="#4169E1">while</font> (tn_iter != tn_iter_end) {
<a name="line1464">1464: </a>          complist.push_front(*tn_iter);
<a name="line1465">1465: </a>          tn_iter++;
<a name="line1466">1466: </a>        }
<a name="line1467">1467: </a>        <font color="#4169E1">while</font> (!complist.empty()) {
<a name="line1468">1468: </a><strong><font color="#FF0000">          PETSC_MESH_TYPE:</font></strong>:point_type emptpt = *complist.begin();
<a name="line1469">1469: </a>          complist.pop_front();
<a name="line1470">1470: </a>          m-&gt;setValue(traversal, emptpt, 0);
<a name="line1471">1471: </a>        }
<a name="line1472">1472: </a>      }
<a name="line1473">1473: </a>      bv_iter++;
<a name="line1474">1474: </a>    }
<a name="line1475">1475: </a>  //  <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"Included %d new points in level %d\n"</font>, m-&gt;getLabelStratum(<font color="#666666">"hdepth"</font>, curLevel)-&gt;size(), curLevel);
<a name="line1476">1476: </a><strong><font color="#FF0000">    ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE&gt; newmesh;
<a name="line1477">1477: </a>    // = MeshCreateHierarchyMesh(m, nLevels, curLevel);
<a name="line1478">1478: </a>    <font color="#4169E1">if</font> (info)<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"%d: %d vertices, %d elements in %d comparisons\n"</font>, curLevel, newmesh-&gt;depthStratum(0)-&gt;size(), newmesh-&gt;heightStratum(0)-&gt;size(), nComparisonsTotal);
<a name="line1479">1479: </a>    overallComparisons += nComparisonsTotal; //yeah yeah horrible names

<a name="line1481">1481: </a>    <A href="../../../../docs/manualpages/Mesh/MeshSetMesh.html#MeshSetMesh">MeshSetMesh</A>(outmeshes[curLevel-1], newmesh);
<a name="line1482">1482: </a><font color="#B22222">/*    <A href="../../../../docs/manualpages/Mesh/SectionRealCreate.html#SectionRealCreate">SectionRealCreate</A>(newmesh-&gt;comm(), &amp;section);</font>
<a name="line1483">1483: </a><font color="#B22222">    <A href="../../../../docs/manualpages/Mesh/SectionRealGetBundle.html#SectionRealGetBundle">SectionRealGetBundle</A>(section, newmesh);</font>
<a name="line1484">1484: </a><font color="#B22222">    <A href="../../../../docs/manualpages/Mesh/SectionRealGetSection.html#SectionRealGetSection">SectionRealGetSection</A>(section, s);</font>
<a name="line1485">1485: </a><font color="#B22222">    <A href="../../../../docs/manualpages/Sys/PetscObjectSetName.html#PetscObjectSetName">PetscObjectSetName</A>((<A href="../../../../docs/manualpages/Sys/PetscObject.html#PetscObject">PetscObject</A>) section, "default");</font>
<a name="line1486">1486: </a><font color="#B22222">    <A href="../../../../docs/manualpages/Mesh/MeshSetSectionReal.html#MeshSetSectionReal">MeshSetSectionReal</A>(outmeshes[curLevel-1], section);</font>
<a name="line1487">1487: </a><font color="#B22222">    <A href="../../../../docs/manualpages/Mesh/SectionRealDestroy.html#SectionRealDestroy">SectionRealDestroy</A>(section);*/</font>
<a name="line1488">1488: </a>  } //end of level <font color="#4169E1">for</font>
<a name="line1489">1489: </a>  delete [] bvCoords;
<a name="line1490">1490: </a>  <font color="#4169E1">if</font> (info)<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"Comparisons per Point: %f\n"</font>, (float)overallComparisons/vertices-&gt;size());
<a name="line1491">1491: </a>  //std::list&lt;PETSC_MESH_TYPE::point_type&gt; tricomplist;
<a name="line1492">1492: </a><font color="#B22222">/*  for (int curLevel = 0; curLevel &lt; nLevels-1; curLevel++) {</font>
<a name="line1493">1493: </a><font color="#B22222">    if (info) <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), "Building the prolongation section from level %d to level %d\n", curLevel, curLevel+1);</font>
<a name="line1494">1494: </a><font color="#B22222">    ALE::Obj&lt;PETSC_MESH_TYPE&gt; c_m;</font>
<a name="line1495">1495: </a><font color="#B22222">    ALE::Obj&lt;PETSC_MESH_TYPE&gt; f_m;</font>
<a name="line1496">1496: </a><font color="#B22222">    if (curLevel == 0) {</font>
<a name="line1497">1497: </a><font color="#B22222">      f_m = m;</font>
<a name="line1498">1498: </a><font color="#B22222">    } else {</font>
<a name="line1499">1499: </a><font color="#B22222">      <A href="../../../../docs/manualpages/Mesh/MeshGetMesh.html#MeshGetMesh">MeshGetMesh</A>(outmeshes[curLevel-1], f_m);</font>
<a name="line1500">1500: </a><font color="#B22222">    }</font>
<a name="line1501">1501: </a><font color="#B22222">    <A href="../../../../docs/manualpages/Mesh/MeshGetMesh.html#MeshGetMesh">MeshGetMesh</A>(outmeshes[curLevel], c_m);</font>
<a name="line1502">1502: </a><font color="#B22222">    ALE::Obj&lt;PETSC_MESH_TYPE::label_type&gt; prolongation = f_m-&gt;createLabel("prolongation");</font>
<a name="line1503">1503: </a><font color="#B22222">    ALE::Obj&lt;PETSC_MESH_TYPE::label_type&gt; coarse_traversal = c_m-&gt;createLabel("traversal");</font>
<a name="line1504">1504: </a><font color="#B22222">    ALE::Obj&lt;PETSC_MESH_TYPE::label_sequence&gt; levelVertices = m-&gt;getLabelStratum("hdepth", curLevel);</font>
<a name="line1505">1505: </a><font color="#B22222">   // <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), "%d points in level %d\n", levelVertices-&gt;size(), curLevel);</font>
<a name="line1506">1506: </a><font color="#B22222">    PETSC_MESH_TYPE::label_sequence::iterator lv_iter = levelVertices-&gt;begin();</font>
<a name="line1507">1507: </a><font color="#B22222">    PETSC_MESH_TYPE::label_sequence::iterator lv_iter_end = levelVertices-&gt;end();</font>
<a name="line1508">1508: </a><font color="#B22222">    int interpolatelevels = c_m-&gt;height(*c_m-&gt;depthStratum(0)-&gt;begin()); //see if the mesh is interpolated or not</font>
<a name="line1509">1509: </a><font color="#B22222">    double lvCoords[dim];</font>
<a name="line1510">1510: </a><font color="#B22222">    while (lv_iter != lv_iter_end) {</font>
<a name="line1511">1511: </a><font color="#B22222">      int ncomps = 0;</font>
<a name="line1512">1512: </a><font color="#B22222">      <A href="../../../../docs/manualpages/Sys/PetscMemcpy.html#PetscMemcpy">PetscMemcpy</A>(lvCoords, coordinates-&gt;restrictPoint(*lv_iter), dim*sizeof(double));</font>
<a name="line1513">1513: </a><font color="#B22222">      if (m-&gt;getValue(boundary, *lv_iter) != 1) {</font>
<a name="line1514">1514: </a><font color="#B22222">        //get the triangle/tet fan around the dominating point in the next level up</font>
<a name="line1515">1515: </a><font color="#B22222">        PETSC_MESH_TYPE::point_type dp = m-&gt;getValue(dompoint, *lv_iter);</font>
<a name="line1516">1516: </a><font color="#B22222">        if (m-&gt;getValue(hdepth, dp) &lt; curLevel+1) dp = m-&gt;getValue(dompoint, dp); //if it's a boundary node it can be a dominating point and NOT be in the topmesh</font>
<a name="line1517">1517: </a><font color="#B22222">        ALE::Obj&lt;PETSC_MESH_TYPE::sieve_type::supportArray&gt; trifan = c_m-&gt;getSieve()-&gt;nSupport(*c_m-&gt;getLabelStratum("fine", dp)-&gt;begin(), interpolatelevels);</font>
<a name="line1518">1518: </a><font color="#B22222">        PETSC_MESH_TYPE::sieve_type::supportArray::iterator tf_iter = trifan-&gt;begin();</font>
<a name="line1519">1519: </a><font color="#B22222">        PETSC_MESH_TYPE::sieve_type::supportArray::iterator tf_iter_end = trifan-&gt;end();</font>
<a name="line1520">1520: </a><font color="#B22222">        while (tf_iter != tf_iter_end) {</font>
<a name="line1521">1521: </a><font color="#B22222">          tricomplist.push_front(*tf_iter); //initialize the closest-guess comparison list.</font>
<a name="line1522">1522: </a><font color="#B22222">          c_m-&gt;setValue(coarse_traversal, *tf_iter, 1);</font>
<a name="line1523">1523: </a><font color="#B22222">          tf_iter++;</font>
<a name="line1524">1524: </a><font color="#B22222">        }</font>
<a name="line1525">1525: </a><font color="#B22222">        //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), "%d initial guesses\n", trifan-&gt;size());</font>
<a name="line1526">1526: </a><font color="#B22222">        bool isFound = false;</font>
<a name="line1527">1527: </a><font color="#B22222">        while (!tricomplist.empty() &amp;&amp; !isFound) {</font>
<a name="line1528">1528: </a><font color="#B22222">          PETSC_MESH_TYPE::point_type curTri = *tricomplist.begin();</font>
<a name="line1529">1529: </a><font color="#B22222">          tricomplist.pop_front();</font>
<a name="line1530">1530: </a><font color="#B22222">          ncomps++;</font>
<a name="line1531">1531: </a><font color="#B22222">          if (PointIsInElement(c_m, curTri, lvCoords)) {</font>
<a name="line1532">1532: </a><font color="#B22222">            PETSC_MESH_TYPE::point_type fmpoint;</font>
<a name="line1533">1533: </a><font color="#B22222">            if (curLevel == 0) {</font>
<a name="line1534">1534: </a><font color="#B22222">              fmpoint = *lv_iter;</font>
<a name="line1535">1535: </a><font color="#B22222">            } else {</font>
<a name="line1536">1536: </a><font color="#B22222">              fmpoint = *f_m-&gt;getLabelStratum("fine", *lv_iter)-&gt;begin();</font>
<a name="line1537">1537: </a><font color="#B22222">            } </font>
<a name="line1538">1538: </a><font color="#B22222">            f_m-&gt;setValue(prolongation, fmpoint, curTri);</font>
<a name="line1539">1539: </a><font color="#B22222">            isFound = true;</font>
<a name="line1540">1540: </a><font color="#B22222">          //  <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), "%d located in %d\n", *lv_iter, curTri);</font>
<a name="line1541">1541: </a><font color="#B22222">          } else {</font>
<a name="line1542">1542: </a><font color="#B22222">            ALE::Obj&lt;PETSC_MESH_TYPE::sieve_type::supportSet&gt; trineighbors = c_m-&gt;getSieve()-&gt;support(c_m-&gt;getSieve()-&gt;cone(curTri));</font>
<a name="line1543">1543: </a><font color="#B22222">            PETSC_MESH_TYPE::sieve_type::supportSet::iterator tn_iter = trineighbors-&gt;begin();</font>
<a name="line1544">1544: </a><font color="#B22222">            PETSC_MESH_TYPE::sieve_type::supportSet::iterator tn_iter_end = trineighbors-&gt;end();</font>
<a name="line1545">1545: </a><font color="#B22222">            while (tn_iter != tn_iter_end) {</font>
<a name="line1546">1546: </a><font color="#B22222">              if (c_m-&gt;getValue(coarse_traversal, *tn_iter) != 1){</font>
<a name="line1547">1547: </a><font color="#B22222">                tricomplist.push_back(*tn_iter);</font>
<a name="line1548">1548: </a><font color="#B22222">                c_m-&gt;setValue(coarse_traversal, *tn_iter, 1);</font>
<a name="line1549">1549: </a><font color="#B22222">              }</font>
<a name="line1550">1550: </a><font color="#B22222">              tn_iter++;</font>
<a name="line1551">1551: </a><font color="#B22222">            }</font>
<a name="line1552">1552: </a><font color="#B22222">          }</font>
<a name="line1553">1553: </a><font color="#B22222">        }</font>
<a name="line1554">1554: </a><font color="#B22222">        ALE::Obj&lt;PETSC_MESH_TYPE::label_sequence&gt; travtris = c_m-&gt;getLabelStratum("traversal", 1);</font>
<a name="line1555">1555: </a><font color="#B22222">        PETSC_MESH_TYPE::label_sequence::iterator tt_iter = travtris-&gt;begin();</font>
<a name="line1556">1556: </a><font color="#B22222">        PETSC_MESH_TYPE::label_sequence::iterator tt_iter_end = travtris-&gt;end();</font>
<a name="line1557">1557: </a><font color="#B22222">        while (tt_iter != tt_iter_end) {</font>
<a name="line1558">1558: </a><font color="#B22222">          tricomplist.push_front(*tt_iter);</font>
<a name="line1559">1559: </a><font color="#B22222">          tt_iter++;</font>
<a name="line1560">1560: </a><font color="#B22222">        }</font>
<a name="line1561">1561: </a><font color="#B22222">        while (!tricomplist.empty()) {</font>
<a name="line1562">1562: </a><font color="#B22222">          c_m-&gt;setValue(coarse_traversal, *tricomplist.begin(), 0);</font>
<a name="line1563">1563: </a><font color="#B22222">          tricomplist.pop_front();</font>
<a name="line1564">1564: </a><font color="#B22222">        }</font>
<a name="line1565">1565: </a><font color="#B22222">        if (!isFound) {</font>
<a name="line1566">1566: </a><font color="#B22222">          <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), "ERROR: Could Not Locate Point %d (%f, %f) in %d comparisons\n", *lv_iter, lvCoords[0], lvCoords[1], ncomps);</font>
<a name="line1567">1567: </a><font color="#B22222">        }</font>
<a name="line1568">1568: </a><font color="#B22222">      } else { //DO NOT correct the boundary nodes only added on this level. (might break neumann)</font>
<a name="line1569">1569: </a><font color="#B22222">        PETSC_MESH_TYPE::point_type fmpoint;</font>
<a name="line1570">1570: </a><font color="#B22222">        if (curLevel == 0) {</font>
<a name="line1571">1571: </a><font color="#B22222">          fmpoint = *lv_iter;</font>
<a name="line1572">1572: </a><font color="#B22222">        } else {</font>
<a name="line1573">1573: </a><font color="#B22222">          fmpoint = *f_m-&gt;getLabelStratum("fine", *lv_iter)-&gt;begin();</font>
<a name="line1574">1574: </a><font color="#B22222">        } </font>
<a name="line1575">1575: </a><font color="#B22222">        f_m-&gt;setValue(prolongation, fmpoint, -1);</font>
<a name="line1576">1576: </a><font color="#B22222">      }</font>
<a name="line1577">1577: </a><font color="#B22222">      lv_iter++;</font>
<a name="line1578">1578: </a><font color="#B22222">    }</font>
<a name="line1579">1579: </a><font color="#B22222">    //set the prolongation label for the guys in this mesh in such a way that there's an element associated for the points in higher levels also.</font>
<a name="line1580">1580: </a><font color="#B22222">    for (int upLevel = curLevel + 1; upLevel &lt; nLevels - 1; upLevel++) {</font>
<a name="line1581">1581: </a><font color="#B22222">      levelVertices = m-&gt;getLabelStratum("hdepth", upLevel);</font>
<a name="line1582">1582: </a><font color="#B22222">      lv_iter = levelVertices-&gt;begin();</font>
<a name="line1583">1583: </a><font color="#B22222">      lv_iter_end = levelVertices-&gt;end();</font>
<a name="line1584">1584: </a><font color="#B22222">      while (lv_iter != lv_iter_end) {</font>
<a name="line1585">1585: </a><font color="#B22222">        //if (m-&gt;getValue(boundary, *lv_iter) != 1) { we CAN correct for the boundary, and should!</font>
<a name="line1586">1586: </a><font color="#B22222">          //nothing complicated, just take the FIRST element of the nSupport of it in the next mesh up.</font>
<a name="line1587">1587: </a><font color="#B22222">          PETSC_MESH_TYPE::point_type cmpt = *c_m-&gt;getLabelStratum("fine", *lv_iter)-&gt;begin();</font>
<a name="line1588">1588: </a><font color="#B22222">          PETSC_MESH_TYPE::point_type fmpoint;</font>
<a name="line1589">1589: </a><font color="#B22222">          if (curLevel == 0) {</font>
<a name="line1590">1590: </a><font color="#B22222">            fmpoint = *lv_iter;</font>
<a name="line1591">1591: </a><font color="#B22222">          } else {</font>
<a name="line1592">1592: </a><font color="#B22222">            fmpoint = *f_m-&gt;getLabelStratum("fine", *lv_iter)-&gt;begin();</font>
<a name="line1593">1593: </a><font color="#B22222">          } </font>
<a name="line1594">1594: </a><font color="#B22222">          f_m-&gt;setValue(prolongation, fmpoint, *c_m-&gt;getSieve()-&gt;nSupport(cmpt, interpolatelevels)-&gt;begin());</font>
<a name="line1595">1595: </a><font color="#B22222">        //}</font>
<a name="line1596">1596: </a><font color="#B22222">        lv_iter++;</font>
<a name="line1597">1597: </a><font color="#B22222">      }</font>
<a name="line1598">1598: </a><font color="#B22222">    }</font>
<a name="line1599">1599: </a><font color="#B22222">  }*/</font>
<a name="line1600">1600: </a><font color="#B22222">/*  if (info) <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), "Building the prolongation section from level %d to level %d\n", 0, 1);</font>
<a name="line1601">1601: </a><font color="#B22222">  MeshLocateInMesh(finemesh, outmeshes[0]);</font>
<a name="line1602">1602: </a><font color="#B22222">  for (int curLevel = 1; curLevel &lt; nLevels-1; curLevel++) {</font>
<a name="line1603">1603: </a><font color="#B22222">    if (info) <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), "Building the prolongation section from level %d to level %d\n", curLevel, curLevel+1);</font>
<a name="line1604">1604: </a><font color="#B22222">    MeshLocateInMesh(outmeshes[curLevel-1], outmeshes[curLevel]);</font>
<a name="line1605">1605: </a><font color="#B22222">  }</font>
<a name="line1606">1606: </a><font color="#B22222">*/</font>
<a name="line1607">1607: </a> <font color="#4169E1">return</font>(0);
<a name="line1608">1608: </a>}




<a name="line1615">1615: </a>//MeshCreateHierarchyLabel: Create a label that tells what the highest level a given vertex appears in where 0 is fine and n is coarsest.
<a name="line1616">1616: </a><strong><font color="#4169E1"><a name="MeshCreateHierarchyLabel_NEW"></a><A href="../../../../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode">PetscErrorCode</A> MeshCreateHierarchyLabel_NEW(Mesh finemesh, double beta, int nLevels, Mesh * outmeshes)</font></strong> {
<a name="line1618">1618: </a>

<a name="line1621">1621: </a>  //initialization
<a name="line1622">1622: </a><strong><font color="#FF0000">  ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE&gt; m;
<a name="line1623">1623: </a>  double maxspace = -1., minspace = -1., dist, current_beta;
<a name="line1624">1624: </a>  double v_space, c_space, total_space, max_total_space;
<a name="line1625">1625: </a>  double v_coords[3], c_coords[3];

<a name="line1627">1627: </a>  int mesh_vertices_size = 0;

<a name="line1629">1629: </a>  int v_point, v_bound, v_hdepth, v_dominating_point;
<a name="line1630">1630: </a>  int c_point, c_bound, c_hdepth, c_dominating_point;
<a name="line1631">1631: </a>  int n_point, n_bound, n_traversal;
<a name="line1632">1632: </a>
<a name="line1633">1633: </a><strong><font color="#FF0000">  std:</font></strong>:list&lt;PETSC_MESH_TYPE::point_type&gt; comparison_list;

<a name="line1635">1635: </a><strong><font color="#FF0000">  std:</font></strong>:list&lt;PETSC_MESH_TYPE::point_type&gt; traversed_list;

<a name="line1637">1637: </a><strong><font color="#FF0000">  std:</font></strong>:list&lt;PETSC_MESH_TYPE::point_type&gt; dominated_list;
<a name="line1638">1638: </a><strong><font color="#FF0000">  std:</font></strong>:list&lt;PETSC_MESH_TYPE::point_type&gt;::iterator dominated_list_iter = dominated_list.begin();
<a name="line1639">1639: </a><strong><font color="#FF0000">  std:</font></strong>:list&lt;PETSC_MESH_TYPE::point_type&gt;::iterator dominated_list_iter_end = dominated_list.end();

<a name="line1641">1641: </a>
<a name="line1642">1642: </a>  bool canAdd, skip;
<a name="line1643">1643: </a>
<a name="line1644">1644: </a>  <A href="../../../../docs/manualpages/Mesh/MeshGetMesh.html#MeshGetMesh">MeshGetMesh</A>(finemesh, m);

<a name="line1646">1646: </a>  int dim = m-&gt;getDimension();

<a name="line1648">1648: </a>  <font color="#4169E1">if</font> (!m-&gt;hasLabel(<font color="#666666">"marker"</font>))MeshIDBoundary(finemesh);
<a name="line1649">1649: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::label_type&gt;&amp; boundary = m-&gt;getLabel(<font color="#666666">"marker"</font>);

<a name="line1651">1651: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::real_section_type&gt;&amp; coordinates = m-&gt;getRealSection(<font color="#666666">"coordinates"</font>);
<a name="line1652">1652: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::real_section_type&gt;&amp; spacing = m-&gt;getRealSection(<font color="#666666">"spacing"</font>);
<a name="line1653">1653: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::label_type&gt; hdepth = m-&gt;createLabel(<font color="#666666">"hierarchy_depth"</font>);
<a name="line1654">1654: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::label_type&gt; dompoint = m-&gt;createLabel(<font color="#666666">"dominating_point"</font>);
<a name="line1655">1655: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::label_type&gt; traversal = m-&gt;createLabel(<font color="#666666">"traversal"</font>);

<a name="line1657">1657: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::sieve_type&gt; sieve = m-&gt;getSieve();
<a name="line1658">1658: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::label_sequence&gt;&amp; vertices = m-&gt;depthStratum(0);
<a name="line1659">1659: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator v_iter = vertices-&gt;begin();
<a name="line1660">1660: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator v_iter_end = vertices-&gt;end();
<a name="line1661">1661: </a>
<a name="line1662">1662: </a>  //Setup, find the minimum and maximum spacing values and force in high-curvature nodes.
<a name="line1663">1663: </a>  <font color="#4169E1">while</font>(v_iter != v_iter_end) {

<a name="line1665">1665: </a>    v_point = *v_iter;
<a name="line1666">1666: </a>    v_bound = m-&gt;getValue(boundary, v_point);
<a name="line1667">1667: </a>    m-&gt;setValue(dompoint, v_point, -1);
<a name="line1668">1668: </a>    m-&gt;setValue(hdepth, v_point, 0);
<a name="line1669">1669: </a>    v_space = *spacing-&gt;restrictPoint(v_point);

<a name="line1671">1671: </a>    <font color="#4169E1">if</font> ((v_space &gt; maxspace) || (maxspace == -1.)) maxspace = v_space;
<a name="line1672">1672: </a>    <font color="#4169E1">if</font> ((v_space &lt; minspace) || (minspace == -1.)) minspace = v_space;

<a name="line1674">1674: </a>    <font color="#4169E1">if</font> (m-&gt;depth(v_point) == 0 &amp;&amp; v_bound == 1) <font color="#4169E1">if</font> (Curvature(m, v_point) &gt; 0.01) {
<a name="line1675">1675: </a>      m-&gt;setValue(hdepth, v_point, nLevels-1);
<a name="line1676">1676: </a>    }

<a name="line1678">1678: </a>    v_iter++;
<a name="line1679">1679: </a>  }

<a name="line1681">1681: </a>  //main loop over levels
<a name="line1682">1682: </a>  <font color="#4169E1">for</font> (int current_level = nLevels - 1; current_level &gt; 0; current_level--) {

<a name="line1684">1684: </a>    current_beta = 0.5*pow(beta, current_level);
<a name="line1685">1685: </a>    v_iter = vertices-&gt;begin();
<a name="line1686">1686: </a>    v_iter_end = vertices-&gt;end();
<a name="line1687">1687: </a>    <font color="#4169E1">while</font> (v_iter != v_iter_end) {

<a name="line1689">1689: </a>      v_point = *v_iter;
<a name="line1690">1690: </a>      v_hdepth = m-&gt;getValue(hdepth, v_point);
<a name="line1691">1691: </a>      v_dominating_point = m-&gt;getValue(dompoint, v_point);

<a name="line1693">1693: </a>      //determine <font color="#4169E1">if</font> this point has already been eliminated this round
<a name="line1694">1694: </a>      skip = false;
<a name="line1695">1695: </a>      <font color="#4169E1">if</font> (v_dominating_point != -1) {
<a name="line1696">1696: </a>        <font color="#4169E1">if</font> (m-&gt;getValue(hdepth, v_dominating_point) == current_level) skip = true;
<a name="line1697">1697: </a>      }

<a name="line1699">1699: </a>      <font color="#4169E1">if</font> (v_hdepth == 0 &amp;&amp; !skip) {
<a name="line1700">1700: </a>        v_bound = m-&gt;getValue(boundary, v_point);
<a name="line1701">1701: </a>        //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"%d\n"</font>, v_point);
<a name="line1702">1702: </a>        //get the coordinates and spacing function values <font color="#4169E1">for</font> this point.
<a name="line1703">1703: </a>        v_space = *spacing-&gt;restrictPoint(v_point);
<a name="line1704">1704: </a>        <A href="../../../../docs/manualpages/Sys/PetscMemcpy.html#PetscMemcpy">PetscMemcpy</A>(v_coords, coordinates-&gt;restrictPoint(v_point), dim*<font color="#4169E1">sizeof</font>(double));
<a name="line1705">1705: </a>        max_total_space = current_beta*(v_space*3);  //keep EVERYTHING local, max-space blows up on highly-graded meshes

<a name="line1707">1707: </a>        //seed the comparison list and set the current point as traversed
<a name="line1708">1708: </a>        m-&gt;setValue(traversal, v_point, 1);
<a name="line1709">1709: </a>        traversed_list.push_front(v_point);
<a name="line1710">1710: </a>        <font color="#4169E1">if</font> (v_dominating_point != -1) {
<a name="line1711">1711: </a>          comparison_list.push_front(v_dominating_point);
<a name="line1712">1712: </a>          traversed_list.push_front(v_dominating_point);
<a name="line1713">1713: </a>          m-&gt;setValue(traversal, v_dominating_point, 1);
<a name="line1714">1714: </a>        }
<a name="line1715">1715: </a><strong><font color="#FF0000">        ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::coneSet&gt; neighbors = sieve-&gt;cone(sieve-&gt;support(v_point));
<a name="line1716">1716: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:sieve_type::coneSet::iterator n_iter = neighbors-&gt;begin();
<a name="line1717">1717: </a><strong><font color="#FF0000">        PETSC_MESH_TYPE:</font></strong>:sieve_type::coneSet::iterator n_iter_end = neighbors-&gt;end();
<a name="line1718">1718: </a>

<a name="line1720">1720: </a>        <font color="#4169E1">while</font> (n_iter != n_iter_end) {
<a name="line1721">1721: </a>          n_point = *n_iter;
<a name="line1722">1722: </a>          <font color="#4169E1">if</font> ((v_point != n_point)&amp;&amp;((m-&gt;getValue(boundary, n_point) == 1 &amp;&amp; v_bound == 1) || v_bound == 0)) {
<a name="line1723">1723: </a>            m-&gt;setValue(traversal, n_point, 1);
<a name="line1724">1724: </a>            traversed_list.push_front(n_point);
<a name="line1725">1725: </a>            comparison_list.push_back(n_point);
<a name="line1726">1726: </a>          }
<a name="line1727">1727: </a>          n_iter++;
<a name="line1728">1728: </a>        }
<a name="line1729">1729: </a>
<a name="line1730">1730: </a>        //traverse the mesh out to the point where nothing can collide with this point
<a name="line1731">1731: </a>        canAdd = true;
<a name="line1732">1732: </a>        <font color="#4169E1">while</font> (!comparison_list.empty() &amp;&amp; canAdd) {
<a name="line1733">1733: </a>
<a name="line1734">1734: </a>          c_point = comparison_list.front();
<a name="line1735">1735: </a>          comparison_list.pop_front();
<a name="line1736">1736: </a>          //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"%d\n"</font>, c_point);
<a name="line1737">1737: </a>          c_bound = m-&gt;getValue(boundary, c_point);
<a name="line1738">1738: </a>          c_hdepth = m-&gt;getValue(hdepth, c_point);
<a name="line1739">1739: </a>          c_dominating_point = m-&gt;getValue(dompoint, c_point);
<a name="line1740">1740: </a>          <A href="../../../../docs/manualpages/Sys/PetscMemcpy.html#PetscMemcpy">PetscMemcpy</A>(c_coords, coordinates-&gt;restrictPoint(c_point), dim*<font color="#4169E1">sizeof</font>(double));
<a name="line1741">1741: </a>
<a name="line1742">1742: </a>          //compute the distance
<a name="line1743">1743: </a>          dist = 0.;
<a name="line1744">1744: </a>          <font color="#4169E1">for</font> (int i = 0; i &lt; dim; i++) {
<a name="line1745">1745: </a>            dist += (c_coords[i] - v_coords[i])*(c_coords[i] - v_coords[i]);
<a name="line1746">1746: </a>          }
<a name="line1747">1747: </a>          dist = sqrt(dist);
<a name="line1748">1748: </a>
<a name="line1749">1749: </a>          <font color="#4169E1">if</font> (dist &lt; max_total_space) { //<font color="#4169E1">if</font> it could possibly collide in the function-ball sense:
<a name="line1750">1750: </a>            c_space = *spacing-&gt;restrictPoint(c_point);
<a name="line1751">1751: </a>            // <font color="#4169E1">if</font> it collides in the function-ball sense:
<a name="line1752">1752: </a>            total_space = current_beta*(v_space + c_space);
<a name="line1753">1753: </a>            <font color="#4169E1">if</font> (dist &lt; total_space) {
<a name="line1754">1754: </a>              <font color="#4169E1">if</font> (v_bound == 1) { //boundary <font color="#4169E1">case</font>
<a name="line1755">1755: </a>                <font color="#4169E1">if</font> (c_hdepth != 0) {
<a name="line1756">1756: </a>                  canAdd = false;
<a name="line1757">1757: </a>                  m-&gt;setValue(dompoint, v_point, c_point);
<a name="line1758">1758: </a>                } <font color="#4169E1">else</font> {
<a name="line1759">1759: </a>                  dominated_list.push_front(c_point);
<a name="line1760">1760: </a>                }
<a name="line1761">1761: </a>              } <font color="#4169E1">else</font> { //interior <font color="#4169E1">case</font>
<a name="line1762">1762: </a>                <font color="#4169E1">if</font> (c_hdepth != 0 || c_bound == 1) {
<a name="line1763">1763: </a>                   canAdd = false;
<a name="line1764">1764: </a>                   m-&gt;setValue(dompoint, v_point, c_point);
<a name="line1765">1765: </a>                } <font color="#4169E1">else</font> {  //add the current inspected point to the list of points potentially dominated
<a name="line1766">1766: </a>                  dominated_list.push_front(c_point);
<a name="line1767">1767: </a>                  //<font color="#4169E1">if</font> the dominating point is defined, test against it next.
<a name="line1768">1768: </a>                  <font color="#4169E1">if</font> (c_dominating_point != -1) {
<a name="line1769">1769: </a>                    <font color="#4169E1">if</font> (m-&gt;getValue(traversal, c_dominating_point) != 1) {
<a name="line1770">1770: </a>                      comparison_list.push_front(c_dominating_point);
<a name="line1771">1771: </a>                      traversed_list.push_front(c_dominating_point);
<a name="line1772">1772: </a>                      m-&gt;setValue(traversal, c_dominating_point, 1);
<a name="line1773">1773: </a>                    }
<a name="line1774">1774: </a>                  }
<a name="line1775">1775: </a>                }
<a name="line1776">1776: </a>              }
<a name="line1777">1777: </a>            }
<a name="line1778">1778: </a>            //add neighbors to the comparison queue
<a name="line1779">1779: </a>            neighbors = sieve-&gt;cone(sieve-&gt;support(c_point));
<a name="line1780">1780: </a>            n_iter = neighbors-&gt;begin();
<a name="line1781">1781: </a>            n_iter_end = neighbors-&gt;end();
<a name="line1782">1782: </a>            <font color="#4169E1">while</font> (n_iter != n_iter_end) {
<a name="line1783">1783: </a>
<a name="line1784">1784: </a>              n_point = *n_iter;
<a name="line1785">1785: </a>              //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"-%d\n"</font>, n_point);
<a name="line1786">1786: </a>              n_traversal = m-&gt;getValue(traversal, n_point);

<a name="line1788">1788: </a>              <font color="#4169E1">if</font> (n_traversal != 1) {

<a name="line1790">1790: </a>                n_bound = m-&gt;getValue(boundary, n_point);

<a name="line1792">1792: </a>                <font color="#4169E1">if</font> (c_bound == 1) { //boundary c_point <font color="#4169E1">case</font>: only add boundary points
<a name="line1793">1793: </a>                  <font color="#4169E1">if</font> (n_bound == 1) {
<a name="line1794">1794: </a>                    comparison_list.push_back(n_point);
<a name="line1795">1795: </a>                    m-&gt;setValue(traversal, n_point, 1);
<a name="line1796">1796: </a>                    traversed_list.push_front(n_point);
<a name="line1797">1797: </a>                  }
<a name="line1798">1798: </a>                } <font color="#4169E1">else</font> { //nonboundary c_point <font color="#4169E1">case</font>: add anything
<a name="line1799">1799: </a>                    comparison_list.push_back(n_point);
<a name="line1800">1800: </a>                    m-&gt;setValue(traversal, n_point, 1);
<a name="line1801">1801: </a>                    traversed_list.push_front(n_point);
<a name="line1802">1802: </a>                }
<a name="line1803">1803: </a>              }

<a name="line1805">1805: </a>              n_iter++;
<a name="line1806">1806: </a>            }

<a name="line1808">1808: </a>          }  // collision endif

<a name="line1810">1810: </a>        }  // comparison traversal loop end

<a name="line1812">1812: </a>        comparison_list.clear();

<a name="line1814">1814: </a>        //clean up the traversal label
<a name="line1815">1815: </a>        <font color="#4169E1">while</font> (!traversed_list.empty()) {
<a name="line1816">1816: </a>          n_point = traversed_list.front();
<a name="line1817">1817: </a>          traversed_list.pop_front();
<a name="line1818">1818: </a>          m-&gt;setValue(traversal, n_point, 0);
<a name="line1819">1819: </a>        }

<a name="line1821">1821: </a>        <font color="#4169E1">if</font> (canAdd == true) {
<a name="line1822">1822: </a>          //we can add the point, so put it at this level and set the points it dominates
<a name="line1823">1823: </a>          m-&gt;setValue (hdepth, v_point, current_level);
<a name="line1824">1824: </a>          dominated_list_iter = dominated_list.begin();
<a name="line1825">1825: </a>          dominated_list_iter_end = dominated_list.end();
<a name="line1826">1826: </a>          <font color="#4169E1">while</font> (dominated_list_iter != dominated_list_iter_end) {
<a name="line1827">1827: </a>            m-&gt;setValue(dompoint, *dominated_list_iter, v_point);
<a name="line1828">1828: </a>            dominated_list_iter++;
<a name="line1829">1829: </a>          }
<a name="line1830">1830: </a>        }
<a name="line1831">1831: </a>        dominated_list.clear();
<a name="line1832">1832: </a>      }  // eligible <font color="#4169E1">for</font> comparison endif
<a name="line1833">1833: </a>      v_iter++;
<a name="line1834">1834: </a>    } // vertices loop end
<a name="line1835">1835: </a>    mesh_vertices_size += m-&gt;getLabelStratum(<font color="#666666">"hierarchy_depth"</font>, current_level)-&gt;size();
<a name="line1836">1836: </a>    <A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(m-&gt;comm(), <font color="#666666">"Size of mesh: %d\n"</font>, mesh_vertices_size);
<a name="line1837">1837: </a>  } // levels loop end

<a name="line1839">1839: </a>  <font color="#4169E1">return</font>(0);
<a name="line1840">1840: </a>}

<a name="line1842">1842: </a>//MeshLocateInMesh: Create a label between the meshes.

<a name="line1844">1844: </a><strong><font color="#4169E1"><a name="MeshLocateInMesh"></a><A href="../../../../docs/manualpages/Sys/PetscErrorCode.html#PetscErrorCode">PetscErrorCode</A> MeshLocateInMesh(Mesh finemesh, Mesh coarsemesh)</font></strong> {
<a name="line1845">1845: </a><strong><font color="#FF0000">  ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE&gt; fm, cm;
<a name="line1848">1848: </a>  //int maxSearches = 30;
<a name="line1849">1849: </a>  <A href="../../../../docs/manualpages/Mesh/MeshGetMesh.html#MeshGetMesh">MeshGetMesh</A>(finemesh, fm);
<a name="line1850">1850: </a>  <A href="../../../../docs/manualpages/Mesh/MeshGetMesh.html#MeshGetMesh">MeshGetMesh</A>(coarsemesh, cm);

<a name="line1852">1852: </a>  //set up the prolongation section <font color="#4169E1">if</font> it doesn't already exist
<a name="line1853">1853: </a>  //bool prolongexists = fm-&gt;hasLabel(<font color="#666666">"prolongation"</font>);
<a name="line1854">1854: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::label_type&gt;&amp; prolongation = fm-&gt;createLabel(<font color="#666666">"prolongation"</font>);

<a name="line1856">1856: </a>  //we have a prolongation label that does not correspond to our current mesh.  Reset it to -1s.
<a name="line1857">1857: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::label_sequence&gt;&amp; finevertices = fm-&gt;depthStratum(0);
<a name="line1858">1858: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator fv_iter = finevertices-&gt;begin();
<a name="line1859">1859: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator fv_iter_end = finevertices-&gt;end();

<a name="line1861">1861: </a>  <font color="#4169E1">while</font> (fv_iter != fv_iter_end) {
<a name="line1862">1862: </a>    fm-&gt;setValue(prolongation, *fv_iter, -1);
<a name="line1863">1863: </a>    fv_iter++;
<a name="line1864">1864: </a>  }
<a name="line1865">1865: </a>  //traversal labels on both layers
<a name="line1866">1866: </a><strong><font color="#FF0000">  ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::label_type&gt; coarsetraversal = cm-&gt;createLabel(<font color="#666666">"traversal"</font>);
<a name="line1867">1867: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::real_section_type&gt;&amp;  finecoordinates = fm-&gt;getRealSection(<font color="#666666">"coordinates"</font>);
<a name="line1868">1868: </a>  //const ALE::Obj&lt;PETSC_MESH_TYPE::real_section_type&gt;&amp;  coarsecoordinates = cm-&gt;getRealSection(<font color="#666666">"coordinates"</font>);
<a name="line1869">1869: </a>  int dim = fm-&gt;getDimension();
<a name="line1870">1870: </a>  //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(cm-&gt;comm(), <font color="#666666">"Dimensions: %d and %d\n"</font>, dim, cm-&gt;getDimension());
<a name="line1871">1871: </a>  <font color="#4169E1">if</font> (dim != cm-&gt;getDimension()) throw ALE::Exception(<font color="#666666">"Dimensions of the fine and coarse meshes do not match"</font>);
<a name="line1872">1872: </a>  //<font color="#4169E1">do</font> the tandem traversal thing.  it is possible that <font color="#4169E1">if</font> the section already existed then the locations of some of the points are known <font color="#4169E1">if</font> they exist in both the meshes.
<a name="line1873">1873: </a>  fv_iter = finevertices-&gt;begin();
<a name="line1874">1874: </a>  fv_iter_end = finevertices-&gt;end();
<a name="line1875">1875: </a>  const ALE::Obj&lt;PETSC_MESH_TYPE::label_sequence&gt;&amp; coarseelements = cm-&gt;heightStratum(0);
<a name="line1876">1876: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator ce_iter = coarseelements-&gt;begin();
<a name="line1877">1877: </a><strong><font color="#FF0000">  PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator ce_iter_end = coarseelements-&gt;end();
<a name="line1878">1878: </a>  double *fvCoords = new double[dim], *nvCoords = new double[dim];
<a name="line1879">1879: </a><strong><font color="#FF0000">  std:</font></strong>:list&lt;PETSC_MESH_TYPE::point_type&gt; travlist;  //store point
<a name="line1880">1880: </a>//  std::list&lt;PETSC_MESH_TYPE::point_type&gt; travElist; //store element location <font color="#666666">"guesses"</font>
<a name="line1881">1881: </a><strong><font color="#FF0000">  std:</font></strong>:list&lt;PETSC_MESH_TYPE::point_type&gt; eguesslist; // store the next guesses <font color="#4169E1">for</font> the location of the current point.
<a name="line1882">1882: </a>  <font color="#4169E1">while</font> (fv_iter != fv_iter_end) {

<a name="line1884">1884: </a>    //locate an initial point.
<a name="line1885">1885: </a>    <font color="#4169E1">if</font> (fm-&gt;getValue(prolongation, *fv_iter) == -1) {
<a name="line1886">1886: </a>      ce_iter = coarseelements-&gt;begin();
<a name="line1887">1887: </a>      ce_iter_end = coarseelements-&gt;end();
<a name="line1888">1888: </a>      bool isLocated = false;
<a name="line1889">1889: </a>      <A href="../../../../docs/manualpages/Sys/PetscMemcpy.html#PetscMemcpy">PetscMemcpy</A>(fvCoords, finecoordinates-&gt;restrictPoint(*fv_iter), dim*<font color="#4169E1">sizeof</font>(double));
<a name="line1890">1890: </a>      <font color="#4169E1">while</font> ((ce_iter != ce_iter_end) &amp;&amp; (!isLocated)) {
<a name="line1891">1891: </a>        <font color="#4169E1">if</font> (PointIsInElement(cm, *ce_iter, fvCoords)) {
<a name="line1892">1892: </a>          isLocated = true;
<a name="line1893">1893: </a>          fm-&gt;setValue(prolongation, *fv_iter, *ce_iter);
<a name="line1894">1894: </a>          //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(fm-&gt;comm(), <font color="#666666">"INITIAL: Point %d located in %d.\n"</font>,  *fv_iter, *ce_iter);
<a name="line1895">1895: </a>          //OK WE HAVE A STARTING POINT.  Go through its neighbors looking at the unfound ones and finding them homes.
<a name="line1896">1896: </a><strong><font color="#FF0000">          ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::coneSet&gt; neighbors = fm-&gt;getSieve()-&gt;cone(fm-&gt;getSieve()-&gt;support(*fv_iter));
<a name="line1897">1897: </a><strong><font color="#FF0000">          PETSC_MESH_TYPE:</font></strong>:sieve_type::coneSet::iterator n_iter = neighbors-&gt;begin();
<a name="line1898">1898: </a><strong><font color="#FF0000">          PETSC_MESH_TYPE:</font></strong>:sieve_type::coneSet::iterator n_iter_end = neighbors-&gt;end();
<a name="line1899">1899: </a>          <font color="#4169E1">while</font> (n_iter != n_iter_end) {
<a name="line1900">1900: </a>            <font color="#4169E1">if</font> (fm-&gt;getValue(prolongation, *n_iter) == -1) {
<a name="line1901">1901: </a>//              travElist.push_front(*ce_iter);
<a name="line1902">1902: </a>              travlist.push_back(*n_iter);
<a name="line1903">1903: </a>              fm-&gt;setValue(prolongation, *n_iter, *ce_iter); //guess the next prolongation
<a name="line1904">1904: </a>            }
<a name="line1905">1905: </a>            n_iter++;
<a name="line1906">1906: </a>          }

<a name="line1908">1908: </a>          //<font color="#4169E1">do</font> a DFS across the finemesh with BFSes on the coarse mesh <font color="#4169E1">for</font> each point using assumed regularity of edgelength as a justification <font color="#4169E1">for</font> guessing neighboring point's locations.
<a name="line1909">1909: </a>          <font color="#4169E1">while</font> (!travlist.empty()) {
<a name="line1910">1910: </a><strong><font color="#FF0000">            PETSC_MESH_TYPE:</font></strong>:point_type curVert = *travlist.begin();
<a name="line1911">1911: </a>            <A href="../../../../docs/manualpages/Sys/PetscMemcpy.html#PetscMemcpy">PetscMemcpy</A>(nvCoords, finecoordinates-&gt;restrictPoint(curVert), dim*<font color="#4169E1">sizeof</font>(double));
<a name="line1912">1912: </a><strong><font color="#FF0000">            PETSC_MESH_TYPE:</font></strong>:point_type curEle =  fm-&gt;getValue(prolongation, curVert);
<a name="line1913">1913: </a>            travlist.pop_front();
<a name="line1914">1914: </a>            //travElist.pop_front();
<a name="line1915">1915: </a>            eguesslist.push_front(curEle);
<a name="line1916">1916: </a>            cm-&gt;setValue(coarsetraversal, curEle, 1);
<a name="line1917">1917: </a>            bool locationDiscovered = false;
<a name="line1918">1918: </a>            <font color="#4169E1">while</font> ((!eguesslist.empty()) &amp;&amp; (!locationDiscovered)) {
<a name="line1919">1919: </a><strong><font color="#FF0000">              PETSC_MESH_TYPE:</font></strong>:point_type curguess = *eguesslist.begin();
<a name="line1920">1920: </a>              eguesslist.pop_front();
<a name="line1921">1921: </a>              <font color="#4169E1">if</font> (PointIsInElement(cm, curguess, nvCoords)) {
<a name="line1922">1922: </a>                locationDiscovered = true;
<a name="line1923">1923: </a>                //set the label.
<a name="line1924">1924: </a>                fm-&gt;setValue(prolongation, curVert, curguess);
<a name="line1925">1925: </a>                //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(fm-&gt;comm(), <font color="#666666">"Point %d located in %d.\n"</font>,  curVert, curguess);
<a name="line1926">1926: </a>                //stick its neighbors in the queue along with its location as a good guess of the location of its neighbors
<a name="line1927">1927: </a>                neighbors = fm-&gt;getSieve()-&gt;cone(fm-&gt;getSieve()-&gt;support(curVert));
<a name="line1928">1928: </a>                n_iter = neighbors-&gt;begin();
<a name="line1929">1929: </a>                n_iter_end = neighbors-&gt;end();
<a name="line1930">1930: </a>                <font color="#4169E1">while</font> (n_iter != n_iter_end) {
<a name="line1931">1931: </a>                  <font color="#4169E1">if</font> (fm-&gt;getValue(prolongation, *n_iter) == -1) { //unlocated neighbor
<a name="line1932">1932: </a>                    travlist.push_back(*n_iter);
<a name="line1933">1933: </a>                    //travElist.push_front(curguess);
<a name="line1934">1934: </a>                    fm-&gt;setValue(prolongation, *n_iter, curguess);
<a name="line1935">1935: </a>                  }
<a name="line1936">1936: </a>                  n_iter++;
<a name="line1937">1937: </a>                }
<a name="line1938">1938: </a>              } <font color="#4169E1">else</font> {
<a name="line1939">1939: </a>              //add the current guesses neighbors to the comparison queue and start over.
<a name="line1940">1940: </a><strong><font color="#FF0000">                ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::sieve_type::supportSet&gt; curguessneighbors = cm-&gt;getSieve()-&gt;support(cm-&gt;getSieve()-&gt;cone(curguess));
<a name="line1941">1941: </a><strong><font color="#FF0000">                PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSet::iterator cgn_iter = curguessneighbors-&gt;begin();
<a name="line1942">1942: </a><strong><font color="#FF0000">                PETSC_MESH_TYPE:</font></strong>:sieve_type::supportSet::iterator cgn_iter_end = curguessneighbors-&gt;end();
<a name="line1943">1943: </a>                <font color="#4169E1">while</font> (cgn_iter != cgn_iter_end) {
<a name="line1944">1944: </a>                  <font color="#4169E1">if</font> (cm-&gt;getValue(coarsetraversal, *cgn_iter) != 1) {
<a name="line1945">1945: </a>                    eguesslist.push_back(*cgn_iter);
<a name="line1946">1946: </a>                    cm-&gt;setValue(coarsetraversal, *cgn_iter, 1);
<a name="line1947">1947: </a>                  }
<a name="line1948">1948: </a>                  cgn_iter++;
<a name="line1949">1949: </a>                }
<a name="line1950">1950: </a>              }
<a name="line1951">1951: </a>            }
<a name="line1952">1952: </a>            <font color="#4169E1">if</font> (!locationDiscovered) {
<a name="line1953">1953: </a>              fm-&gt;setValue(prolongation, curVert, -2); //put it back in the list of orphans.
<a name="line1954">1954: </a>              <font color="#4169E1">if</font>(fm-&gt;debug())<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(fm-&gt;comm(), <font color="#666666">"Point %d (%f, %f) not located.\n"</font>,  curVert, nvCoords[0], nvCoords[1]);
<a name="line1955">1955: </a>            }
<a name="line1956">1956: </a>            eguesslist.clear(); //we've discovered the location of the point or exhausted our possibilities on this contiguous block of elements.
<a name="line1957">1957: </a>            //unset the traversed element list
<a name="line1958">1958: </a><strong><font color="#FF0000">            ALE:</font></strong>:Obj&lt;PETSC_MESH_TYPE::label_sequence&gt; traved_elements = cm-&gt;getLabelStratum(<font color="#666666">"traversal"</font>, 1);
<a name="line1959">1959: </a>            //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(cm-&gt;comm(), <font color="#666666">"%d\n"</font>, traved_elements-&gt;size());
<a name="line1960">1960: </a><strong><font color="#FF0000">            PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator tp_iter = traved_elements-&gt;begin();
<a name="line1961">1961: </a><strong><font color="#FF0000">            PETSC_MESH_TYPE:</font></strong>:label_sequence::iterator tp_iter_end = traved_elements-&gt;end();
<a name="line1962">1962: </a>            <font color="#4169E1">while</font> (tp_iter != tp_iter_end) {
<a name="line1963">1963: </a>              eguesslist.push_back(*tp_iter);
<a name="line1964">1964: </a>              tp_iter++;
<a name="line1965">1965: </a>            }
<a name="line1966">1966: </a>            <font color="#4169E1">while</font> (!eguesslist.empty()) {
<a name="line1967">1967: </a>              cm-&gt;setValue(coarsetraversal, *eguesslist.begin(), 0);
<a name="line1968">1968: </a>              eguesslist.pop_front();
<a name="line1969">1969: </a>            }
<a name="line1970">1970: </a>          }
<a name="line1971">1971: </a>        }
<a name="line1972">1972: </a>        ce_iter++;
<a name="line1973">1973: </a>      }
<a name="line1974">1974: </a>      <font color="#4169E1">if</font> (!isLocated) {
<a name="line1975">1975: </a>       fm-&gt;setValue(prolongation, *fv_iter, -2);
<a name="line1976">1976: </a>      }
<a name="line1977">1977: </a>    }
<a name="line1978">1978: </a>   // printf(<font color="#666666">"-"</font>);
<a name="line1979">1979: </a>    fv_iter++;
<a name="line1980">1980: </a>  }
<a name="line1981">1981: </a>  delete [] fvCoords; delete [] nvCoords;
<a name="line1982">1982: </a>  <font color="#4169E1">return</font>(0);
<a name="line1983">1983: </a>}

<a name="line1985">1985: </a>bool PointIsInElement(ALE::Obj&lt;PETSC_MESH_TYPE&gt; mesh, PETSC_MESH_TYPE::point_type e, double * point) {
<a name="line1986">1986: </a>      int dim = mesh-&gt;getDimension();
<a name="line1987">1987: </a>      static double v0[3], J[9], invJ[9], detJ;
<a name="line1988">1988: </a>      mesh-&gt;computeElementGeometry(mesh-&gt;getRealSection(<font color="#666666">"coordinates"</font>), e, v0, J, invJ, detJ);
<a name="line1989">1989: </a>      <font color="#4169E1">if</font> (dim == 2) {
<a name="line1990">1990: </a>        double xi   = invJ[0*dim+0]*(point[0] - v0[0]) + invJ[0*dim+1]*(point[1] - v0[1]);
<a name="line1991">1991: </a>        double eta  = invJ[1*dim+0]*(point[0] - v0[0]) + invJ[1*dim+1]*(point[1] - v0[1]);
<a name="line1992">1992: </a>        //<A href="../../../../docs/manualpages/Sys/PetscPrintf.html#PetscPrintf">PetscPrintf</A>(mesh-&gt;comm(), <font color="#666666">"Location Try: (%d) (%f, %f, %f)\n"</font>, e, xi, eta, xi + eta);
<a name="line1993">1993: </a>        <font color="#4169E1">if</font> ((xi &gt;= -0.000001) &amp;&amp; (eta &gt;= -0.000001) &amp;&amp; (xi + eta &lt;= 2.000001)) {<font color="#4169E1">return</font> true;
<a name="line1994">1994: </a>        } <font color="#4169E1">else</font> <font color="#4169E1">return</font> false;
<a name="line1995">1995: </a>      } <font color="#4169E1">else</font> <font color="#4169E1">if</font> (dim == 3) {
<a name="line1996">1996: </a>        double xi   = invJ[0*dim+0]*(point[0] - v0[0]) + invJ[0*dim+1]*(point[1] - v0[1]) + invJ[0*dim+2]*(point[2] - v0[2]);
<a name="line1997">1997: </a>        double eta  = invJ[1*dim+0]*(point[0] - v0[0]) + invJ[1*dim+1]*(point[1] - v0[1]) + invJ[1*dim+2]*(point[2] - v0[2]);
<a name="line1998">1998: </a>        double zeta = invJ[2*dim+0]*(point[0] - v0[0]) + invJ[2*dim+1]*(point[1] - v0[1]) + invJ[2*dim+2]*(point[2] - v0[2]);

<a name="line2000">2000: </a>        <font color="#4169E1">if</font> ((xi &gt;= -0.00000000001) &amp;&amp; (eta &gt;= -0.00000000001) &amp;&amp; (zeta &gt;= -0.00000000001) &amp;&amp; (xi + eta + zeta &lt;= 2.00000000001)) { <font color="#4169E1">return</font> true;
<a name="line2001">2001: </a>        } <font color="#4169E1">else</font> <font color="#4169E1">return</font> false;
<a name="line2002">2002: </a>      } <font color="#4169E1">else</font> throw ALE::Exception(<font color="#666666">"Location only in 2D or 3D"</font>);
<a name="line2003">2003: </a><font color="#B22222">/*      double coeffs[dim];</font>
<a name="line2004">2004: </a><font color="#B22222">      double sum = 0.;</font>
<a name="line2005">2005: </a><font color="#B22222">      for (int i = 0; i &lt; dim; i++) {</font>
<a name="line2006">2006: </a><font color="#B22222">        coeffs[i] = 0.;</font>
<a name="line2007">2007: </a><font color="#B22222">        for (int j = 0; j &lt; dim; j++) {</font>
<a name="line2008">2008: </a><font color="#B22222">          coeffs[i] += invJ[i*dim+j]*(point[j] - v0[j]);</font>
<a name="line2009">2009: </a><font color="#B22222">        }</font>
<a name="line2010">2010: </a><font color="#B22222">        sum += coeffs[i];</font>
<a name="line2011">2011: </a><font color="#B22222">      }</font>
<a name="line2012">2012: </a><font color="#B22222">      if (sum &gt; 1.) return false;</font>
<a name="line2013">2013: </a><font color="#B22222">      for (int i = 0; i &lt; dim; i++) {</font>
<a name="line2014">2014: </a><font color="#B22222">        if (coeffs[i] &lt; 0.) return false;</font>
<a name="line2015">2015: </a><font color="#B22222">      }</font>
<a name="line2016">2016: </a><font color="#B22222">      return true; */</font>
<a name="line2017">2017: </a>}




</pre>
</body>

</html>
