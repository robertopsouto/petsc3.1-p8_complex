<center><a href="Map.hh">Actual source code: Map.hh</a></center><br>

<html>
<head>
<title></title>
<meta name="generator" content="c2html 0.9.5">
<meta name="date" content="2011-03-17T19:00:29+00:00">
</head>

<body bgcolor="#FFFFFF">
<pre width="80"><a name="line1">  1: </a><font color="#A020F0">#ifndef included_ALE_Map_hh</font>
<a name="line2">  2: </a><strong><font color="#228B22">#define included_ALE_Map_hh</font></strong>

<a name="line4">  4: </a><font color="#A020F0">#ifndef  included_ALE_Sifter_hh</font>
<a name="line5">  5: </a><font color="#A020F0">#include &lt;Sifter.hh&gt;</font>
<a name="line6">  6: </a><font color="#A020F0">#endif</font>


<a name="line9">  9: </a>// Concepts.
<a name="line10"> 10: </a>// -----------
<a name="line11"> 11: </a>// Because of the use of templating and generic programming techniques,
<a name="line12"> 12: </a>// many fundamental ALE types cannot be defined by making progressively specific
<a name="line13"> 13: </a>// class declarations within a given hierarchy. Instead, they must satisfy certain
<a name="line14"> 14: </a>// Concept requirements that make them acceptable inputs to various Algorithms.
<a name="line15"> 15: </a>// This reflects a shortcoming of the current compiler technology that some defining
<a name="line16"> 16: </a>// features of Concepts have to be specified in documentation, rather than within the
<a name="line17"> 17: </a>// language.  Sometimes, however, conceptual types can be viewed as themselves
<a name="line18"> 18: </a>// encapsulating Algorithms acting on other types implementing certain concepts.
<a name="line19"> 19: </a>// This allows to define the structure of these algorithmic types using generic
<a name="line20"> 20: </a>// programming techniques available in C++, <font color="#4169E1">for</font> example.


<a name="line23"> 23: </a>// Atlas &amp; Sec
<a name="line24"> 24: </a>// -----------------------
<a name="line25"> 25: </a>// In the past we have considered the Atlas concept, which, <font color="#4169E1">for</font> the given
<a name="line26"> 26: </a>// Sifter, chart and ind types computed the assignment of indices
<a name="line27"> 27: </a>// to the points in the underlying Sieve (relative to a given chart).
<a name="line28"> 28: </a>// This mimics a system of local coordinate systems on a manifold or some
<a name="line29"> 29: </a>// such space.

<a name="line31"> 31: </a>// Essentially, Atlas can be thought of as a Sifter, with the
<a name="line32"> 32: </a>// underlying Sifter's points (base or cap?) in the cap, charts in the base
<a name="line33"> 33: </a>// and indices being the color on the edges.  However, any type that responds
<a name="line34"> 34: </a>// to the fundamental requests -- setting the number of indices over a point
<a name="line35"> 35: </a>// (fiber dimension), (re)ordering the indices after some dimension modifications
<a name="line36"> 36: </a>// have been made, and retrieving the indices -- is an Atlas.

<a name="line38"> 38: </a>// An object that assigns data of a given type to the (point, chart) pairs of an Atlas
<a name="line39"> 39: </a>// is called its section or Sec.  If an Atlas is viewed as a discrete model of a structure
<a name="line40"> 40: </a>// bundle over the point space, a Sec is a discrete model of a section of that bundle.
<a name="line41"> 41: </a>// Sec is required to define a restrict method, which, given a (point,chart) pair returns
<a name="line42"> 42: </a>// a data iterator.

<a name="line44"> 44: </a>// If the Sifter underling the Atlas is a Sieve, we assume that to each
<a name="line45"> 45: </a>// covering arrow p --&gt; q (within the same chart), corresponds a mapping of the data d(p) &lt;-- d(q),
<a name="line46"> 46: </a>// reflecting the idea that d(q) can be 'restricted' to d(p) within the same chart (or perhaps
<a name="line47"> 47: </a>// in any chart?).  This sort of behavior is certainly impossible to guarantee through
<a name="line48"> 48: </a>// an interface specification, but it remains a conceptual requirement on Sec that
<a name="line49"> 49: </a>// the data over p are somehow <font color="#666666">"included"</font> in the data over q.  This <font color="#666666">"inclusion"</font> is partly specified
<a name="line50"> 50: </a>// in the Atlas (e.g., by ensuring that the indices over p are included in those over q),
<a name="line51"> 51: </a>// and partly in Sec itself.


<a name="line54"> 54: </a>// Map &amp; ParMap concepts.
<a name="line55"> 55: </a>// -----------------------
<a name="line56"> 56: </a>// A Map is thought of as a type of mapping from a Sec class to another Sec class.
<a name="line57"> 57: </a>// Maps and ParMaps can be viewed as algorithmic types acting on the input/output Sec types.
<a name="line58"> 58: </a>// Most importantly, a Map must advertise the Atlases of the input and output Sec
<a name="line59"> 59: </a>// types.  Furthermore, a Map acts essentially as a Sec relative to the output
<a name="line60"> 60: </a>// atlas: giving a fixed input Sec S, a Map extends the Sec interface by defining restrictions
<a name="line61"> 61: </a>// to output  (point,chart) pairs relative to S.  Alternatively, a Map can <font color="#4169E1">return</font> an output Sec T,
<a name="line62"> 62: </a>// containing the result of applying the map to S, which can be queried independently.

<a name="line64"> 64: </a>// With these features of a Map hardly define any implementation structure (rather an interface),
<a name="line65"> 65: </a>// since the particular behavior of restrictions is unconstrained by this specification.
<a name="line66"> 66: </a>// Particular Maps can impose further constraints on the input/output atlases
<a name="line67"> 67: </a>// and expand the interface, so long as they conform to the Map concept outlined above.
<a name="line68"> 68: </a>// For example, we can require that each output chart data depend only on the explicitly specified
<a name="line69"> 69: </a>// input charts' data.  This is done by specifying the 'lightcone' Sifter or a Sieve, connecting
<a name="line70"> 70: </a>// the input charts to the output charts they depend on.  Taking the cone (or the closure, <font color="#4169E1">if</font> it's
<a name="line71"> 71: </a>// a Sieve) of a given output chart in the lightcone returns all of the input charts necessary
<a name="line72"> 72: </a>// to compute the data over the output chart.

<a name="line74"> 74: </a>// The specification of a Map's lightcone is very necessary to enable preallocation of internal
<a name="line75"> 75: </a>// data structures, such as the matrix storage, <font color="#4169E1">for</font> linear maps.  In the distributed context
<a name="line76"> 76: </a>// it also enables the setup of communication structures.  This behavior is encapsulated in
<a name="line77"> 77: </a>// a ParMap, which is itself a conceptual type that extends Map.  ParMap encapsulates (among other things)
<a name="line78"> 78: </a>// three conceptual Map objects: Gather,Scatter and the Transform. A ParMap is then an algorithm that orchestrates
<a name="line79"> 79: </a>// the action of other maps.

<a name="line81"> 81: </a>// ***
<a name="line82"> 82: </a>//   The ParMap algorithm is a most clear illustration of the locazation principle underlying Sieves and computation over
<a name="line83"> 83: </a>// them: restrict-compute-assemble.  To compute the action of a ParMap on a distributed Sec the necessary data must be
<a name="line84"> 84: </a>// communicate to and from the processes requiring and holding the data.  The total overlap of a processes domain with the
<a name="line85"> 85: </a>// rest of the communicator is naturally covered by the individual overlaps indexed by the remote ranks.
<a name="line86"> 86: </a>//   To communicate the local input Sec data to the remote processes, the Sec is first restricted to each of the overlap pieces,
<a name="line87"> 87: </a>// forming another Sec, whose charts are the overlaps indexed by indices, and whose points are the (in_point,in_chart)
<a name="line88"> 88: </a>// pairs on which in the input Sec is defined.  This Sec can be viewed as multisheeted coverings of the overlap porition
<a name="line89"> 89: </a>// of the input Sec, and the multiplexing process forming the new Sec will be called Scatter.  It is a map between two Secs
<a name="line90"> 90: </a>// with the input atlas and the new rank-indexed atlas.
<a name="line91"> 91: </a>//   After Scatter maps the input Sec to a multisheeted covering, the multisheeted data are communicated to the processes according
<a name="line92"> 92: </a>// to the rank in each chart. This can be viewed as a map between two such Secs -- communication is certainly a mapping in
<a name="line93"> 93: </a>// the distributed context -- done 'locally' over each chart.  Thus, the data from the input Sec are first localized onto
<a name="line94"> 94: </a>// each rank-chart, then mapped, and finally must be assembled.
<a name="line95"> 95: </a>//   To obtain a Sec over the local domain, the Scatter process must be reversed, using the a map called Gather.  Gather
<a name="line96"> 96: </a>// takes in the multisheeted covering of the overlap obtained after the communication phase, and obtains a single
<a name="line97"> 97: </a>// (in_point,in_chart) data point from the collection of all such points over all the rank charts.  During this reduction
<a name="line98"> 98: </a>// the overlap portion of the communicated input Sec is unified with the local data over the same (in_point,in_chart) pair,
<a name="line99"> 99: </a>// completing the assembly of the input Sec.
<a name="line100">100: </a>//   Once the input data have been communicate to the consuming processes, Transform locally maps the data from the input
<a name="line101">101: </a>// Sec to the output Sec.  The Gather/Scatter maps involved in the communication stage depend on the GatherAtlas, which
<a name="line102">102: </a>// describes the multisheeted covering of InAtlas.  Gather/Scatter maps can in principle operate on a Sec of any Atlas,
<a name="line103">103: </a>// unifying the data over the same point in different charts, producing a Sec over a single-charted atlas.  Different
<a name="line104">104: </a>// implementations of Gather/Scatter lead to different multiplexing/reduction procedures, <font color="#4169E1">while</font> the atlas structure stays
<a name="line105">105: </a>// the same.  Gather/Scatter maps can be used locally as well and need not act on the result of a communication.
<a name="line106">106: </a>// ***

<a name="line108">108: </a>// The Gather output atlas has the same structure as the ParMap input atlas,
<a name="line109">109: </a>// <font color="#4169E1">while</font> the Gather input atlas  -- GatherAtlas -- combines the ParMap input (point,chart) pairs into
<a name="line110">110: </a>// the source and puts the communicator rank in the target. The Scatter input/output atlases have the
<a name="line111">111: </a>// structure of the output/input atlases of Gather respectively. The Transform atlases have the same
<a name="line112">112: </a>// structure as the ParMap atlases.
<a name="line113">113: </a>//                   (Gather input)                  (Gather output == Transform input)
<a name="line114">114: </a>
<a name="line115">115: </a>//                           index                            index
<a name="line116">116: </a>//             (point,chart) -----&gt; rank     &lt;==&gt;       point -----&gt; chart

<a name="line118">118: </a>//                   (Scatter output)                (Scatter input == Transform input)

<a name="line120">120: </a>// GatherAtlas is constructed from ParMap's input atlas using the lightcone.
<a name="line121">121: </a>// The Gather input/Scatter output atlas essentially applies the idea of a chart recursively:
<a name="line122">122: </a>// Transform input charts are distributed among different processes.  Given a single process, its overlap
<a name="line123">123: </a>// with other processes can be indexed by their remote communicator ranks.  All (point_in,chart_in) pairs shared
<a name="line124">124: </a>// with a given rank are part of a single rank-chart.  This way a single in-chart is <font color="#666666">"blown up"</font>
<a name="line125">125: </a>// into a <font color="#666666">"multisheeted"</font> covering by rank-charts; each (point_in,chart_in) pair becomes a rank-point within
<a name="line126">126: </a>// one or many rank-charts.

<a name="line128">128: </a>// The data over this rank-atlas are essentially the data in the send/receive buffers,
<a name="line129">129: </a>// and the Scatter map is responsible <font color="#4169E1">for</font> (multiplexing) packing and moving the data from the input Sec into the rank-Sec
<a name="line130">130: </a>// encapsulating these buffers. Once this has been done, ParMap executes the communication code (send/recv),
<a name="line131">131: </a>// and the rank-multisheeted data are transfered to the required processes.

<a name="line133">133: </a>//                                     Scatter                                     send/recv
<a name="line134">134: </a>//                                                                    ... rank_0
<a name="line135">135: </a>//              point_in --&gt; chart_in    ==&gt;      (point_in,chart_in) --&gt; rank_k      ==&gt;
<a name="line136">136: </a>//                                                                    ... rank_K

<a name="line138">138: </a>// Then Gather reduces the data over a single (point_in,chart_in) pair in all of the rank-charts.  This can be thought
<a name="line139">139: </a>// of as gluing all of the partial sections over the overlaps with remote processes into a single <font color="#666666">"remote"</font> Sec and then
<a name="line140">140: </a>// gluing it with the <font color="#666666">"local"</font> Sec.  Once the remote data have been assimilated into the local input Sec, Transform does
<a name="line141">141: </a>// its thing.


<a name="line144">144: </a>//                                      rank_0    Gather                        Transform
<a name="line145">145: </a>//                                 ...
<a name="line146">146: </a>//             (point_in,chart_in) --&gt;  rank_n     ==&gt;    point_in --&gt; chart_in    ==&gt;      point_out --&gt; chart_out
<a name="line147">147: </a>//                                 ...
<a name="line148">148: </a>//                                      rank_N

<a name="line150">150: </a>// Observe that the structure of the GatherAtlas is essentially the same as the structure of the
<a name="line151">151: </a>// Overlap Sifter in ParDelta, therefore the Overlap code can be reused.  However, that code is not customizable,
<a name="line152">152: </a>// <font color="#4169E1">while</font> we may want to allow the GatherAtlas  constructor the flexibility to massage the atlas (e.g., to keep only
<a name="line153">153: </a>// s single rank <font color="#4169E1">for</font> a given (point,chart) pair, thereby implementing the 'owner' concept).  Making GatherAtlas a class
<a name="line154">154: </a>// a class will allow this flexibility by exposing the input atlas computation method to overloading.
<a name="line155">155: </a>// The prototypical GatherAtlas object will be implemented to keep all of the ranks in the remote overlap under
<a name="line156">156: </a>// a given (point_in, chart_in) pair.  Custom GatherAtlas objects may prune that so that the number and amount
<a name="line157">157: </a>// of data sent/recv'd by ParMap is only as required.  Here we assume that the overlap is small and computed only once
<a name="line158">158: </a>// or infrequently, <font color="#4169E1">while</font> ParMap mappings are frequent.

<a name="line160">160: </a>


<a name="line163">163: </a>//
<a name="line164">164: </a>// Atlas, Sec and Map classes
<a name="line165">165: </a>//
<a name="line166">166: </a>namespace ALE {
<a name="line167">167: </a>  namespace X {

<a name="line169">169: </a>    // We require that any class implementing the Atlas concept extending Sifter.
<a name="line170">170: </a>    // FIX: should Atlas depend on a Sieve type?  A Sifter type?
<a name="line171">171: </a>    template &lt;typename Ind_, typename Point_, typename Chart_&gt;
<a name="line172">172: </a>    class Atlas : public ASifter&lt;Ind_, Point_, Chart_, SifterDef::multiColor&gt; {
<a name="line173">173: </a><strong><font color="#FF0000">    public:</font></strong>
<a name="line174">174: </a>      //
<a name="line175">175: </a>      // Encapsulated types
<a name="line176">176: </a>      //
<a name="line177">177: </a>      <font color="#4169E1">typedef</font> Point_                                 point_type;
<a name="line178">178: </a>      <font color="#4169E1">typedef</font> Chart_                                 chart_type;
<a name="line179">179: </a>      <font color="#4169E1">typedef</font> Ind_                                   ind_type;
<a name="line180">180: </a>      <font color="#4169E1">typedef</font> ALE::pair&lt;ind_type, ind_type&gt;          index_type;
<a name="line181">181: </a>      //
<a name="line182">182: </a>      <font color="#4169E1">typedef</font> ASifter&lt;index_type, point_type, chart_type, SifterDef::multiColor&gt; sifter_type;
<a name="line183">183: </a><strong><font color="#FF0000">    public:</font></strong>
<a name="line184">184: </a>      //
<a name="line185">185: </a>      // Basic interface
<a name="line186">186: </a>      //
<a name="line187">187: </a>      Atlas(<A href="../../../../docs/manualpages/Sys/MPI_Comm.html#MPI_Comm">MPI_Comm</A> comm = <A href="../../../../docs/manualpages/Sys/PETSC_COMM_SELF.html#PETSC_COMM_SELF">PETSC_COMM_SELF</A>, const int&amp; debug = 0) : sifter_type(comm, debug) {};
<a name="line188">188: </a>      virtual ~Atlas(){};
<a name="line189">189: </a>      //
<a name="line190">190: </a>      // Extended interface
<a name="line191">191: </a>      //
<a name="line192">192: </a>      ind_type size(){
<a name="line193">193: </a>        ind_type sz = 0;
<a name="line194">194: </a>        // Here we simply look at each chart's cone and add up the sizes
<a name="line195">195: </a>        // In fact, we assume that within a chart indices are contiguous,
<a name="line196">196: </a>        // so we simply add up the offset to the size of the last point of each chart's cone and sum them up.
<a name="line197">197: </a>        baseSequence base = this-&gt;base();
<a name="line198">198: </a>        <font color="#4169E1">for</font>(typename baseSequence::iterator bitor = base-&gt;begin(); bitor != base-&gt;end(); bitor++) {
<a name="line199">199: </a>          index_type ii = this-&gt;cone(*bitor)-&gt;rbegin()-&gt;color();
<a name="line200">200: </a>          sz += ii.first + ii.second;
<a name="line201">201: </a>        }
<a name="line202">202: </a>        <font color="#4169E1">return</font> sz;
<a name="line203">203: </a>      };
<a name="line204">204: </a>      ind_type size(const chart_type&amp; c) {
<a name="line205">205: </a>        // Here we simply look at the chart's cone and add up the sizes.
<a name="line206">206: </a>        // In fact, we assume that within a chart indices are contiguous,
<a name="line207">207: </a>        // so we simply <font color="#4169E1">return</font> the sum of the offset to the size of the chart's last point.
<a name="line208">208: </a>        index_type ii = this-&gt;cone(c).rbegin()-&gt;color();
<a name="line209">209: </a>        ind_type sz = ii.first + ii.second;
<a name="line210">210: </a>        <font color="#4169E1">return</font> sz;
<a name="line211">211: </a>      };
<a name="line212">212: </a>      ind_type size(const chart_type&amp; c, const point_type&amp; p) {
<a name="line213">213: </a>        // Here we assume that at most a single arrow between p and c exists
<a name="line214">214: </a>        arrowSequence arrows = this-&gt;arrows(p,c);
<a name="line215">215: </a>        ind_type sz = 0;
<a name="line216">216: </a>        <font color="#4169E1">if</font>(arrows.begin() != arrows.end()) {
<a name="line217">217: </a>          sz = arrows.begin()-&gt;first;
<a name="line218">218: </a>        }
<a name="line219">219: </a>        <font color="#4169E1">return</font> sz;
<a name="line220">220: </a>      };
<a name="line221">221: </a>
<a name="line222">222: </a>      ind_type offset(const chart_type&amp; c) {
<a name="line223">223: </a>        // We assume that within a chart indices are contiguous, so the offset of the chart
<a name="line224">224: </a>        // is the offset of the first element in its cone.
<a name="line225">225: </a>        ind_type off = this-&gt;cone(c).begin()-&gt;color().first;
<a name="line226">226: </a>        <font color="#4169E1">return</font> off;
<a name="line227">227: </a>      };
<a name="line228">228: </a>      ind_type offset(const chart_type&amp; c, const point_type&amp; p) {
<a name="line229">229: </a>        // Here we assume that at most a single arrow between p and c exists
<a name="line230">230: </a>        arrowSequence arrows = this-&gt;arrows(p,c);
<a name="line231">231: </a>        // CONTINUE: what's the offset in <font color="#4169E1">case</font> p is not in c
<a name="line232">232: </a>        ind_type sz = 0;
<a name="line233">233: </a>        <font color="#4169E1">if</font>(arrows.begin() != arrows.end()) {
<a name="line234">234: </a>          sz = arrows.begin()-&gt;first;
<a name="line235">235: </a>        }
<a name="line236">236: </a>        <font color="#4169E1">return</font> sz;
<a name="line237">237: </a>      };
<a name="line238">238: </a>
<a name="line239">239: </a>    };// class Atlas

<a name="line241">241: </a>

<a name="line243">243: </a>    // FIX: should Sec depend on a Sieve?  Perhaps Atlas should encapsulate a Sieve type?
<a name="line244">244: </a>    template &lt;typename Data_, typename Atlas_&gt;
<a name="line245">245: </a>    class Sec {
<a name="line246">246: </a><strong><font color="#FF0000">    public:</font></strong>
<a name="line247">247: </a>      //
<a name="line248">248: </a>      // Encapsulated types
<a name="line249">249: </a>      //
<a name="line250">250: </a>      <font color="#4169E1">typedef</font> Atlas_                           atlas_type;
<a name="line251">251: </a>      <font color="#4169E1">typedef</font> Data_                            data_type;
<a name="line252">252: </a>      <font color="#4169E1">typedef</font> typename atlas_type::point_type  point_type;
<a name="line253">253: </a>      <font color="#4169E1">typedef</font> typename atlas_type::chart_type  chart_type;
<a name="line254">254: </a>      <font color="#4169E1">typedef</font> typename atlas_type::index_type  index_type;
<a name="line255">255: </a>      //
<a name="line256">256: </a>      // Perhaps the most important incapsulated type: sequence of data elements over a sequence of AtlasArrows.
<a name="line257">257: </a>      // of the sequence.
<a name="line258">258: </a>      template &lt;typename AtlasArrowSequence_&gt;
<a name="line259">259: </a>      class DataSequence {
<a name="line260">260: </a>      // The AtlasArrowSequence_ encodes the arrows over a chart or a chart-point pair.
<a name="line261">261: </a>      // The crucial assumption is that the begin() and rbegin() of the AtlasArrowSequence_ contain the extremal indices
<a name="line262">262: </a><strong><font color="#FF0000">      public:</font></strong>
<a name="line263">263: </a>        //
<a name="line264">264: </a>        // Encapsulated types
<a name="line265">265: </a>        //
<a name="line266">266: </a>        <font color="#4169E1">typedef</font> AtlasArrowSequence_ atlas_arrow_sequence_type;
<a name="line267">267: </a>        //
<a name="line268">268: </a>        // Encapsulated iterators
<a name="line269">269: </a>        class iterator {
<a name="line270">270: </a><strong><font color="#FF0000">        public:</font></strong>
<a name="line271">271: </a>          <font color="#4169E1">typedef</font> std::input_iterator_tag     iterator_category;
<a name="line272">272: </a>          <font color="#4169E1">typedef</font> data_type                   value_type;
<a name="line273">273: </a>          <font color="#4169E1">typedef</font> int                         difference_type;
<a name="line274">274: </a>          <font color="#4169E1">typedef</font> value_type*                 pointer;
<a name="line275">275: </a>          <font color="#4169E1">typedef</font> value_type&amp;                 reference;
<a name="line276">276: </a><strong><font color="#FF0000">        protected:</font></strong>
<a name="line277">277: </a>          // Encapsulates a data_type pointer
<a name="line278">278: </a>          data_type* _ptr;
<a name="line279">279: </a><strong><font color="#FF0000">        public:</font></strong>
<a name="line280">280: </a>          iterator(const iterator&amp; iter) : _ptr(iter._ptr) {};
<a name="line281">281: </a>          iterator(data_type* ptr)       : _ptr(ptr) {};
<a name="line282">282: </a>          data_type&amp;         operator*(){<font color="#4169E1">return</font> *(this-&gt;_ptr);};
<a name="line283">283: </a>          virtual iterator   operator++() {++this-&gt;_ptr; <font color="#4169E1">return</font> *this;};
<a name="line284">284: </a>          virtual iterator   operator++(int n) {iterator tmp(this-&gt;_ptr); ++this-&gt;_ptr; <font color="#4169E1">return</font> tmp;};
<a name="line285">285: </a>          virtual bool       operator==(const iterator&amp; iter) const {<font color="#4169E1">return</font> this-&gt;_ptr == iter._ptr;};
<a name="line286">286: </a>          virtual bool       operator!=(const iterator&amp; iter) const {<font color="#4169E1">return</font> this-&gt;_ptr != iter._ptr;};
<a name="line287">287: </a>        };
<a name="line288">288: </a>        //
<a name="line289">289: </a>        class reverse_iterator {
<a name="line290">290: </a><strong><font color="#FF0000">        public:</font></strong>
<a name="line291">291: </a>          <font color="#4169E1">typedef</font> std::input_iterator_tag     iterator_category;
<a name="line292">292: </a>          <font color="#4169E1">typedef</font> data_type                   value_type;
<a name="line293">293: </a>          <font color="#4169E1">typedef</font> int                         difference_type;
<a name="line294">294: </a>          <font color="#4169E1">typedef</font> value_type*                 pointer;
<a name="line295">295: </a>          <font color="#4169E1">typedef</font> value_type&amp;                 reference;
<a name="line296">296: </a><strong><font color="#FF0000">        protected:</font></strong>
<a name="line297">297: </a>          // Encapsulates a data_type pointer
<a name="line298">298: </a>          data_type* _ptr;
<a name="line299">299: </a><strong><font color="#FF0000">        public:</font></strong>
<a name="line300">300: </a>          reverse_iterator(const reverse_iterator&amp; iter) : _ptr(iter._ptr) {};
<a name="line301">301: </a>          reverse_iterator(data_type* ptr)       : _ptr(ptr) {};
<a name="line302">302: </a>          data_type&amp;                operator*(){<font color="#4169E1">return</font> *(this-&gt;_ptr);};
<a name="line303">303: </a>          virtual reverse_iterator  operator++() {--this-&gt;_ptr; <font color="#4169E1">return</font> *this;};
<a name="line304">304: </a>          virtual reverse_iterator  operator++(int n) {reverse_iterator tmp(this-&gt;_ptr); --this-&gt;_ptr; <font color="#4169E1">return</font> tmp;};
<a name="line305">305: </a>          virtual bool              operator==(const reverse_iterator&amp; iter) const {<font color="#4169E1">return</font> this-&gt;_ptr == iter._ptr;};
<a name="line306">306: </a>          virtual bool              operator!=(const reverse_iterator&amp; iter) const {<font color="#4169E1">return</font> this-&gt;_ptr != iter._ptr;};
<a name="line307">307: </a>        };
<a name="line308">308: </a><strong><font color="#FF0000">      protected:</font></strong>
<a name="line309">309: </a>        const atlas_arrow_sequence_type&amp; _arrows;
<a name="line310">310: </a>        data_type *_base_ptr;
<a name="line311">311: </a>        index      _size;
<a name="line312">312: </a><strong><font color="#FF0000">      public:</font></strong>
<a name="line313">313: </a>        //
<a name="line314">314: </a>        // Basic interface
<a name="line315">315: </a>        DataSequence(data_type *arr, const atlas_arrow_sequence_type&amp; arrows) : _arrows(arrows) {
<a name="line316">316: </a>          // We immediately calculate the base pointer into the array and the size of the data sequence.
<a name="line317">317: </a>          // To compute the index of the base pointer look at the beginning of the _arrows sequence.
<a name="line318">318: </a>          this-&gt;_base_ptr = arr + this-&gt;_arrows-&gt;begin()-&gt;color().first;
<a name="line319">319: </a>          // To compute the total size of the array segement, we look at the end of the _arrows sequence.
<a name="line320">320: </a><strong><font color="#FF0000">          ALE:</font></strong>:pair&lt;index_type, index_type&gt; ii = this-&gt;_arrows-&gt;rbegin()-&gt;color();
<a name="line321">321: </a>          this-&gt;_size = ii.first + ii.second;
<a name="line322">322: </a>        };
<a name="line323">323: </a>       ~DataSequence(){};
<a name="line324">324: </a>        //
<a name="line325">325: </a>        // Extended interface
<a name="line326">326: </a>        index_type size() {<font color="#4169E1">return</font> this-&gt;_size;};
<a name="line327">327: </a>        iterator begin()  {<font color="#4169E1">return</font> iterator(this-&gt;_base_ptr);};
<a name="line328">328: </a>        iterator end()    {<font color="#4169E1">return</font> iterator(this-&gt;_base_ptr+this-&gt;_size+1);};
<a name="line329">329: </a>        iterator rbegin() {<font color="#4169E1">return</font> reverse_iterator(this-&gt;_base_ptr+this-&gt;_size);};
<a name="line330">330: </a>        iterator rend()   {<font color="#4169E1">return</font> reverse_iterator(this-&gt;_base_ptr-1);};
<a name="line331">331: </a>      }; // class Sec::DataSequence
<a name="line332">332: </a><strong><font color="#FF0000">    protected:</font></strong>
<a name="line333">333: </a>      Obj&lt;atlas_type&gt; _atlas;
<a name="line334">334: </a>      data_type*      _data;
<a name="line335">335: </a>      bool            _allocated;
<a name="line336">336: </a><strong><font color="#FF0000">    public:</font></strong>
<a name="line337">337: </a>      //
<a name="line338">338: </a>      // Basic interface
<a name="line339">339: </a>      //
<a name="line340">340: </a>      Sec(const Obj&lt;atlas_type&gt; atlas, const (data_type*)&amp; data) {this-&gt;setAtlas(atlas, false); this-&gt;_data = data;};
<a name="line341">341: </a>      Sec(const Obj&lt;atlas_type&gt; atlas = Obj&lt;atlas_type&gt;()) {this-&gt;_data = NULL; this-&gt;setAtlas(atlas);};
<a name="line342">342: </a>     ~Sec(){<font color="#4169E1">if</font>((this-&gt;_data != NULL)&amp;&amp;(this-&gt;_allocated)) {<A href="../../../../docs/manualpages/Sys/PetscFree.html#PetscFree">PetscFree</A>(this-&gt;_data);CHKERROR(ierr, <font color="#666666">"Error in <A href="../../../../docs/manualpages/Sys/PetscFree.html#PetscFree">PetscFree</A>"</font>);}};
<a name="line343">343: </a>      //
<a name="line344">344: </a>      // Extended interface
<a name="line345">345: </a>      //
<a name="line346">346: </a>      void setAtlas(const Obj&lt;atlas_type&gt;&amp; atlas, bool allocate = true) {
<a name="line347">347: </a>        <font color="#4169E1">if</font>(!this-&gt;_atlas.isNull()) {
<a name="line348">348: </a>          throw ALE::Exception(<font color="#666666">"Cannot reset nonempty atlas"</font>);
<a name="line349">349: </a>        }
<a name="line350">350: </a>        <font color="#4169E1">else</font> {
<a name="line351">351: </a>          <font color="#4169E1">if</font>(atlas.isNull()) {
<a name="line352">352: </a>            throw ALE::Exception(<font color="#666666">"Cannot set a nonempty atlas"</font>);
<a name="line353">353: </a>          }
<a name="line354">354: </a>          <font color="#4169E1">else</font> {
<a name="line355">355: </a>            this-&gt;_atlas = atlas;
<a name="line356">356: </a>            this-&gt;_allocated = allocate;
<a name="line357">357: </a>            <font color="#4169E1">if</font>(allocate) {
<a name="line358">358: </a>              // Allocate data
<a name="line359">359: </a>              <A href="../../../../docs/manualpages/Sys/PetscMalloc.html#PetscMalloc">PetscMalloc</A>(this-&gt;_atlas-&gt;size()*<font color="#4169E1">sizeof</font>(data_type), &amp;this-&gt;_data);CHKERROR(ierr, <font color="#666666">"Error in <A href="../../../../docs/manualpages/Sys/PetscMalloc.html#PetscMalloc">PetscMalloc</A>"</font>);
<a name="line360">360: </a>            }
<a name="line361">361: </a>          }
<a name="line362">362: </a>        }
<a name="line363">363: </a>      };// setAtlas()
<a name="line364">364: </a>      Obj&lt;atlas_type&gt; getAtlas() {<font color="#4169E1">return</font> this-&gt;_atlas;};
<a name="line365">365: </a>      Obj&lt;atlas_type&gt; atlas()    {<font color="#4169E1">return</font> getAtlas();};
<a name="line366">366: </a>      //
<a name="line367">367: </a>      DataSequence&lt;typename atlas_type::coneSequence&gt;
<a name="line368">368: </a>      restrict(const chart_type&amp; chart) {
<a name="line369">369: </a>        <font color="#4169E1">return</font> DataSequence&lt;typename atlas_type::coneSequence&gt;(this-&gt;_data, this-&gt;_atlas-&gt;cone(chart));
<a name="line370">370: </a>      };
<a name="line371">371: </a>      DataSequence&lt;typename atlas_type::arrowSequence&gt;
<a name="line372">372: </a>      restrict(const chart_type&amp; chart, const point_type&amp; point) {
<a name="line373">373: </a>        <font color="#4169E1">return</font> DataSequence&lt;typename atlas_type::coneSequence&gt;(this-&gt;_data, this-&gt;_atlas-&gt;arrows(point, chart));
<a name="line374">374: </a>      };
<a name="line375">375: </a>    };// class Sec


<a name="line378">378: </a>    template &lt;typename Data_, typename Atlas_&gt;
<a name="line379">379: </a>    class ArraySec : public Sec&lt;Data_, Atlas_&gt; {
<a name="line380">380: </a><strong><font color="#FF0000">    public:</font></strong>
<a name="line381">381: </a>      //
<a name="line382">382: </a>      // Encapsulated types
<a name="line383">383: </a>      //
<a name="line384">384: </a>      <font color="#4169E1">typedef</font> Sec&lt;Data_,Atlas_&gt;                sec_type;
<a name="line385">385: </a>      <font color="#4169E1">typedef</font> Atlas_                           atlas_type;
<a name="line386">386: </a>      <font color="#4169E1">typedef</font> Data_                            data_type;
<a name="line387">387: </a>      <font color="#4169E1">typedef</font> typename atlas_type::point_type  point_type;
<a name="line388">388: </a>      <font color="#4169E1">typedef</font> typename atlas_type::chart_type  chart_type;
<a name="line389">389: </a>      <font color="#4169E1">typedef</font> typename atlas_type::index_type  index_type;
<a name="line390">390: </a>      //
<a name="line391">391: </a>      // Basic interface
<a name="line392">392: </a>      //
<a name="line393">393: </a>      ArraySec(const Obj&lt;atlas_type&gt; atlas, const (data_type*)&amp; data) {this-&gt;setAtlas(atlas, false); this-&gt;_data = data;};
<a name="line394">394: </a>      ArraySec(const Obj&lt;atlas_type&gt; atlas = Obj&lt;atlas_type&gt;()) {this-&gt;_data = NULL; this-&gt;setAtlas(atlas);};
<a name="line395">395: </a>     ~ArraySec(){<font color="#4169E1">if</font>((this-&gt;_data != NULL)&amp;&amp;(this-&gt;_allocated)) {<A href="../../../../docs/manualpages/Sys/PetscFree.html#PetscFree">PetscFree</A>(this-&gt;_data);CHKERROR(ierr, <font color="#666666">"Error in <A href="../../../../docs/manualpages/Sys/PetscFree.html#PetscFree">PetscFree</A>"</font>);}};
<a name="line396">396: </a>      //
<a name="line397">397: </a>      // Extended interface
<a name="line398">398: </a>      //
<a name="line399">399: </a>      data_type*
<a name="line400">400: </a>      restrict(const chart_type&amp; chart) {
<a name="line401">401: </a>        <font color="#4169E1">return</font> this-&gt;_data + this-&gt;_atlas-&gt;offset(chart);
<a name="line402">402: </a>      };
<a name="line403">403: </a>      data_type*
<a name="line404">404: </a>      restrict(const chart_type&amp; chart, const point_type&amp; point) {
<a name="line405">405: </a>        <font color="#4169E1">return</font> this-&gt;_data + this-&gt;_atlas-&gt;offset(chart,point);
<a name="line406">406: </a>      };
<a name="line407">407: </a>    }; // class ArraySec


<a name="line410">410: </a>    // Overlap is a container class that declares GatherAtlas and ScatterAtlas types as well as
<a name="line411">411: </a>    // defines their construction procedures.
<a name="line412">412: </a>    // InAtlas_ and OutAtlas_ are Atlases, Lightcone_ is a Sifter.
<a name="line413">413: </a>    // Lightcone connects the charts of some ParMap's OutAtlas_ to the ParMap's InAtlas_.
<a name="line414">414: </a>    // GatherAtlas and ScatterAtlas have (point_in,chart_in) pairs as points and process ranks as charts.
<a name="line415">415: </a>    // Preconditions: InAtlas, Lightcone, and OutAtlas share communicator; we require that chart type be Point
<a name="line416">416: </a>    // FIX: should GatherAtlas/ScatterAtlas depend on an underlying Topology Sieve?
<a name="line417">417: </a>    template &lt;typename Data_, typename InAtlas_, typename OutAtlas_, typename Lightcone_&gt;
<a name="line418">418: </a>    class Overlap {
<a name="line419">419: </a><strong><font color="#FF0000">    public:</font></strong>
<a name="line420">420: </a>      // encapsulated types
<a name="line421">421: </a>      <font color="#4169E1">typedef</font> Data_                                                 data_type;
<a name="line422">422: </a>      <font color="#4169E1">typedef</font> InAtlas_                                              in_atlas_type;
<a name="line423">423: </a>      <font color="#4169E1">typedef</font> Lightcone_                                            lightcone_type;
<a name="line424">424: </a>      <font color="#4169E1">typedef</font> OutAtlas_                                             out_atlas_type;
<a name="line425">425: </a>      <font color="#4169E1">typedef</font> MPI_Int                                               chart_type;
<a name="line426">426: </a>      <font color="#4169E1">typedef</font> ALE::pair&lt;in_atlas_type::point_type, chart_type&gt;      point_type;
<a name="line427">427: </a>      <font color="#4169E1">typedef</font> typename in_atlas_type::ind_type                      ind_type;
<a name="line428">428: </a>      <font color="#4169E1">typedef</font> typename in_atlas_type::index_type                    index_type;
<a name="line429">429: </a>      //
<a name="line430">430: </a>      <font color="#4169E1">typedef</font> typename Atlas&lt;point_type, chart_type, ind_type&gt;      gather_scatter_atlas_type;
<a name="line431">431: </a><strong><font color="#FF0000">    protected:</font></strong>
<a name="line432">432: </a>      Obj&lt;in_atlas_type&gt;             _in_atlas;
<a name="line433">433: </a>      Obj&lt;out_atlas_type&gt;            _out_atlas;
<a name="line434">434: </a>      Obj&lt;lightcone_type&gt;            _lightcone;
<a name="line435">435: </a>      //
<a name="line436">436: </a>      Obj&lt;gather_scatter_atlas_type&gt; _gather_atlas;
<a name="line437">437: </a>      Obj&lt;gather_scatter_atlas_type&gt; _scatter_atlas;
<a name="line438">438: </a><strong><font color="#FF0000">    public:</font></strong>
<a name="line439">439: </a>      //
<a name="line440">440: </a>      Overlap(const Obj&lt;in_atlas_type&gt;&amp; in_atlas,const Obj&lt;out_atlas_type&gt;&amp; out_atlas, const Obj&lt;lightcone_type&gt;&amp; lightcone = Obj&lt;lightcone_type&gt;()) : atlas_type(in_atlas-&gt;comm()), _in_atlas(in_atlas),_out_atlas(out_atlas),_lightcone(lightcone) {
<a name="line441">441: </a>        this-&gt;computeAtlases(this-&gt;_gather_atlas, this-&gt;_scatter_atlas);
<a name="line442">442: </a>      };
<a name="line443">443: </a>     ~Overlap(){};
<a name="line444">444: </a>      //
<a name="line445">445: </a>      // Extended interface
<a name="line446">446: </a>      Obj&lt;in_atlas_type&gt;  inAtlas()  {<font color="#4169E1">return</font> this-&gt;_in_atlas();};
<a name="line447">447: </a>      Obj&lt;out_atlas_type&gt; outAtlas() {<font color="#4169E1">return</font> this-&gt;_out_atlas();};
<a name="line448">448: </a>      Obj&lt;lightcone_type&gt; lightcone(){<font color="#4169E1">return</font> this-&gt;_lightcone();}
<a name="line449">449: </a>      //
<a name="line450">450: </a>      void computeAtlases(Obj&lt;gather_atlas_type&gt; gather_atlas, Obj&lt;scatter_atlas_type&gt; scatter_atlas) {
<a name="line451">451: </a>        // This function computes the gather and scatter atlases necessary <font color="#4169E1">for</font> exchanging and fusing the input data lying over the
<a name="line452">452: </a>        // overlap with the remote processes into the local data over the overlap points.
<a name="line453">453: </a>        // The Lightcone sifter encodes the dependence between input and output charts of some map: each out-chart in the base
<a name="line454">454: </a>        // of the Lightcone depends on the in-chart in its Lightcone cone (depends <font color="#4169E1">for</font> the computation of the map values).
<a name="line455">455: </a>        // A Null Lightcone Obj is interpreted as an identity Lightcone, hence the <font color="#4169E1">if</font>-<font color="#4169E1">else</font> dichotomy in the code below.
<a name="line456">456: </a>        //

<a name="line458">458: </a>        // In order to retrieve the remote points that OutAtlas depends on, we compute the overlap of the local bases of InAtlas
<a name="line459">459: </a>        // restricted to a suitable subset of Lightcone's cap.  The idea is that at most the charts the in the cap of the Lightcone
<a name="line460">460: </a>        // are required locally by the OutAtlas.
<a name="line461">461: </a>        // Furthermore, at most the cone of OutAtlas' base in Lightcone is required, which is the set we use to compute the overlap.
<a name="line462">462: </a>        // If the Lightcone Obj is Null, we take all of the OutAtlas base as the base of the overlap in InAtlas.
<a name="line463">463: </a>        //
<a name="line464">464: </a>        <font color="#4169E1">if</font>(gather_atlas.isNull()) {
<a name="line465">465: </a>          gather_atlas  = gather_atlas_type(this-&gt;_in_atlas-&gt;comm());
<a name="line466">466: </a>        }
<a name="line467">467: </a>        <font color="#4169E1">if</font>(scatter_atlas.isNull()){
<a name="line468">468: </a>          scatter_atlas = scatter_atlas_type(this-&gt;_in_atlas-&gt;comm());
<a name="line469">469: </a>        }
<a name="line470">470: </a>        //
<a name="line471">471: </a>        <font color="#4169E1">if</font>(!lightcone.isNull()) {
<a name="line472">472: </a>          // Take all of out-charts &amp; compute their lightcone closure; this will give all of the in-charts required locally
<a name="line473">473: </a>          typename out_atlas_type::capSequence out_base = this-&gt;_out_atlas-&gt;base();
<a name="line474">474: </a>          typename lightcone_type::coneSet in_charts = this-&gt;_lightcone-&gt;closure(out_base);
<a name="line475">475: </a>          // Now we compute the <font color="#666666">"overlap"</font> of in_atlas with these local in-charts; this will be the gather atlas
<a name="line476">476: </a>          this-&gt;__pullbackAtlases(in_charts, gather_atlas, scatter_atlas);

<a name="line478">478: </a>        }// <font color="#4169E1">if</font>(!lightcone.isNull())
<a name="line479">479: </a>        <font color="#4169E1">else</font> {
<a name="line480">480: </a>          // FIX: handle the Null lightcone <font color="#4169E1">case</font>
<a name="line481">481: </a>        }
<a name="line482">482: </a>      };// computeAtlases()

<a name="line484">484: </a><strong><font color="#FF0000">    protected:</font></strong>
<a name="line485">485: </a>      // Internal type definitions to ensure compatibility with the legacy code in the parallel subroutines
<a name="line486">486: </a>      <font color="#4169E1">typedef</font> ALE::Point                                Point;
<a name="line487">487: </a>      <font color="#4169E1">typedef</font> int                                            int32_t;
<a name="line488">488: </a>      <font color="#4169E1">typedef</font> ALE::pair&lt;int32_t, int32_t&gt;                    int_pair;
<a name="line489">489: </a>      <font color="#4169E1">typedef</font> ALE::set&lt;std::pair&lt;int32_t, int32_t&gt; &gt;         int_pair_set;
<a name="line490">490: </a>      <font color="#4169E1">typedef</font> ALE::map&lt;int32_t,int32_t&gt;                      int__int;
<a name="line491">491: </a>      <font color="#4169E1">typedef</font> ALE::map&lt;Point, int32_t&gt;                       Point__int;
<a name="line492">492: </a>      <font color="#4169E1">typedef</font> ALE::map&lt;Point, std::pair&lt;int32_t,int32_t&gt; &gt;   Point__int_int;
<a name="line493">493: </a>      <font color="#4169E1">typedef</font> ALE::map&lt;Point, int_pair_set&gt;                  Point__int_pair_set;

<a name="line495">495: </a>      template &lt;typename Sequence&gt;
<a name="line496">496: </a>      svoid __determinePointOwners(const Obj&lt;Sequence&gt;&amp; points, int32_t *LeaseData, Point__int&amp; owner) {
<a name="line498">498: </a>        // The Sequence points will be referred to as 'base' throughout, although it may in fact represent a cap.
<a name="line499">499: </a>        <A href="../../../../docs/manualpages/Sys/MPI_Comm.html#MPI_Comm">MPI_Comm</A> comm = this-&gt;comm();
<a name="line500">500: </a>        MPI_Int  rank = this-&gt;commRank();
<a name="line501">501: </a>        MPI_Int  size = this-&gt;commSize();

<a name="line503">503: </a>        // We need to partition global nodes among lessors, which we <font color="#4169E1">do</font> by global prefix
<a name="line504">504: </a>        // First we determine the extent of global prefices and the bounds on the indices with each global prefix.
<a name="line505">505: </a>        int minGlobalPrefix = 0;
<a name="line506">506: </a>        // Determine the local extent of global domains
<a name="line507">507: </a>        <font color="#4169E1">for</font>(typename Sequence::iterator point_itor = points-&gt;begin(); point_itor != points-&gt;end(); point_itor++) {
<a name="line508">508: </a>          Point p = (*point_itor);
<a name="line509">509: </a>          <font color="#4169E1">if</font>((p.prefix &lt; 0) &amp;&amp; (p.prefix &lt; minGlobalPrefix)) {
<a name="line510">510: </a>            minGlobalPrefix = p.prefix;
<a name="line511">511: </a>          }
<a name="line512">512: </a>        }
<a name="line513">513: </a>        int MinGlobalPrefix;
<a name="line514">514: </a>        <A href="http://www.mcs.anl.gov/mpi/www/www3/MPI_Allreduce.html#MPI_Allreduce">MPI_Allreduce</A>(&amp;minGlobalPrefix, &amp;MinGlobalPrefix, 1, MPIU_INT, MPI_MIN, comm);
<a name="line515">515: </a>        CHKERROR(ierr, <font color="#666666">"Error in <A href="http://www.mcs.anl.gov/mpi/www/www3/MPI_Allreduce.html#MPI_Allreduce">MPI_Allreduce</A>"</font>);
<a name="line516">516: </a>
<a name="line517">517: </a>        int__int BaseLowerBound, BaseUpperBound; // global quantities computed from the local quantities below
<a name="line518">518: </a>        int__int BaseMaxSize;                    // the maximum size of the global base index space by global prefix
<a name="line519">519: </a>        int__int BaseSliceScale, BaseSliceSize, BaseSliceOffset;
<a name="line520">520: </a>
<a name="line521">521: </a>        <font color="#4169E1">if</font>(MinGlobalPrefix &lt; 0) { // <font color="#4169E1">if</font> we actually <font color="#4169E1">do</font> have global base points
<a name="line522">522: </a>          // Determine the upper and lower bounds on the indices of base points with each global prefix.
<a name="line523">523: </a>          // We use maps to keep track of these quantities with different global prefices.
<a name="line524">524: </a>          int__int baseLowerBound, baseUpperBound; // local quantities
<a name="line525">525: </a>          // Initialize local bound maps with the upper below lower so we can later recognize omitted prefices.
<a name="line526">526: </a>          <font color="#4169E1">for</font>(int d = -1; d &gt;= MinGlobalPrefix; d--) {
<a name="line527">527: </a>            baseLowerBound[d] = 0; baseUpperBound[d] = -1;
<a name="line528">528: </a>          }
<a name="line529">529: </a>          // Compute local bounds
<a name="line530">530: </a>          <font color="#4169E1">for</font>(typename Sequence::iterator point_itor = points-&gt;begin(); point_itor != points-&gt;end(); point_itor++) {
<a name="line531">531: </a>            Point p = (*point_itor);
<a name="line532">532: </a>            int d = p.prefix;
<a name="line533">533: </a>            int i = p.index;
<a name="line534">534: </a>            <font color="#4169E1">if</font>(d &lt; 0) { // it is indeed a global prefix
<a name="line535">535: </a>              <font color="#4169E1">if</font> (i &lt; baseLowerBound[d]) {
<a name="line536">536: </a>                baseLowerBound[d] = i;
<a name="line537">537: </a>              }
<a name="line538">538: </a>              <font color="#4169E1">if</font> (i &gt; baseUpperBound[d]) {
<a name="line539">539: </a>                baseUpperBound[d] = i;
<a name="line540">540: </a>              }
<a name="line541">541: </a>            }
<a name="line542">542: </a>          }
<a name="line543">543: </a>          // Compute global bounds
<a name="line544">544: </a>          <font color="#4169E1">for</font>(int d = -1; d &gt;= MinGlobalPrefix; d--){
<a name="line545">545: </a>            int lowerBound, upperBound, maxSize;
<a name="line546">546: </a>            <A href="http://www.mcs.anl.gov/mpi/www/www3/MPI_Allreduce.html#MPI_Allreduce">MPI_Allreduce</A>(&amp;baseLowerBound[d],&amp;lowerBound,1,MPIU_INT,MPI_MIN,comm);
<a name="line547">547: </a>            CHKERROR(ierr, <font color="#666666">"Error in <A href="http://www.mcs.anl.gov/mpi/www/www3/MPI_Allreduce.html#MPI_Allreduce">MPI_Allreduce</A>"</font>);
<a name="line548">548: </a>            <A href="http://www.mcs.anl.gov/mpi/www/www3/MPI_Allreduce.html#MPI_Allreduce">MPI_Allreduce</A>(&amp;baseUpperBound[d],&amp;upperBound,1,MPIU_INT,MPI_MAX,comm);
<a name="line549">549: </a>            CHKERROR(ierr, <font color="#666666">"Error in <A href="http://www.mcs.anl.gov/mpi/www/www3/MPI_Allreduce.html#MPI_Allreduce">MPI_Allreduce</A>"</font>);
<a name="line550">550: </a>            maxSize = upperBound - lowerBound + 1;
<a name="line551">551: </a>            <font color="#4169E1">if</font>(maxSize &gt; 0) { // there are actually some indices in this global prefix
<a name="line552">552: </a>              BaseLowerBound[d] = lowerBound;
<a name="line553">553: </a>              BaseUpperBound[d] = upperBound;
<a name="line554">554: </a>              BaseMaxSize[d]    = maxSize;
<a name="line555">555: </a>
<a name="line556">556: </a>              // Each processor (at least potentially) owns a slice of the base indices with each global indices.
<a name="line557">557: </a>              // The size of the slice with global prefix d is BaseMaxSize[d]/size + 1 (except <font color="#4169E1">if</font> rank == size-1,
<a name="line558">558: </a>              // where the slice size can be smaller; +1 is <font color="#4169E1">for</font> safety).
<a name="line559">559: </a>
<a name="line560">560: </a>              // For a non-empty domain d we compute and store the slice size in BaseSliceScale[d] (the 'typical' slice size) and
<a name="line561">561: </a>              // BaseSliceSize[d] (the 'actual' slice size, which only differs from 'typical' <font color="#4169E1">for</font> processor with rank == size -1 ).
<a name="line562">562: </a>              // Likewise, each processor has to keep track of the index offset <font color="#4169E1">for</font> each slice it owns and stores it in BaseSliceOffset[d].
<a name="line563">563: </a>              BaseSliceScale[d]  = BaseMaxSize[d]/size + 1;
<a name="line564">564: </a>              BaseSliceSize[d]   = BaseSliceScale[d];
<a name="line565">565: </a>              <font color="#4169E1">if</font> (rank == size-1) {
<a name="line566">566: </a>                BaseSliceSize[d] =  BaseMaxSize[d] - BaseSliceScale[d]*(size-1);
<a name="line567">567: </a>              }
<a name="line568">568: </a>              BaseSliceSize[d]   = PetscMax(1,BaseSliceSize[d]);
<a name="line569">569: </a>              BaseSliceOffset[d] = BaseLowerBound[d] + BaseSliceScale[d]*rank;
<a name="line570">570: </a>            }// <font color="#4169E1">for</font>(int d = -1; d &gt;= MinGlobalPrefix; d--){
<a name="line571">571: </a>          }
<a name="line572">572: </a>        }// <font color="#4169E1">if</font>(MinGlobalDomain &lt; 0)
<a name="line573">573: </a>
<a name="line574">574: </a>        <font color="#4169E1">for</font> (typename Sequence::iterator point_itor = points-&gt;begin(); point_itor != points-&gt;end(); point_itor++) {
<a name="line575">575: </a>          Point p = (*point_itor);
<a name="line576">576: </a>          // Determine which slice p falls into
<a name="line577">577: </a>          // ASSUMPTION on Point type
<a name="line578">578: </a>          int d = p.prefix;
<a name="line579">579: </a>          int i = p.index;
<a name="line580">580: </a>          int proc;
<a name="line581">581: </a>          <font color="#4169E1">if</font>(d &lt; 0) { // global domain -- determine the owner by which slice p falls into
<a name="line582">582: </a>            proc = (i-BaseLowerBound[d])/BaseSliceScale[d];
<a name="line583">583: </a>          }
<a name="line584">584: </a>          <font color="#4169E1">else</font> { // local domain -- must refer to a rank within the comm
<a name="line585">585: </a>            <font color="#4169E1">if</font>(d &gt;= size) {
<a name="line586">586: </a>              throw ALE::Exception(<font color="#666666">"Local domain outside of comm size"</font>);
<a name="line587">587: </a>            }
<a name="line588">588: </a>            proc = d;
<a name="line589">589: </a>          }
<a name="line590">590: </a>          owner[p]     = proc;
<a name="line591">591: </a>          LeaseData[2*proc+1] = 1;                 // processor owns at least one of ours (i.e., the number of leases from proc is 1)
<a name="line592">592: </a>          LeaseData[2*proc]++;                     // count of how many we lease from proc
<a name="line593">593: </a>        }

<a name="line595">595: </a>        // Base was empty
<a name="line596">596: </a>        <font color="#4169E1">if</font>(points-&gt;begin() == points-&gt;end()) {
<a name="line597">597: </a>          <font color="#4169E1">for</font>(int p = 0; p &lt; size; p++) {
<a name="line598">598: </a>            LeaseData[2*p+0] = 0;
<a name="line599">599: </a>            LeaseData[2*p+1] = 0;
<a name="line600">600: </a>          }
<a name="line601">601: </a>        }
<a name="line602">602: </a>      }; // __determinePointOwners()


<a name="line605">605: </a>      template &lt;typename BaseSequence_&gt;
<a name="line606">606: </a>      void __pullbackAtlases(const BaseSequence&amp; pointsB, Obj&lt;gather_atlas_type&gt;&amp; gather_atlas, Obj&lt;scatter_atlas_type&gt;&amp; scatter_atlas){
<a name="line607">607: </a>        <font color="#4169E1">typedef</font> typename in_atlas_type::traits::baseSequence Sequence;
<a name="line608">608: </a>        <A href="../../../../docs/manualpages/Sys/MPI_Comm.html#MPI_Comm">MPI_Comm</A>       comm = _graphA-&gt;comm();
<a name="line609">609: </a>        int            size = _graphA-&gt;commSize();
<a name="line610">610: </a>        int            rank = _graphA-&gt;commRank();
<a name="line611">611: </a>        <A href="../../../../docs/manualpages/Sys/PetscObject.html#PetscObject">PetscObject</A>    petscObj = _graphA-&gt;petscObj();
<a name="line612">612: </a>        <A href="../../../../docs/manualpages/Sys/PetscMPIInt.html#PetscMPIInt">PetscMPIInt</A>    tag1, tag2, tag3, tag4, tag5, tag6;
<a name="line614">614: </a>        // The bases we are going to work with
<a name="line615">615: </a>        Obj&lt;Sequence&gt; pointsA = _graphA-&gt;base();
<a name="line616">616: </a>        Obj&lt;Sequence&gt; pointsB = _graphB-&gt;base();

<a name="line618">618: </a>        // We MUST have the same sellers <font color="#4169E1">for</font> points in A and B (same point owner determination)
<a name="line619">619: </a>        int *BuyDataA; // 2 ints per processor: number of A base points we buy and number of sales (0 or 1).
<a name="line620">620: </a>        int *BuyDataB; // 2 ints per processor: number of B base points we buy and number of sales (0 or 1).
<a name="line621">621: </a>        <A href="../../../../docs/manualpages/Sys/PetscMalloc2.html#PetscMalloc2">PetscMalloc2</A>(2*size,int,&amp;BuyDataA,2*size,int,&amp;BuyDataB);CHKERROR(ierr, <font color="#666666">"Error in <A href="../../../../docs/manualpages/Sys/PetscMalloc.html#PetscMalloc">PetscMalloc</A>"</font>);
<a name="line622">622: </a>        <A href="../../../../docs/manualpages/Sys/PetscMemzero.html#PetscMemzero">PetscMemzero</A>(BuyDataA, 2*size * <font color="#4169E1">sizeof</font>(int));CHKERROR(ierr, <font color="#666666">"Error in <A href="../../../../docs/manualpages/Sys/PetscMemzero.html#PetscMemzero">PetscMemzero</A>"</font>);
<a name="line623">623: </a>        <A href="../../../../docs/manualpages/Sys/PetscMemzero.html#PetscMemzero">PetscMemzero</A>(BuyDataB, 2*size * <font color="#4169E1">sizeof</font>(int));CHKERROR(ierr, <font color="#666666">"Error in <A href="../../../../docs/manualpages/Sys/PetscMemzero.html#PetscMemzero">PetscMemzero</A>"</font>);
<a name="line624">624: </a>        // Map from points to the process managing its bin (seller)
<a name="line625">625: </a>        Point__int ownerA, ownerB;

<a name="line627">627: </a>        // determine owners of each base node and save it in a map
<a name="line628">628: </a>        __determinePointOwners(_graphA, pointsA, BuyDataA, ownerA);
<a name="line629">629: </a>        __determinePointOwners(_graphB, pointsB, BuyDataB, ownerB);

<a name="line631">631: </a>        int  msgSize = 3;   // A point is 2 ints, and the cone size is 1
<a name="line632">632: </a>        int  BuyCountA = 0; // The number of sellers with which this process (A buyer) communicates
<a name="line633">633: </a>        int  BuyCountB = 0; // The number of sellers with which this process (B buyer) communicates
<a name="line634">634: </a>        int *BuySizesA;     // The number of A points to buy from each seller
<a name="line635">635: </a>        int *BuySizesB;     // The number of B points to buy from each seller
<a name="line636">636: </a>        int *SellersA;      // The process <font color="#4169E1">for</font> each seller of A points
<a name="line637">637: </a>        int *SellersB;      // The process <font color="#4169E1">for</font> each seller of B points
<a name="line638">638: </a>        int *offsetsA = new int[size];
<a name="line639">639: </a>        int *offsetsB = new int[size];
<a name="line640">640: </a>        <font color="#4169E1">for</font>(int p = 0; p &lt; size; ++p) {
<a name="line641">641: </a>          BuyCountA += BuyDataA[2*p+1];
<a name="line642">642: </a>          BuyCountB += BuyDataB[2*p+1];
<a name="line643">643: </a>        }
<a name="line644">644: </a>        <A href="../../../../docs/manualpages/Sys/PetscMalloc2.html#PetscMalloc2">PetscMalloc2</A>(BuyCountA,int,&amp;BuySizesA,BuyCountA,int,&amp;SellersA);CHKERROR(ierr, <font color="#666666">"Error in <A href="../../../../docs/manualpages/Sys/PetscMalloc.html#PetscMalloc">PetscMalloc</A>"</font>);
<a name="line645">645: </a>        <A href="../../../../docs/manualpages/Sys/PetscMalloc2.html#PetscMalloc2">PetscMalloc2</A>(BuyCountB,int,&amp;BuySizesB,BuyCountB,int,&amp;SellersB);CHKERROR(ierr, <font color="#666666">"Error in <A href="../../../../docs/manualpages/Sys/PetscMalloc.html#PetscMalloc">PetscMalloc</A>"</font>);
<a name="line646">646: </a>        <font color="#4169E1">for</font>(int p = 0, buyNumA = 0, buyNumB = 0; p &lt; size; ++p) {
<a name="line647">647: </a>          <font color="#4169E1">if</font> (BuyDataA[2*p+1]) {
<a name="line648">648: </a>            SellersA[buyNumA]    = p;
<a name="line649">649: </a>            BuySizesA[buyNumA++] = BuyDataA[2*p];
<a name="line650">650: </a>          }
<a name="line651">651: </a>          <font color="#4169E1">if</font> (BuyDataB[2*p+1]) {
<a name="line652">652: </a>            SellersB[buyNumB]    = p;
<a name="line653">653: </a>            BuySizesB[buyNumB++] = BuyDataB[2*p];
<a name="line654">654: </a>          }
<a name="line655">655: </a>          <font color="#4169E1">if</font> (p == 0) {
<a name="line656">656: </a>            offsetsA[p] = 0;
<a name="line657">657: </a>            offsetsB[p] = 0;
<a name="line658">658: </a>          } <font color="#4169E1">else</font> {
<a name="line659">659: </a>            offsetsA[p] = offsetsA[p-1] + msgSize*BuyDataA[2*(p-1)];
<a name="line660">660: </a>            offsetsB[p] = offsetsB[p-1] + msgSize*BuyDataB[2*(p-1)];
<a name="line661">661: </a>          }
<a name="line662">662: </a>        }

<a name="line664">664: </a>        // All points are bought from someone
<a name="line665">665: </a>        int32_t *BuyPointsA; // (point, coneSize) <font color="#4169E1">for</font> each A point boung from a seller
<a name="line666">666: </a>        int32_t *BuyPointsB; // (point, coneSize) <font color="#4169E1">for</font> each B point boung from a seller
<a name="line667">667: </a>        <A href="../../../../docs/manualpages/Sys/PetscMalloc2.html#PetscMalloc2">PetscMalloc2</A>(msgSize*pointsA-&gt;size(),int32_t,&amp;BuyPointsA,msgSize*pointsB-&gt;size(),int32_t,&amp;BuyPointsB);CHKERROR(ierr,<font color="#666666">"Error in <A href="../../../../docs/manualpages/Sys/PetscMalloc.html#PetscMalloc">PetscMalloc</A>"</font>);
<a name="line668">668: </a>        <font color="#4169E1">for</font> (typename Sequence::iterator p_itor = pointsA-&gt;begin(); p_itor != pointsA-&gt;end(); p_itor++) {
<a name="line669">669: </a>          BuyPointsA[offsetsA[ownerA[*p_itor]]++] = (*p_itor).prefix;
<a name="line670">670: </a>          BuyPointsA[offsetsA[ownerA[*p_itor]]++] = (*p_itor).index;
<a name="line671">671: </a>          BuyPointsA[offsetsA[ownerA[*p_itor]]++] = _graphA-&gt;cone(*p_itor)-&gt;size();
<a name="line672">672: </a>        }
<a name="line673">673: </a>        <font color="#4169E1">for</font> (typename Sequence::iterator p_itor = pointsB-&gt;begin(); p_itor != pointsB-&gt;end(); p_itor++) {
<a name="line674">674: </a>          BuyPointsB[offsetsB[ownerB[*p_itor]]++] = (*p_itor).prefix;
<a name="line675">675: </a>          BuyPointsB[offsetsB[ownerB[*p_itor]]++] = (*p_itor).index;
<a name="line676">676: </a>          BuyPointsB[offsetsB[ownerB[*p_itor]]++] = _graphB-&gt;cone(*p_itor)-&gt;size();
<a name="line677">677: </a>        }
<a name="line678">678: </a>        <font color="#4169E1">for</font>(int b = 0, o = 0; b &lt; BuyCountA; ++b) {
<a name="line679">679: </a>          <font color="#4169E1">if</font> (offsetsA[SellersA[b]] - o != msgSize*BuySizesA[b]) {
<a name="line680">680: </a>            throw ALE::Exception(<font color="#666666">"Invalid A point size"</font>);
<a name="line681">681: </a>          }
<a name="line682">682: </a>          o += msgSize*BuySizesA[b];
<a name="line683">683: </a>        }
<a name="line684">684: </a>        <font color="#4169E1">for</font>(int b = 0, o = 0; b &lt; BuyCountB; ++b) {
<a name="line685">685: </a>          <font color="#4169E1">if</font> (offsetsB[SellersB[b]] - o != msgSize*BuySizesB[b]) {
<a name="line686">686: </a>            throw ALE::Exception(<font color="#666666">"Invalid B point size"</font>);
<a name="line687">687: </a>          }
<a name="line688">688: </a>          o += msgSize*BuySizesB[b];
<a name="line689">689: </a>        }
<a name="line690">690: </a>        delete [] offsetsA;
<a name="line691">691: </a>        delete [] offsetsB;

<a name="line693">693: </a>        int  SellCountA;     // The number of A point buyers with which this process (seller) communicates
<a name="line694">694: </a>        int  SellCountB;     // The number of B point buyers with which this process (seller) communicates
<a name="line695">695: </a>        int *SellSizesA;     // The number of A points to sell to each buyer
<a name="line696">696: </a>        int *SellSizesB;     // The number of B points to sell to each buyer
<a name="line697">697: </a>        int *BuyersA;        // The process <font color="#4169E1">for</font> each A point buyer
<a name="line698">698: </a>        int *BuyersB;        // The process <font color="#4169E1">for</font> each B point buyer
<a name="line699">699: </a>        int  MaxSellSizeA;   // The maximum number of messages to be sold to any A point buyer
<a name="line700">700: </a>        int  MaxSellSizeB;   // The maximum number of messages to be sold to any B point buyer
<a name="line701">701: </a>        int32_t *SellPointsA = <A href="../../../../docs/manualpages/Sys/PETSC_NULL.html#PETSC_NULL">PETSC_NULL</A>; // The points and cone sizes from all buyers
<a name="line702">702: </a>        int32_t *SellPointsB = <A href="../../../../docs/manualpages/Sys/PETSC_NULL.html#PETSC_NULL">PETSC_NULL</A>; // The points and cone sizes from all buyers
<a name="line703">703: </a>        PetscMaxSum(comm, BuyDataA, &amp;MaxSellSizeA, &amp;SellCountA);CHKERROR(ierr,<font color="#666666">"Error in PetscMaxSum"</font>);
<a name="line704">704: </a>        PetscMaxSum(comm, BuyDataB, &amp;MaxSellSizeB, &amp;SellCountB);CHKERROR(ierr,<font color="#666666">"Error in PetscMaxSum"</font>);
<a name="line705">705: </a>        <A href="../../../../docs/manualpages/Sys/PetscMalloc2.html#PetscMalloc2">PetscMalloc2</A>(SellCountA,int,&amp;SellSizesA,SellCountA,int,&amp;BuyersA);CHKERROR(ierr, <font color="#666666">"Error in <A href="../../../../docs/manualpages/Sys/PetscMalloc.html#PetscMalloc">PetscMalloc</A>"</font>);
<a name="line706">706: </a>        <A href="../../../../docs/manualpages/Sys/PetscMalloc2.html#PetscMalloc2">PetscMalloc2</A>(SellCountB,int,&amp;SellSizesB,SellCountB,int,&amp;BuyersB);CHKERROR(ierr, <font color="#666666">"Error in <A href="../../../../docs/manualpages/Sys/PetscMalloc.html#PetscMalloc">PetscMalloc</A>"</font>);
<a name="line707">707: </a>        <font color="#4169E1">for</font>(int s = 0; s &lt; SellCountA; s++) {
<a name="line708">708: </a>          SellSizesA[s] = MaxSellSizeA;
<a name="line709">709: </a>          BuyersA[s]    = MPI_ANY_SOURCE;
<a name="line710">710: </a>        }
<a name="line711">711: </a>        <font color="#4169E1">for</font>(int s = 0; s &lt; SellCountB; s++) {
<a name="line712">712: </a>          SellSizesB[s] = MaxSellSizeB;
<a name="line713">713: </a>          BuyersB[s]    = MPI_ANY_SOURCE;
<a name="line714">714: </a>        }

<a name="line716">716: </a>        <font color="#4169E1">if</font> (debug) {
<a name="line717">717: </a>          ostringstream txt;

<a name="line719">719: </a>          <font color="#4169E1">for</font>(int s = 0; s &lt; BuyCountA; s++) {
<a name="line720">720: </a>            txt &lt;&lt; <font color="#666666">"BuySizesA["</font>&lt;&lt;s&lt;&lt;<font color="#666666">"]: "</font>&lt;&lt;BuySizesA[s]&lt;&lt;<font color="#666666">" from seller "</font>&lt;&lt;SellersA[s]&lt;&lt; std::endl;
<a name="line721">721: </a>          }
<a name="line722">722: </a>          <font color="#4169E1">for</font>(int p = 0; p &lt; (int) pointsA-&gt;size(); p++) {
<a name="line723">723: </a>            txt &lt;&lt; <font color="#666666">"["</font>&lt;&lt;rank&lt;&lt;<font color="#666666">"]: BuyPointsA["</font>&lt;&lt;p&lt;&lt;<font color="#666666">"]: ("</font>&lt;&lt;BuyPointsA[p*msgSize]&lt;&lt;<font color="#666666">", "</font>&lt;&lt;BuyPointsA[p*msgSize+1]&lt;&lt;<font color="#666666">") coneSize "</font>&lt;&lt;BuyPointsA[p*msgSize+2]&lt;&lt;std::endl;
<a name="line724">724: </a>          }
<a name="line725">725: </a>          <font color="#4169E1">for</font>(int s = 0; s &lt; BuyCountB; s++) {
<a name="line726">726: </a>            txt &lt;&lt; <font color="#666666">"BuySizesB["</font>&lt;&lt;s&lt;&lt;<font color="#666666">"]: "</font>&lt;&lt;BuySizesB[s]&lt;&lt;<font color="#666666">" from seller "</font>&lt;&lt;SellersB[s]&lt;&lt; std::endl;
<a name="line727">727: </a>          }
<a name="line728">728: </a>          <font color="#4169E1">for</font>(int p = 0; p &lt; (int) pointsB-&gt;size(); p++) {
<a name="line729">729: </a>            txt &lt;&lt; <font color="#666666">"["</font>&lt;&lt;rank&lt;&lt;<font color="#666666">"]: BuyPointsB["</font>&lt;&lt;p&lt;&lt;<font color="#666666">"]: ("</font>&lt;&lt;BuyPointsB[p*msgSize]&lt;&lt;<font color="#666666">", "</font>&lt;&lt;BuyPointsB[p*msgSize+1]&lt;&lt;<font color="#666666">") coneSize "</font>&lt;&lt;BuyPointsB[p*msgSize+2]&lt;&lt;std::endl;
<a name="line730">730: </a>          }
<a name="line731">731: </a>          <A href="../../../../docs/manualpages/Sys/PetscSynchronizedPrintf.html#PetscSynchronizedPrintf">PetscSynchronizedPrintf</A>(comm, txt.str().c_str()); CHKERROR(ierr, <font color="#666666">"Error in <A href="../../../../docs/manualpages/Sys/PetscSynchronizedPrintf.html#PetscSynchronizedPrintf">PetscSynchronizedPrintf</A>"</font>);
<a name="line732">732: </a>          <A href="../../../../docs/manualpages/Sys/PetscSynchronizedFlush.html#PetscSynchronizedFlush">PetscSynchronizedFlush</A>(comm);CHKERROR(ierr,<font color="#666666">"Error in <A href="../../../../docs/manualpages/Sys/PetscSynchronizedFlush.html#PetscSynchronizedFlush">PetscSynchronizedFlush</A>"</font>);
<a name="line733">733: </a>        }

<a name="line735">735: </a>        // First tell sellers which points we want to buy
<a name="line736">736: </a>        //   SellSizes, Buyers, and SellPoints are output
<a name="line737">737: </a>        <A href="../../../../docs/manualpages/Sys/PetscObjectGetNewTag.html#PetscObjectGetNewTag">PetscObjectGetNewTag</A>(petscObj, &amp;tag1);CHKERROR(ierr, <font color="#666666">"Failed on <A href="../../../../docs/manualpages/Sys/PetscObjectGetNewTag.html#PetscObjectGetNewTag">PetscObjectGetNewTag</A>"</font>);
<a name="line738">738: </a>        commCycle(comm, tag1, msgSize, BuyCountA, BuySizesA, SellersA, BuyPointsA, SellCountA, SellSizesA, BuyersA, &amp;SellPointsA);
<a name="line739">739: </a>        <A href="../../../../docs/manualpages/Sys/PetscObjectGetNewTag.html#PetscObjectGetNewTag">PetscObjectGetNewTag</A>(petscObj, &amp;tag2);CHKERROR(ierr, <font color="#666666">"Failed on <A href="../../../../docs/manualpages/Sys/PetscObjectGetNewTag.html#PetscObjectGetNewTag">PetscObjectGetNewTag</A>"</font>);
<a name="line740">740: </a>        commCycle(comm, tag2, msgSize, BuyCountB, BuySizesB, SellersB, BuyPointsB, SellCountB, SellSizesB, BuyersB, &amp;SellPointsB);

<a name="line742">742: </a>        <font color="#4169E1">if</font> (debug) {
<a name="line743">743: </a>          ostringstream txt;

<a name="line745">745: </a>          <font color="#4169E1">if</font> (!rank) {txt &lt;&lt; <font color="#666666">"Unsquished"</font> &lt;&lt; std::endl;}
<a name="line746">746: </a>          <font color="#4169E1">for</font>(int p = 0; p &lt; SellCountA*MaxSellSizeA; p++) {
<a name="line747">747: </a>            txt &lt;&lt; <font color="#666666">"["</font>&lt;&lt;rank&lt;&lt;<font color="#666666">"]: SellPointsA["</font>&lt;&lt;p&lt;&lt;<font color="#666666">"]: ("</font>&lt;&lt;SellPointsA[p*msgSize]&lt;&lt;<font color="#666666">", "</font>&lt;&lt;SellPointsA[p*msgSize+1]&lt;&lt;<font color="#666666">") coneSize "</font>&lt;&lt;SellPointsA[p*msgSize+2]&lt;&lt;std::endl;
<a name="line748">748: </a>          }
<a name="line749">749: </a>          <font color="#4169E1">for</font>(int p = 0; p &lt; SellCountB*MaxSellSizeB; p++) {
<a name="line750">750: </a>            txt &lt;&lt; <font color="#666666">"["</font>&lt;&lt;rank&lt;&lt;<font color="#666666">"]: SellPointsB["</font>&lt;&lt;p&lt;&lt;<font color="#666666">"]: ("</font>&lt;&lt;SellPointsB[p*msgSize]&lt;&lt;<font color="#666666">", "</font>&lt;&lt;SellPointsB[p*msgSize+1]&lt;&lt;<font color="#666666">") coneSize "</font>&lt;&lt;SellPointsB[p*msgSize+2]&lt;&lt;std::endl;
<a name="line751">751: </a>          }
<a name="line752">752: </a>          <A href="../../../../docs/manualpages/Sys/PetscSynchronizedPrintf.html#PetscSynchronizedPrintf">PetscSynchronizedPrintf</A>(comm, txt.str().c_str());CHKERROR(ierr, <font color="#666666">"Error in <A href="../../../../docs/manualpages/Sys/PetscSynchronizedPrintf.html#PetscSynchronizedPrintf">PetscSynchronizedPrintf</A>"</font>);
<a name="line753">753: </a>          <A href="../../../../docs/manualpages/Sys/PetscSynchronizedFlush.html#PetscSynchronizedFlush">PetscSynchronizedFlush</A>(comm);CHKERROR(ierr,<font color="#666666">"Error in <A href="../../../../docs/manualpages/Sys/PetscSynchronizedFlush.html#PetscSynchronizedFlush">PetscSynchronizedFlush</A>"</font>);
<a name="line754">754: </a>        }

<a name="line756">756: </a>        // Since we gave maximum sizes, we need to squeeze SellPoints
<a name="line757">757: </a>        <font color="#4169E1">for</font>(int s = 0, offset = 0; s &lt; SellCountA; s++) {
<a name="line758">758: </a>          <font color="#4169E1">if</font> (offset != s*MaxSellSizeA*msgSize) {
<a name="line759">759: </a>            <A href="../../../../docs/manualpages/Sys/PetscMemmove.html#PetscMemmove">PetscMemmove</A>(&amp;SellPointsA[offset], &amp;SellPointsA[s*MaxSellSizeA*msgSize], SellSizesA[s]*msgSize*<font color="#4169E1">sizeof</font>(int32_t));CHKERROR(ierr,<font color="#666666">"Error in <A href="../../../../docs/manualpages/Sys/PetscMemmove.html#PetscMemmove">PetscMemmove</A>"</font>);
<a name="line760">760: </a>          }
<a name="line761">761: </a>          offset += SellSizesA[s]*msgSize;
<a name="line762">762: </a>        }
<a name="line763">763: </a>        <font color="#4169E1">for</font>(int s = 0, offset = 0; s &lt; SellCountB; s++) {
<a name="line764">764: </a>          <font color="#4169E1">if</font> (offset != s*MaxSellSizeB*msgSize) {
<a name="line765">765: </a>            <A href="../../../../docs/manualpages/Sys/PetscMemmove.html#PetscMemmove">PetscMemmove</A>(&amp;SellPointsB[offset], &amp;SellPointsB[s*MaxSellSizeB*msgSize], SellSizesB[s]*msgSize*<font color="#4169E1">sizeof</font>(int32_t));CHKERROR(ierr,<font color="#666666">"Error in <A href="../../../../docs/manualpages/Sys/PetscMemmove.html#PetscMemmove">PetscMemmove</A>"</font>);
<a name="line766">766: </a>          }
<a name="line767">767: </a>          offset += SellSizesB[s]*msgSize;
<a name="line768">768: </a>        }

<a name="line770">770: </a>        <font color="#4169E1">if</font> (debug) {
<a name="line771">771: </a>          ostringstream txt;
<a name="line772">772: </a>          int SellSizeA = 0, SellSizeB = 0;

<a name="line774">774: </a>          <font color="#4169E1">if</font> (!rank) {txt &lt;&lt; <font color="#666666">"Squished"</font> &lt;&lt; std::endl;}
<a name="line775">775: </a>          <font color="#4169E1">for</font>(int s = 0; s &lt; SellCountA; s++) {
<a name="line776">776: </a>            SellSizeA += SellSizesA[s];
<a name="line777">777: </a>            txt &lt;&lt; <font color="#666666">"SellSizesA["</font>&lt;&lt;s&lt;&lt;<font color="#666666">"]: "</font>&lt;&lt;SellSizesA[s]&lt;&lt;<font color="#666666">" from buyer "</font>&lt;&lt;BuyersA[s]&lt;&lt; std::endl;
<a name="line778">778: </a>          }
<a name="line779">779: </a>          <font color="#4169E1">for</font>(int p = 0; p &lt; SellSizeA; p++) {
<a name="line780">780: </a>            txt &lt;&lt; <font color="#666666">"["</font>&lt;&lt;rank&lt;&lt;<font color="#666666">"]: SellPointsA["</font>&lt;&lt;p&lt;&lt;<font color="#666666">"]: ("</font>&lt;&lt;SellPointsA[p*msgSize]&lt;&lt;<font color="#666666">", "</font>&lt;&lt;SellPointsA[p*msgSize+1]&lt;&lt;<font color="#666666">") coneSize "</font>&lt;&lt;SellPointsA[p*msgSize+2]&lt;&lt;std::endl;
<a name="line781">781: </a>          }
<a name="line782">782: </a>          <font color="#4169E1">for</font>(int s = 0; s &lt; SellCountB; s++) {
<a name="line783">783: </a>            SellSizeB += SellSizesB[s];
<a name="line784">784: </a>            txt &lt;&lt; <font color="#666666">"SellSizesB["</font>&lt;&lt;s&lt;&lt;<font color="#666666">"]: "</font>&lt;&lt;SellSizesB[s]&lt;&lt;<font color="#666666">" from buyer "</font>&lt;&lt;BuyersB[s]&lt;&lt; std::endl;
<a name="line785">785: </a>          }
<a name="line786">786: </a>          <font color="#4169E1">for</font>(int p = 0; p &lt; SellSizeB; p++) {
<a name="line787">787: </a>            txt &lt;&lt; <font color="#666666">"["</font>&lt;&lt;rank&lt;&lt;<font color="#666666">"]: SellPointsB["</font>&lt;&lt;p&lt;&lt;<font color="#666666">"]: ("</font>&lt;&lt;SellPointsB[p*msgSize]&lt;&lt;<font color="#666666">", "</font>&lt;&lt;SellPointsB[p*msgSize+1]&lt;&lt;<font color="#666666">") coneSize "</font>&lt;&lt;SellPointsB[p*msgSize+2]&lt;&lt;std::endl;
<a name="line788">788: </a>          }
<a name="line789">789: </a>          <A href="../../../../docs/manualpages/Sys/PetscSynchronizedPrintf.html#PetscSynchronizedPrintf">PetscSynchronizedPrintf</A>(comm, txt.str().c_str());CHKERROR(ierr, <font color="#666666">"Error in <A href="../../../../docs/manualpages/Sys/PetscSynchronizedPrintf.html#PetscSynchronizedPrintf">PetscSynchronizedPrintf</A>"</font>);
<a name="line790">790: </a>          <A href="../../../../docs/manualpages/Sys/PetscSynchronizedFlush.html#PetscSynchronizedFlush">PetscSynchronizedFlush</A>(comm);CHKERROR(ierr,<font color="#666666">"Error in <A href="../../../../docs/manualpages/Sys/PetscSynchronizedFlush.html#PetscSynchronizedFlush">PetscSynchronizedFlush</A>"</font>);
<a name="line791">791: </a>        }

<a name="line793">793: </a>        // Map from A base points to (B process, B coneSize) pairs
<a name="line794">794: </a>        Point__int_pair_set BillOfSaleAtoB;
<a name="line795">795: </a>        // Map from B base points to (A process, A coneSize) pairs
<a name="line796">796: </a>        Point__int_pair_set BillOfSaleBtoA;

<a name="line798">798: </a>        // Find the A points being sold to B buyers and record the B cone size
<a name="line799">799: </a>        <font color="#4169E1">for</font>(int s = 0, offset = 0; s &lt; SellCountA; s++) {
<a name="line800">800: </a>          <font color="#4169E1">for</font>(int m = 0; m &lt; SellSizesA[s]; m++) {
<a name="line801">801: </a>            Point point = Point(SellPointsA[offset], SellPointsA[offset+1]);
<a name="line802">802: </a>            // Just insert the point
<a name="line803">803: </a>            int size = BillOfSaleAtoB[point].size();
<a name="line804">804: </a>            // Avoid unused variable warning
<a name="line805">805: </a>            <font color="#4169E1">if</font> (!size) offset += msgSize;
<a name="line806">806: </a>          }
<a name="line807">807: </a>        }
<a name="line808">808: </a>        <font color="#4169E1">for</font>(int s = 0, offset = 0; s &lt; SellCountB; s++) {
<a name="line809">809: </a>          <font color="#4169E1">for</font>(int m = 0; m &lt; SellSizesB[s]; m++) {
<a name="line810">810: </a>            Point point = Point(SellPointsB[offset], SellPointsB[offset+1]);

<a name="line812">812: </a>            <font color="#4169E1">if</font> (BillOfSaleAtoB.find(point) != BillOfSaleAtoB.end()) {
<a name="line813">813: </a>              BillOfSaleAtoB[point].insert(int_pair(BuyersB[s], SellPointsB[offset+2]));
<a name="line814">814: </a>            }
<a name="line815">815: </a>            offset += msgSize;
<a name="line816">816: </a>          }
<a name="line817">817: </a>        }
<a name="line818">818: </a>        // Find the B points being sold to A buyers and record the A cone size
<a name="line819">819: </a>        <font color="#4169E1">for</font>(int s = 0, offset = 0; s &lt; SellCountB; s++) {
<a name="line820">820: </a>          <font color="#4169E1">for</font>(int m = 0; m &lt; SellSizesB[s]; m++) {
<a name="line821">821: </a>            Point point = Point(SellPointsB[offset], SellPointsB[offset+1]);
<a name="line822">822: </a>            // Just insert the point
<a name="line823">823: </a>            int size = BillOfSaleBtoA[point].size();
<a name="line824">824: </a>            // Avoid unused variable warning
<a name="line825">825: </a>            <font color="#4169E1">if</font> (!size) offset += msgSize;
<a name="line826">826: </a>          }
<a name="line827">827: </a>        }
<a name="line828">828: </a>        <font color="#4169E1">for</font>(int s = 0, offset = 0; s &lt; SellCountA; s++) {
<a name="line829">829: </a>          <font color="#4169E1">for</font>(int m = 0; m &lt; SellSizesA[s]; m++) {
<a name="line830">830: </a>            Point point = Point(SellPointsA[offset], SellPointsA[offset+1]);

<a name="line832">832: </a>            <font color="#4169E1">if</font> (BillOfSaleBtoA.find(point) != BillOfSaleBtoA.end()) {
<a name="line833">833: </a>              BillOfSaleBtoA[point].insert(int_pair(BuyersA[s], SellPointsA[offset+2]));
<a name="line834">834: </a>            }
<a name="line835">835: </a>            offset += msgSize;
<a name="line836">836: </a>          }
<a name="line837">837: </a>        }
<a name="line838">838: </a>        // Calculate number of B buyers <font color="#4169E1">for</font> A base points
<a name="line839">839: </a>        <font color="#4169E1">for</font>(int s = 0, offset = 0; s &lt; SellCountA; s++) {
<a name="line840">840: </a>          <font color="#4169E1">for</font>(int m = 0; m &lt; SellSizesA[s]; m++) {
<a name="line841">841: </a>            Point point = Point(SellPointsA[offset], SellPointsA[offset+1]);

<a name="line843">843: </a>            SellPointsA[offset+2] = BillOfSaleAtoB[point].size();
<a name="line844">844: </a>            offset += msgSize;
<a name="line845">845: </a>          }
<a name="line846">846: </a>        }
<a name="line847">847: </a>        // Calculate number of A buyers <font color="#4169E1">for</font> B base points
<a name="line848">848: </a>        <font color="#4169E1">for</font>(int s = 0, offset = 0; s &lt; SellCountB; s++) {
<a name="line849">849: </a>          <font color="#4169E1">for</font>(int m = 0; m &lt; SellSizesB[s]; m++) {
<a name="line850">850: </a>            Point point = Point(SellPointsB[offset], SellPointsB[offset+1]);

<a name="line852">852: </a>            SellPointsB[offset+2] = BillOfSaleBtoA[point].size();
<a name="line853">853: </a>            offset += msgSize;
<a name="line854">854: </a>          }
<a name="line855">855: </a>        }

<a name="line857">857: </a>        // Tell A buyers how many B buyers there were (contained in BuyPointsA)
<a name="line858">858: </a>        // Tell B buyers how many A buyers there were (contained in BuyPointsB)
<a name="line859">859: </a>        <A href="../../../../docs/manualpages/Sys/PetscObjectGetNewTag.html#PetscObjectGetNewTag">PetscObjectGetNewTag</A>(petscObj, &amp;tag3);CHKERROR(ierr, <font color="#666666">"Failed on <A href="../../../../docs/manualpages/Sys/PetscObjectGetNewTag.html#PetscObjectGetNewTag">PetscObjectGetNewTag</A>"</font>);
<a name="line860">860: </a>        commCycle(comm, tag3, msgSize, SellCountA, SellSizesA, BuyersA, SellPointsA, BuyCountA, BuySizesA, SellersA, &amp;BuyPointsA);
<a name="line861">861: </a>        <A href="../../../../docs/manualpages/Sys/PetscObjectGetNewTag.html#PetscObjectGetNewTag">PetscObjectGetNewTag</A>(petscObj, &amp;tag4);CHKERROR(ierr, <font color="#666666">"Failed on <A href="../../../../docs/manualpages/Sys/PetscObjectGetNewTag.html#PetscObjectGetNewTag">PetscObjectGetNewTag</A>"</font>);
<a name="line862">862: </a>        commCycle(comm, tag4, msgSize, SellCountB, SellSizesB, BuyersB, SellPointsB, BuyCountB, BuySizesB, SellersB, &amp;BuyPointsB);

<a name="line864">864: </a>        <font color="#4169E1">if</font> (debug) {
<a name="line865">865: </a>          ostringstream txt;
<a name="line866">866: </a>          int BuySizeA = 0, BuySizeB = 0;

<a name="line868">868: </a>          <font color="#4169E1">if</font> (!rank) {txt &lt;&lt; <font color="#666666">"Got other B and A buyers"</font> &lt;&lt; std::endl;}
<a name="line869">869: </a>          <font color="#4169E1">for</font>(int s = 0; s &lt; BuyCountA; s++) {
<a name="line870">870: </a>            BuySizeA += BuySizesA[s];
<a name="line871">871: </a>            txt &lt;&lt; <font color="#666666">"BuySizesA["</font>&lt;&lt;s&lt;&lt;<font color="#666666">"]: "</font>&lt;&lt;BuySizesA[s]&lt;&lt;<font color="#666666">" from seller "</font>&lt;&lt;SellersA[s]&lt;&lt; std::endl;
<a name="line872">872: </a>          }
<a name="line873">873: </a>          <font color="#4169E1">for</font>(int p = 0; p &lt; BuySizeA; p++) {
<a name="line874">874: </a>            txt &lt;&lt; <font color="#666666">"["</font>&lt;&lt;rank&lt;&lt;<font color="#666666">"]: BuyPointsA["</font>&lt;&lt;p&lt;&lt;<font color="#666666">"]: ("</font>&lt;&lt;BuyPointsA[p*msgSize]&lt;&lt;<font color="#666666">", "</font>&lt;&lt;BuyPointsA[p*msgSize+1]&lt;&lt;<font color="#666666">") B buyers "</font>&lt;&lt;BuyPointsA[p*msgSize+2]&lt;&lt;std::endl;
<a name="line875">875: </a>          }
<a name="line876">876: </a>          <font color="#4169E1">for</font>(int s = 0; s &lt; BuyCountB; s++) {
<a name="line877">877: </a>            BuySizeB += BuySizesB[s];
<a name="line878">878: </a>            txt &lt;&lt; <font color="#666666">"BuySizesB["</font>&lt;&lt;s&lt;&lt;<font color="#666666">"]: "</font>&lt;&lt;BuySizesB[s]&lt;&lt;<font color="#666666">" from seller "</font>&lt;&lt;SellersB[s]&lt;&lt; std::endl;
<a name="line879">879: </a>          }
<a name="line880">880: </a>          <font color="#4169E1">for</font>(int p = 0; p &lt; BuySizeB; p++) {
<a name="line881">881: </a>            txt &lt;&lt; <font color="#666666">"["</font>&lt;&lt;rank&lt;&lt;<font color="#666666">"]: BuyPointsB["</font>&lt;&lt;p&lt;&lt;<font color="#666666">"]: ("</font>&lt;&lt;BuyPointsB[p*msgSize]&lt;&lt;<font color="#666666">", "</font>&lt;&lt;BuyPointsB[p*msgSize+1]&lt;&lt;<font color="#666666">") A buyers "</font>&lt;&lt;BuyPointsB[p*msgSize+2]&lt;&lt;std::endl;
<a name="line882">882: </a>          }
<a name="line883">883: </a>          <A href="../../../../docs/manualpages/Sys/PetscSynchronizedPrintf.html#PetscSynchronizedPrintf">PetscSynchronizedPrintf</A>(comm, txt.str().c_str());CHKERROR(ierr, <font color="#666666">"Error in <A href="../../../../docs/manualpages/Sys/PetscSynchronizedPrintf.html#PetscSynchronizedPrintf">PetscSynchronizedPrintf</A>"</font>);
<a name="line884">884: </a>          <A href="../../../../docs/manualpages/Sys/PetscSynchronizedFlush.html#PetscSynchronizedFlush">PetscSynchronizedFlush</A>(comm);CHKERROR(ierr,<font color="#666666">"Error in <A href="../../../../docs/manualpages/Sys/PetscSynchronizedFlush.html#PetscSynchronizedFlush">PetscSynchronizedFlush</A>"</font>);
<a name="line885">885: </a>        }

<a name="line887">887: </a>        int      BuyConesSizeA  = 0;
<a name="line888">888: </a>        int      BuyConesSizeB  = 0;
<a name="line889">889: </a>        int      SellConesSizeA = 0;
<a name="line890">890: </a>        int      SellConesSizeB = 0;
<a name="line891">891: </a>        int     *BuyConesSizesA;  // The number of A points to buy from each seller
<a name="line892">892: </a>        int     *BuyConesSizesB;  // The number of B points to buy from each seller
<a name="line893">893: </a>        int     *SellConesSizesA; // The number of A points to sell to each buyer
<a name="line894">894: </a>        int     *SellConesSizesB; // The number of B points to sell to each buyer
<a name="line895">895: </a>        int32_t *SellConesA;      // The (rank, B cone size) <font color="#4169E1">for</font> each A point from all other B buyers
<a name="line896">896: </a>        int32_t *SellConesB;      // The (rank, A cone size) <font color="#4169E1">for</font> each B point from all other A buyers
<a name="line897">897: </a>        int32_t *overlapInfoA = <A href="../../../../docs/manualpages/Sys/PETSC_NULL.html#PETSC_NULL">PETSC_NULL</A>; // The (rank, B cone size) <font color="#4169E1">for</font> each A point from all other B buyers
<a name="line898">898: </a>        int32_t *overlapInfoB = <A href="../../../../docs/manualpages/Sys/PETSC_NULL.html#PETSC_NULL">PETSC_NULL</A>; // The (rank, A cone size) <font color="#4169E1">for</font> each B point from all other A buyers
<a name="line899">899: </a>        <A href="../../../../docs/manualpages/Sys/PetscMalloc2.html#PetscMalloc2">PetscMalloc2</A>(BuyCountA,int,&amp;BuyConesSizesA,SellCountA,int,&amp;SellConesSizesA);CHKERROR(ierr, <font color="#666666">"Error in <A href="../../../../docs/manualpages/Sys/PetscMalloc.html#PetscMalloc">PetscMalloc</A>"</font>);
<a name="line900">900: </a>        <A href="../../../../docs/manualpages/Sys/PetscMalloc2.html#PetscMalloc2">PetscMalloc2</A>(BuyCountB,int,&amp;BuyConesSizesB,SellCountB,int,&amp;SellConesSizesB);CHKERROR(ierr, <font color="#666666">"Error in <A href="../../../../docs/manualpages/Sys/PetscMalloc.html#PetscMalloc">PetscMalloc</A>"</font>);
<a name="line901">901: </a>        <font color="#4169E1">for</font>(int s = 0, offset = 0; s &lt; SellCountA; s++) {
<a name="line902">902: </a>          SellConesSizesA[s] = 0;

<a name="line904">904: </a>          <font color="#4169E1">for</font>(int m = 0; m &lt; SellSizesA[s]; m++) {
<a name="line905">905: </a>            SellConesSizesA[s] += SellPointsA[offset+2];
<a name="line906">906: </a>            offset             += msgSize;
<a name="line907">907: </a>          }
<a name="line908">908: </a>          SellConesSizeA += SellConesSizesA[s];
<a name="line909">909: </a>        }
<a name="line910">910: </a>        <font color="#4169E1">for</font>(int s = 0, offset = 0; s &lt; SellCountB; s++) {
<a name="line911">911: </a>          SellConesSizesB[s] = 0;

<a name="line913">913: </a>          <font color="#4169E1">for</font>(int m = 0; m &lt; SellSizesB[s]; m++) {
<a name="line914">914: </a>            SellConesSizesB[s] += SellPointsB[offset+2];
<a name="line915">915: </a>            offset             += msgSize;
<a name="line916">916: </a>          }
<a name="line917">917: </a>          SellConesSizeB += SellConesSizesB[s];
<a name="line918">918: </a>        }

<a name="line920">920: </a>        <font color="#4169E1">for</font>(int b = 0, offset = 0; b &lt; BuyCountA; b++) {
<a name="line921">921: </a>          BuyConesSizesA[b] = 0;

<a name="line923">923: </a>          <font color="#4169E1">for</font>(int m = 0; m &lt; BuySizesA[b]; m++) {
<a name="line924">924: </a>            BuyConesSizesA[b] += BuyPointsA[offset+2];
<a name="line925">925: </a>            offset            += msgSize;
<a name="line926">926: </a>          }
<a name="line927">927: </a>          BuyConesSizeA += BuyConesSizesA[b];
<a name="line928">928: </a>        }
<a name="line929">929: </a>        <font color="#4169E1">for</font>(int b = 0, offset = 0; b &lt; BuyCountB; b++) {
<a name="line930">930: </a>          BuyConesSizesB[b] = 0;

<a name="line932">932: </a>          <font color="#4169E1">for</font>(int m = 0; m &lt; BuySizesB[b]; m++) {
<a name="line933">933: </a>            BuyConesSizesB[b] += BuyPointsB[offset+2];
<a name="line934">934: </a>            offset            += msgSize;
<a name="line935">935: </a>          }
<a name="line936">936: </a>          BuyConesSizeB += BuyConesSizesB[b];
<a name="line937">937: </a>        }

<a name="line939">939: </a>        int cMsgSize = 2;
<a name="line940">940: </a>        <A href="../../../../docs/manualpages/Sys/PetscMalloc2.html#PetscMalloc2">PetscMalloc2</A>(SellConesSizeA*cMsgSize,int32_t,&amp;SellConesA,SellConesSizeB*cMsgSize,int32_t,&amp;SellConesB);CHKERROR(ierr, <font color="#666666">"Error in <A href="../../../../docs/manualpages/Sys/PetscMalloc.html#PetscMalloc">PetscMalloc</A>"</font>);
<a name="line941">941: </a>        <font color="#4169E1">for</font>(int s = 0, offset = 0, cOffset = 0, SellConeSize = 0; s &lt; SellCountA; s++) {
<a name="line942">942: </a>          <font color="#4169E1">for</font>(int m = 0; m &lt; SellSizesA[s]; m++) {
<a name="line943">943: </a>            Point point(SellPointsA[offset],SellPointsA[offset+1]);

<a name="line945">945: </a>            <font color="#4169E1">for</font>(typename int_pair_set::iterator p_iter = BillOfSaleAtoB[point].begin(); p_iter != BillOfSaleAtoB[point].end(); ++p_iter) {
<a name="line946">946: </a>              SellConesA[cOffset+0] = (*p_iter).first;
<a name="line947">947: </a>              SellConesA[cOffset+1] = (*p_iter).second;
<a name="line948">948: </a>              cOffset += cMsgSize;
<a name="line949">949: </a>            }
<a name="line950">950: </a>            offset += msgSize;
<a name="line951">951: </a>          }
<a name="line952">952: </a>          <font color="#4169E1">if</font> (cOffset - cMsgSize*SellConeSize != cMsgSize*SellConesSizesA[s]) {
<a name="line953">953: </a>            throw ALE::Exception(<font color="#666666">"Nonmatching sizes"</font>);
<a name="line954">954: </a>          }
<a name="line955">955: </a>          SellConeSize += SellConesSizesA[s];
<a name="line956">956: </a>        }
<a name="line957">957: </a>        <font color="#4169E1">for</font>(int s = 0, offset = 0, cOffset = 0, SellConeSize = 0; s &lt; SellCountB; s++) {
<a name="line958">958: </a>          <font color="#4169E1">for</font>(int m = 0; m &lt; SellSizesB[s]; m++) {
<a name="line959">959: </a>            Point point(SellPointsB[offset],SellPointsB[offset+1]);

<a name="line961">961: </a>            <font color="#4169E1">for</font>(typename int_pair_set::iterator p_iter = BillOfSaleBtoA[point].begin(); p_iter != BillOfSaleBtoA[point].end(); ++p_iter) {
<a name="line962">962: </a>              SellConesB[cOffset+0] = (*p_iter).first;
<a name="line963">963: </a>              SellConesB[cOffset+1] = (*p_iter).second;
<a name="line964">964: </a>              cOffset += cMsgSize;
<a name="line965">965: </a>            }
<a name="line966">966: </a>            offset += msgSize;
<a name="line967">967: </a>          }
<a name="line968">968: </a>          <font color="#4169E1">if</font> (cOffset - cMsgSize*SellConeSize != cMsgSize*SellConesSizesB[s]) {
<a name="line969">969: </a>            throw ALE::Exception(<font color="#666666">"Nonmatching sizes"</font>);
<a name="line970">970: </a>          }
<a name="line971">971: </a>          SellConeSize += SellConesSizesB[s];
<a name="line972">972: </a>        }

<a name="line974">974: </a>        // Then send A buyers a (rank, cone size) <font color="#4169E1">for</font> all B buyers of the same points
<a name="line975">975: </a>        <A href="../../../../docs/manualpages/Sys/PetscObjectGetNewTag.html#PetscObjectGetNewTag">PetscObjectGetNewTag</A>(petscObj, &amp;tag5);CHKERROR(ierr, <font color="#666666">"Failed on <A href="../../../../docs/manualpages/Sys/PetscObjectGetNewTag.html#PetscObjectGetNewTag">PetscObjectGetNewTag</A>"</font>);
<a name="line976">976: </a>        commCycle(comm, tag5, cMsgSize, SellCountA, SellConesSizesA, BuyersA, SellConesA, BuyCountA, BuyConesSizesA, SellersA, &amp;overlapInfoA);
<a name="line977">977: </a>        <A href="../../../../docs/manualpages/Sys/PetscObjectGetNewTag.html#PetscObjectGetNewTag">PetscObjectGetNewTag</A>(petscObj, &amp;tag6);CHKERROR(ierr, <font color="#666666">"Failed on <A href="../../../../docs/manualpages/Sys/PetscObjectGetNewTag.html#PetscObjectGetNewTag">PetscObjectGetNewTag</A>"</font>);
<a name="line978">978: </a>        commCycle(comm, tag6, cMsgSize, SellCountB, SellConesSizesB, BuyersB, SellConesB, BuyCountB, BuyConesSizesB, SellersB, &amp;overlapInfoB);

<a name="line980">980: </a>        // Finally build the A--&gt;B overlap sifter
<a name="line981">981: </a>        //   (remote rank) ---(base A overlap point, remote cone size, local cone size)---&gt; (base A overlap point)
<a name="line982">982: </a>        <font color="#4169E1">for</font>(int b = 0, offset = 0, cOffset = 0; b &lt; BuyCountA; b++) {
<a name="line983">983: </a>          <font color="#4169E1">for</font>(int m = 0; m &lt; BuySizesA[b]; m++) {
<a name="line984">984: </a>            Point p(BuyPointsA[offset],BuyPointsA[offset+1]);

<a name="line986">986: </a>            <font color="#4169E1">for</font>(int n = 0; n &lt; BuyPointsA[offset+2]; n++) {
<a name="line987">987: </a>              int neighbor = overlapInfoA[cOffset+0];
<a name="line988">988: </a>              int coneSize = overlapInfoA[cOffset+1];

<a name="line990">990: </a>              // Record the point, size of the cone over p coming in from neighbor, and going out to the neighbor <font color="#4169E1">for</font> the arrow color
<a name="line991">991: </a>              overlap-&gt;addArrow(neighbor, ALE::pair&lt;int,Point&gt;(0, p), ALE::pair&lt;Point,ALE::pair&lt;int,int&gt; &gt;(p, ALE::pair&lt;int,int&gt;(coneSize, _graphA-&gt;cone(p)-&gt;size())) );
<a name="line992">992: </a>              cOffset += cMsgSize;
<a name="line993">993: </a>            }
<a name="line994">994: </a>            offset += msgSize;
<a name="line995">995: </a>          }
<a name="line996">996: </a>        }

<a name="line998">998: </a>        // Finally build the B--&gt;A overlap sifter
<a name="line999">999: </a>        //   (remote rank) ---(base B overlap point, remote cone size, local cone size)---&gt; (base B overlap point)
<a name="line1000">1000: </a>        <font color="#4169E1">for</font>(int b = 0, offset = 0, cOffset = 0; b &lt; BuyCountB; b++) {
<a name="line1001">1001: </a>          <font color="#4169E1">for</font>(int m = 0; m &lt; BuySizesB[b]; m++) {
<a name="line1002">1002: </a>            Point p(BuyPointsB[offset],BuyPointsB[offset+1]);

<a name="line1004">1004: </a>            <font color="#4169E1">for</font>(int n = 0; n &lt; BuyPointsB[offset+2]; n++) {
<a name="line1005">1005: </a>              int neighbor = overlapInfoB[cOffset+0];
<a name="line1006">1006: </a>              int coneSize = overlapInfoB[cOffset+1];

<a name="line1008">1008: </a>              // Record the point, size of the cone over p coming in from neighbor, and going out to the neighbor <font color="#4169E1">for</font> the arrow color
<a name="line1009">1009: </a>              overlap-&gt;addArrow(neighbor, ALE::pair&lt;int,Point&gt;(1, p), ALE::pair&lt;Point,ALE::pair&lt;int,int&gt; &gt;(p, ALE::pair&lt;int,int&gt;(coneSize, _graphB-&gt;cone(p)-&gt;size())) );
<a name="line1010">1010: </a>              cOffset += cMsgSize;
<a name="line1011">1011: </a>            }
<a name="line1012">1012: </a>            offset += msgSize;
<a name="line1013">1013: </a>          }
<a name="line1014">1014: </a>        }
<a name="line1015">1015: </a>      }; // __pullbackAtlases()

<a name="line1017">1017: </a><strong><font color="#FF0000">    public:</font></strong>
<a name="line1018">1018: </a>    }; // class Overlap

<a name="line1020">1020: </a>    template &lt;typename Data_, typename Map_, typename Overlap_, typename Fusion_&gt;
<a name="line1021">1021: </a>    class ParMap { // class ParMap
<a name="line1022">1022: </a><strong><font color="#FF0000">    public:</font></strong>
<a name="line1023">1023: </a>      //
<a name="line1024">1024: </a>      // Encapsulated types
<a name="line1025">1025: </a>      //
<a name="line1026">1026: </a>      //  Overlap is an object that encapsulates GatherAtlas &amp; ScatterAtlas objects, <font color="#4169E1">while</font> Fusion encapsulates and the corresponding
<a name="line1027">1027: </a>      // Gather &amp; Scatter map objects. The idea is that Gather &amp; Scatter depend on the structure of the corresponding atlases, but
<a name="line1028">1028: </a>      // <font color="#4169E1">do</font> not necessarily control their construction.  Therefore the two types of objects and/or their constructors can be overloaded
<a name="line1029">1029: </a>      // separately.
<a name="line1030">1030: </a>      //  For convenience Overlap encapsulates the data it is constructed from: two atlases, InAtlas and OutAtlas, and Lightcone,
<a name="line1031">1031: </a>      // which is a Sifter.
<a name="line1032">1032: </a>      // InAtlas refers to the input Sec (the argument of the ParMap), <font color="#4169E1">while</font> OutAtlas refers to the output Sec (the result of ParMap).
<a name="line1033">1033: </a>      // InAtlas_ and OutAtlas_ have arrows from points to charts decorated with indices into Data_ storage of the input/output Sec
<a name="line1034">1034: </a>      // respectively.
<a name="line1035">1035: </a>      //  GatherAtlas is an Atlas lifting InAtlas into a rank-indexed covering by overlaps with remote processes.
<a name="line1036">1036: </a>      // The overlap is computed accroding to Lightcone, which connects the charts of OutAtlas_ to InAtlas_, which implies the two
<a name="line1037">1037: </a>      // atlases have charts of the same type.  The idea is that data dependencies are initially expressed at the chart level;
<a name="line1038">1038: </a>      // a refinement of this can be achieved by subclassing (or implementing a new) GatherAtlas.
<a name="line1039">1039: </a>      //  Gather is  a Map that reduce a Sec over GatherAtlas with data over each ((in_point,in_chart),rank) pair to a Sec over InAtlas,
<a name="line1040">1040: </a>      // with data over each (in_point, in_chart) pair.  Scatter maps in the opposite direction by <font color="#666666">"multiplexing"</font> the data onto a
<a name="line1041">1041: </a>      // rank-indexed covering.
<a name="line1042">1042: </a>      //  Map is a Map sending an InAtlas Sec obtained from Gather, into an OutAtlas Sec.
<a name="line1043">1043: </a>      //
<a name="line1044">1044: </a>      <font color="#4169E1">typedef</font> Data_                                            data_type;
<a name="line1045">1045: </a>      <font color="#4169E1">typedef</font> Overlap_                                         overlap_type;
<a name="line1046">1046: </a>      <font color="#4169E1">typedef</font> typename overlap_type::in_atlas_type             in_atlas_type;
<a name="line1047">1047: </a>      <font color="#4169E1">typedef</font> typename overlap_type::out_atlas_type            out_atlas_type;
<a name="line1048">1048: </a>      <font color="#4169E1">typedef</font> typename lightcone_type::out_atlas_type          lightcone_type;
<a name="line1049">1049: </a>      //
<a name="line1050">1050: </a>      <font color="#4169E1">typedef</font> Fusion_                                          fusion_type;
<a name="line1051">1051: </a>      <font color="#4169E1">typedef</font> typename fusion_type::gather_type                gather_type;
<a name="line1052">1052: </a>      <font color="#4169E1">typedef</font> typename fusion_type::scatter_type               scatter_type;
<a name="line1053">1053: </a>      <font color="#4169E1">typedef</font> Map_                                             map_type;
<a name="line1054">1054: </a>      //
<a name="line1055">1055: </a><strong><font color="#FF0000">    protected:</font></strong>
<a name="line1056">1056: </a>      int                             _debug;
<a name="line1057">1057: </a>      //
<a name="line1058">1058: </a>      Obj&lt;map_type&gt;                   _map;
<a name="line1059">1059: </a>      Obj&lt;overlap_type&gt;               _overlap_type;
<a name="line1060">1060: </a>      Obj&lt;fusion_type&gt;                _fusion;
<a name="line1061">1061: </a><strong><font color="#FF0000">    protected:</font></strong>
<a name="line1062">1062: </a>      void __init(<A href="../../../../docs/manualpages/Sys/MPI_Comm.html#MPI_Comm">MPI_Comm</A> comm) {
<a name="line1064">1064: </a>        this-&gt;_comm = comm;
<a name="line1065">1065: </a>        <A href="http://www.mcs.anl.gov/mpi/www/www3/MPI_Comm_rank.html#MPI_Comm_rank">MPI_Comm_rank</A>(this-&gt;_comm, &amp;this-&gt;_commRank);CHKERROR(ierr, <font color="#666666">"Error in <A href="http://www.mcs.anl.gov/mpi/www/www3/MPI_Comm_rank.html#MPI_Comm_rank">MPI_Comm_rank</A>"</font>);
<a name="line1066">1066: </a>        <A href="http://www.mcs.anl.gov/mpi/www/www3/MPI_Comm_size.html#MPI_Comm_size">MPI_Comm_size</A>(this-&gt;_comm, &amp;this-&gt;_commSize);CHKERROR(ierr, <font color="#666666">"Error in <A href="http://www.mcs.anl.gov/mpi/www/www3/MPI_Comm_rank.html#MPI_Comm_rank">MPI_Comm_rank</A>"</font>);
<a name="line1067">1067: </a>      };
<a name="line1068">1068: </a><strong><font color="#FF0000">    public:</font></strong>
<a name="line1069">1069: </a>      //
<a name="line1070">1070: </a>      // Basic interface
<a name="line1071">1071: </a>      //
<a name="line1072">1072: </a>      ParMap(const Obj&lt;map_type&gt;&amp; map, const Obj&lt;overlap_type&gt;&amp; overlap, const Obj&lt;fusion_type&gt;&amp; fusion)
<a name="line1073">1073: </a>        : _debug(0), _map(map), _overlap(overlap), _fusion(fusion) {};
<a name="line1074">1074: </a>     ~ParMap(){};
<a name="line1075">1075: </a>      //
<a name="line1076">1076: </a>      // Extended interface
<a name="line1077">1077: </a>      //
<a name="line1078">1078: </a>      int  getDebug() {<font color="#4169E1">return</font> this-&gt;_debug;}
<a name="line1079">1079: </a>      void setDebug(const int&amp; d) {this-&gt;_debug = d;};
<a name="line1080">1080: </a>      <A href="../../../../docs/manualpages/Sys/MPI_Comm.html#MPI_Comm">MPI_Comm</A> comm() {<font color="#4169E1">return</font> this-&gt;_comm;};
<a name="line1081">1081: </a>      MPI_Int  commRank() {<font color="#4169E1">return</font> this-&gt;_commRank;};
<a name="line1082">1082: </a>      MPI_Int  commSize() {<font color="#4169E1">return</font> this-&gt;_commSize;};
<a name="line1083">1083: </a>    }; // class ParMap
<a name="line1084">1084: </a>

<a name="line1086">1086: </a>} // namespace X
<a name="line1087">1087: </a>} // namespace ALE

<a name="line1089">1089: </a><font color="#A020F0">#endif</font>
</pre>
</body>

</html>
