<center><a href="Selection.hh">Actual source code: Selection.hh</a></center><br>

<html>
<head>
<title></title>
<meta name="generator" content="c2html 0.9.5">
<meta name="date" content="2011-03-17T19:15:33+00:00">
</head>

<body bgcolor="#FFFFFF">
<pre width="80"><a name="line1">  1: </a><font color="#A020F0">#ifndef included_ALE_Selection_hh</font>
<a name="line2">  2: </a><strong><font color="#228B22">#define included_ALE_Selection_hh</font></strong>

<a name="line4">  4: </a><font color="#A020F0">#ifndef  included_ALE_SieveAlgorithms_hh</font>
<a name="line5">  5: </a><font color="#A020F0">#include &lt;SieveAlgorithms.hh&gt;</font>
<a name="line6">  6: </a><font color="#A020F0">#endif</font>

<a name="line8">  8: </a><font color="#A020F0">#ifndef  included_ALE_SieveBuilder_hh</font>
<a name="line9">  9: </a><font color="#A020F0">#include &lt;SieveBuilder.hh&gt;</font>
<a name="line10"> 10: </a><font color="#A020F0">#endif</font>

<a name="line12"> 12: </a>namespace ALE {
<a name="line13"> 13: </a>  template&lt;typename Mesh_&gt;
<a name="line14"> 14: </a>  class Selection {
<a name="line15"> 15: </a><strong><font color="#FF0000">  public:</font></strong>
<a name="line16"> 16: </a>    <font color="#4169E1">typedef</font> Mesh_                                mesh_type;
<a name="line17"> 17: </a>    <font color="#4169E1">typedef</font> typename mesh_type::sieve_type       sieve_type;
<a name="line18"> 18: </a>    <font color="#4169E1">typedef</font> typename mesh_type::point_type       point_type;
<a name="line19"> 19: </a>    <font color="#4169E1">typedef</font> typename mesh_type::int_section_type int_section_type;
<a name="line20"> 20: </a>    <font color="#4169E1">typedef</font> std::set&lt;point_type&gt;                 PointSet;
<a name="line21"> 21: </a>    <font color="#4169E1">typedef</font> std::vector&lt;point_type&gt;              PointArray;
<a name="line22"> 22: </a>    <font color="#4169E1">typedef</font> std::pair&lt;typename sieve_type::point_type, int&gt; oPoint_type;
<a name="line23"> 23: </a>    <font color="#4169E1">typedef</font> std::vector&lt;oPoint_type&gt;                        oPointArray;
<a name="line24"> 24: </a>    <font color="#4169E1">typedef</font> typename ALE::SieveAlg&lt;mesh_type&gt;    sieveAlg;
<a name="line25"> 25: </a><strong><font color="#FF0000">  protected:</font></strong>
<a name="line26"> 26: </a>    template&lt;typename Sieve, typename FaceType&gt;
<a name="line27"> 27: </a>    class FaceVisitor {
<a name="line28"> 28: </a><strong><font color="#FF0000">    public:</font></strong>
<a name="line29"> 29: </a>      <font color="#4169E1">typedef</font> typename Sieve::point_type point_type;
<a name="line30"> 30: </a>      <font color="#4169E1">typedef</font> typename Sieve::arrow_type arrow_type;
<a name="line31"> 31: </a><strong><font color="#FF0000">    protected:</font></strong>
<a name="line32"> 32: </a>      const FaceType&amp; face;
<a name="line33"> 33: </a>      PointArray&amp;     origVertices;
<a name="line34"> 34: </a>      PointArray&amp;     faceVertices;
<a name="line35"> 35: </a>      int            *indices;
<a name="line36"> 36: </a>      const int       debug;
<a name="line37"> 37: </a>      int             oppositeVertex;
<a name="line38"> 38: </a>      int             v;
<a name="line39"> 39: </a><strong><font color="#FF0000">    public:</font></strong>
<a name="line40"> 40: </a>      FaceVisitor(const FaceType&amp; f, PointArray&amp; oV, PointArray&amp; fV, int *i, const int debug) : face(f), origVertices(oV), faceVertices(fV), indices(i), debug(debug), oppositeVertex(-1), v(0) {};
<a name="line41"> 41: </a>      void visitPoint(const point_type&amp; point) {
<a name="line42"> 42: </a>        <font color="#4169E1">if</font> (face-&gt;find(point) != face-&gt;end()) {
<a name="line43"> 43: </a>          <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"    vertex "</font> &lt;&lt; point &lt;&lt; std::endl;
<a name="line44"> 44: </a>          indices[origVertices.size()] = v;
<a name="line45"> 45: </a>          origVertices.insert(origVertices.end(), point);
<a name="line46"> 46: </a>        } <font color="#4169E1">else</font> {
<a name="line47"> 47: </a>          <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"    vertex "</font> &lt;&lt; point &lt;&lt; std::endl;
<a name="line48"> 48: </a>          oppositeVertex = v;
<a name="line49"> 49: </a>        }
<a name="line50"> 50: </a>        ++v;
<a name="line51"> 51: </a>      };
<a name="line52"> 52: </a>      void visitArrow(const arrow_type&amp;) {};
<a name="line53"> 53: </a><strong><font color="#FF0000">    public:</font></strong>
<a name="line54"> 54: </a>      int getOppositeVertex() {<font color="#4169E1">return</font> this-&gt;oppositeVertex;};
<a name="line55"> 55: </a>    };
<a name="line56"> 56: </a><strong><font color="#FF0000">  public:</font></strong>
<a name="line57"> 57: </a>    template&lt;typename Processor&gt;
<a name="line58"> 58: </a>    static void subsets(const PointArray&amp; v, const int size, Processor&amp; processor, Obj&lt;PointArray&gt; *out = NULL, const int min = 0) {
<a name="line59"> 59: </a>      <font color="#4169E1">if</font> (size == 0) {
<a name="line60"> 60: </a>        processor(*out);
<a name="line61"> 61: </a>        <font color="#4169E1">return</font>;
<a name="line62"> 62: </a>      }
<a name="line63"> 63: </a>      <font color="#4169E1">if</font> (min == 0) {
<a name="line64"> 64: </a>        out  = new Obj&lt;PointArray&gt;();
<a name="line65"> 65: </a>        *out = new PointArray();
<a name="line66"> 66: </a>      }
<a name="line67"> 67: </a>      <font color="#4169E1">for</font>(int i = min; i &lt; (int) v.size(); ++i) {
<a name="line68"> 68: </a>        (*out)-&gt;push_back(v[i]);
<a name="line69"> 69: </a>        subsets(v, size-1, processor, out, i+1);
<a name="line70"> 70: </a>        (*out)-&gt;pop_back();
<a name="line71"> 71: </a>      }
<a name="line72"> 72: </a>      <font color="#4169E1">if</font> (min == 0) {delete out;}
<a name="line73"> 73: </a>    };
<a name="line74"> 74: </a>    template&lt;typename Mesh&gt;
<a name="line75"> 75: </a>    static int numFaceVertices(const Obj&lt;Mesh&gt;&amp; mesh) {
<a name="line76"> 76: </a>      <font color="#4169E1">return</font> numFaceVertices(mesh, mesh-&gt;getNumCellCorners());
<a name="line77"> 77: </a>    };
<a name="line78"> 78: </a>    template&lt;typename Mesh&gt;
<a name="line79"> 79: </a>    static int numFaceVertices(const Obj&lt;Mesh&gt;&amp; mesh, const unsigned int numCorners) {
<a name="line80"> 80: </a>      //unsigned int numCorners = mesh-&gt;getNumCellCorners(cell, depth);
<a name="line81"> 81: </a>      const    int cellDim          = mesh-&gt;getDimension();
<a name="line82"> 82: </a>      unsigned int _numFaceVertices = 0;

<a name="line84"> 84: </a>      <font color="#4169E1">switch</font> (cellDim) {
<a name="line85"> 85: </a>      <font color="#4169E1">case</font> 0 :
<a name="line86"> 86: </a>        _numFaceVertices = 0;
<a name="line87"> 87: </a>        <font color="#4169E1">break</font>;
<a name="line88"> 88: </a>      <font color="#4169E1">case</font> 1 :
<a name="line89"> 89: </a>        _numFaceVertices = 1;
<a name="line90"> 90: </a>        <font color="#4169E1">break</font>;
<a name="line91"> 91: </a>      <font color="#4169E1">case</font> 2:
<a name="line92"> 92: </a>        <font color="#4169E1">switch</font> (numCorners) {
<a name="line93"> 93: </a>        <font color="#4169E1">case</font> 3 : // triangle
<a name="line94"> 94: </a>          _numFaceVertices = 2; // Edge has 2 vertices
<a name="line95"> 95: </a>          <font color="#4169E1">break</font>;
<a name="line96"> 96: </a>        <font color="#4169E1">case</font> 4 : // quadrilateral
<a name="line97"> 97: </a>          _numFaceVertices = 2; // Edge has 2 vertices
<a name="line98"> 98: </a>          <font color="#4169E1">break</font>;
<a name="line99"> 99: </a>        <font color="#4169E1">default</font> :
<a name="line100">100: </a>          throw ALE::Exception(<font color="#666666">"Invalid number of face corners"</font>);
<a name="line101">101: </a>        }
<a name="line102">102: </a>        <font color="#4169E1">break</font>;
<a name="line103">103: </a>      <font color="#4169E1">case</font> 3:
<a name="line104">104: </a>        <font color="#4169E1">switch</font> (numCorners)        {
<a name="line105">105: </a>        <font color="#4169E1">case</font> 4 : // tetradehdron
<a name="line106">106: </a>          _numFaceVertices = 3; // Face has 3 vertices
<a name="line107">107: </a>          <font color="#4169E1">break</font>;
<a name="line108">108: </a>        <font color="#4169E1">case</font> 8 : // hexahedron
<a name="line109">109: </a>          _numFaceVertices = 4; // Face has 4 vertices
<a name="line110">110: </a>          <font color="#4169E1">break</font>;
<a name="line111">111: </a>        <font color="#4169E1">default</font> :
<a name="line112">112: </a>          throw ALE::Exception(<font color="#666666">"Invalid number of face corners"</font>);
<a name="line113">113: </a>        }
<a name="line114">114: </a>        <font color="#4169E1">break</font>;
<a name="line115">115: </a><strong><font color="#FF0000">      default:</font></strong>
<a name="line116">116: </a>        throw ALE::Exception(<font color="#666666">"Invalid cell dimension"</font>);
<a name="line117">117: </a>      }
<a name="line118">118: </a>      <font color="#4169E1">return</font> _numFaceVertices;
<a name="line119">119: </a>    };
<a name="line120">120: </a>    // We need this method because we <font color="#4169E1">do</font> not use interpolated sieves
<a name="line121">121: </a>    //   - Without interpolation, we cannot say what vertex collections are
<a name="line122">122: </a>    //     faces, and how they are oriented
<a name="line123">123: </a>    //   - Now we read off the list of face vertices IN THE ORDER IN WHICH
<a name="line124">124: </a>    //     THEY APPEAR IN THE CELL
<a name="line125">125: </a>    //   - This leads to simple algorithms <font color="#4169E1">for</font> simplices and quads to check
<a name="line126">126: </a>    //     orientation since these sets are always valid faces
<a name="line127">127: </a>    //   - This is not true with hexes, so we just sort and check explicit cases
<a name="line128">128: </a>    //   - This means <font color="#4169E1">for</font> hexes that we have to alter the vertex container as well
<a name="line129">129: </a>    template&lt;typename Mesh&gt;
<a name="line130">130: </a>    static bool faceOrientation(const point_type&amp; cell, const Obj&lt;Mesh&gt;&amp; mesh, const int numCorners,
<a name="line131">131: </a>                                const int indices[], const int oppositeVertex, PointArray *origVertices, PointArray *faceVertices) {
<a name="line132">132: </a>      const int cellDim   = mesh-&gt;getDimension();
<a name="line133">133: </a>      const int debug     = mesh-&gt;debug();
<a name="line134">134: </a>      bool      posOrient = false;

<a name="line136">136: </a>      // Simplices
<a name="line137">137: </a>      <font color="#4169E1">if</font> (cellDim == numCorners-1) {
<a name="line138">138: </a>        posOrient = !(oppositeVertex%2);
<a name="line139">139: </a>      } <font color="#4169E1">else</font> <font color="#4169E1">if</font> (cellDim == 2) {
<a name="line140">140: </a>        // Quads
<a name="line141">141: </a>        <font color="#4169E1">if</font> ((indices[1] &gt; indices[0]) &amp;&amp; (indices[1] - indices[0] == 1)) {
<a name="line142">142: </a>          posOrient = true;
<a name="line143">143: </a>        } <font color="#4169E1">else</font> <font color="#4169E1">if</font> ((indices[0] == 3) &amp;&amp; (indices[1] == 0)) {
<a name="line144">144: </a>          posOrient = true;
<a name="line145">145: </a>        } <font color="#4169E1">else</font> {
<a name="line146">146: </a>          <font color="#4169E1">if</font> (((indices[0] &gt; indices[1]) &amp;&amp; (indices[0] - indices[1] == 1)) || ((indices[0] == 0) &amp;&amp; (indices[1] == 3))) {
<a name="line147">147: </a>            posOrient = false;
<a name="line148">148: </a>          } <font color="#4169E1">else</font> {
<a name="line149">149: </a>            throw ALE::Exception(<font color="#666666">"Invalid quad crossedge"</font>);
<a name="line150">150: </a>          }
<a name="line151">151: </a>        }
<a name="line152">152: </a>      } <font color="#4169E1">else</font> <font color="#4169E1">if</font> (cellDim == 3) {
<a name="line153">153: </a>        // Hexes
<a name="line154">154: </a>        //   A hex is two oriented quads with the normal of the first
<a name="line155">155: </a>        //   pointing up at the second.
<a name="line156">156: </a>        //
<a name="line157">157: </a>        //     7---6
<a name="line158">158: </a>        //    /|  /|
<a name="line159">159: </a>        //   4---5 |
<a name="line160">160: </a>        //   | 3-|-2
<a name="line161">161: </a>        //   |/  |/
<a name="line162">162: </a>        //   0---1
<a name="line163">163: </a>        int  sortedIndices[4];
<a name="line164">164: </a>        bool found = false;

<a name="line166">166: </a>        <font color="#4169E1">for</font>(int i = 0; i &lt; 4; ++i) sortedIndices[i] = indices[i];
<a name="line167">167: </a><strong><font color="#FF0000">        std:</font></strong>:sort(sortedIndices, sortedIndices+4);
<a name="line168">168: </a>        // Case 1: Bottom quad
<a name="line169">169: </a>        <font color="#4169E1">if</font> ((sortedIndices[0] == 0) &amp;&amp; (sortedIndices[1] == 1) &amp;&amp; (sortedIndices[2] == 2) &amp;&amp; (sortedIndices[3] == 3)) {
<a name="line170">170: </a>          <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"Bottom quad"</font> &lt;&lt; std::endl;
<a name="line171">171: </a>          <font color="#4169E1">for</font>(int i = 0; i &lt; 4; ++i) {
<a name="line172">172: </a>            <font color="#4169E1">if</font> (indices[i] == 3) {
<a name="line173">173: </a>              faceVertices-&gt;push_back((*origVertices)[i]); <font color="#4169E1">break</font>;
<a name="line174">174: </a>            }
<a name="line175">175: </a>          }
<a name="line176">176: </a>          <font color="#4169E1">for</font>(int i = 0; i &lt; 4; ++i) {
<a name="line177">177: </a>            <font color="#4169E1">if</font> (indices[i] == 2) {
<a name="line178">178: </a>              faceVertices-&gt;push_back((*origVertices)[i]); <font color="#4169E1">break</font>;
<a name="line179">179: </a>            }
<a name="line180">180: </a>          }
<a name="line181">181: </a>          <font color="#4169E1">for</font>(int i = 0; i &lt; 4; ++i) {
<a name="line182">182: </a>            <font color="#4169E1">if</font> (indices[i] == 1) {
<a name="line183">183: </a>              faceVertices-&gt;push_back((*origVertices)[i]); <font color="#4169E1">break</font>;
<a name="line184">184: </a>            }
<a name="line185">185: </a>          }
<a name="line186">186: </a>          <font color="#4169E1">for</font>(int i = 0; i &lt; 4; ++i) {
<a name="line187">187: </a>            <font color="#4169E1">if</font> (indices[i] == 0) {
<a name="line188">188: </a>              faceVertices-&gt;push_back((*origVertices)[i]); <font color="#4169E1">break</font>;
<a name="line189">189: </a>            }
<a name="line190">190: </a>          }
<a name="line191">191: </a>          found = true;
<a name="line192">192: </a>        }
<a name="line193">193: </a>        // Case 2: Top quad
<a name="line194">194: </a>        <font color="#4169E1">if</font> ((sortedIndices[0] == 4) &amp;&amp; (sortedIndices[1] == 5) &amp;&amp; (sortedIndices[2] == 6) &amp;&amp; (sortedIndices[3] == 7)) {
<a name="line195">195: </a>          <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"Top quad"</font> &lt;&lt; std::endl;
<a name="line196">196: </a>          <font color="#4169E1">for</font>(int i = 0; i &lt; 4; ++i) {
<a name="line197">197: </a>            <font color="#4169E1">if</font> (indices[i] == 5) {
<a name="line198">198: </a>              faceVertices-&gt;push_back((*origVertices)[i]); <font color="#4169E1">break</font>;
<a name="line199">199: </a>            }
<a name="line200">200: </a>          }
<a name="line201">201: </a>          <font color="#4169E1">for</font>(int i = 0; i &lt; 4; ++i) {
<a name="line202">202: </a>            <font color="#4169E1">if</font> (indices[i] == 6) {
<a name="line203">203: </a>              faceVertices-&gt;push_back((*origVertices)[i]); <font color="#4169E1">break</font>;
<a name="line204">204: </a>            }
<a name="line205">205: </a>          }
<a name="line206">206: </a>          <font color="#4169E1">for</font>(int i = 0; i &lt; 4; ++i) {
<a name="line207">207: </a>            <font color="#4169E1">if</font> (indices[i] == 7) {
<a name="line208">208: </a>              faceVertices-&gt;push_back((*origVertices)[i]); <font color="#4169E1">break</font>;
<a name="line209">209: </a>            }
<a name="line210">210: </a>          }
<a name="line211">211: </a>          <font color="#4169E1">for</font>(int i = 0; i &lt; 4; ++i) {
<a name="line212">212: </a>            <font color="#4169E1">if</font> (indices[i] == 4) {
<a name="line213">213: </a>              faceVertices-&gt;push_back((*origVertices)[i]); <font color="#4169E1">break</font>;
<a name="line214">214: </a>            }
<a name="line215">215: </a>          }
<a name="line216">216: </a>          found = true;
<a name="line217">217: </a>        }
<a name="line218">218: </a>        // Case 3: Front quad
<a name="line219">219: </a>        <font color="#4169E1">if</font> ((sortedIndices[0] == 0) &amp;&amp; (sortedIndices[1] == 1) &amp;&amp; (sortedIndices[2] == 4) &amp;&amp; (sortedIndices[3] == 5)) {
<a name="line220">220: </a>          <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"Front quad"</font> &lt;&lt; std::endl;
<a name="line221">221: </a>          <font color="#4169E1">for</font>(int i = 0; i &lt; 4; ++i) {
<a name="line222">222: </a>            <font color="#4169E1">if</font> (indices[i] == 1) {
<a name="line223">223: </a>              faceVertices-&gt;push_back((*origVertices)[i]); <font color="#4169E1">break</font>;
<a name="line224">224: </a>            }
<a name="line225">225: </a>          }
<a name="line226">226: </a>          <font color="#4169E1">for</font>(int i = 0; i &lt; 4; ++i) {
<a name="line227">227: </a>            <font color="#4169E1">if</font> (indices[i] == 5) {
<a name="line228">228: </a>              faceVertices-&gt;push_back((*origVertices)[i]); <font color="#4169E1">break</font>;
<a name="line229">229: </a>            }
<a name="line230">230: </a>          }
<a name="line231">231: </a>          <font color="#4169E1">for</font>(int i = 0; i &lt; 4; ++i) {
<a name="line232">232: </a>            <font color="#4169E1">if</font> (indices[i] == 4) {
<a name="line233">233: </a>              faceVertices-&gt;push_back((*origVertices)[i]); <font color="#4169E1">break</font>;
<a name="line234">234: </a>            }
<a name="line235">235: </a>          }
<a name="line236">236: </a>          <font color="#4169E1">for</font>(int i = 0; i &lt; 4; ++i) {
<a name="line237">237: </a>            <font color="#4169E1">if</font> (indices[i] == 0) {
<a name="line238">238: </a>              faceVertices-&gt;push_back((*origVertices)[i]); <font color="#4169E1">break</font>;
<a name="line239">239: </a>            }
<a name="line240">240: </a>          }
<a name="line241">241: </a>          found = true;
<a name="line242">242: </a>        }
<a name="line243">243: </a>        // Case 4: Back quad
<a name="line244">244: </a>        <font color="#4169E1">if</font> ((sortedIndices[0] == 2) &amp;&amp; (sortedIndices[1] == 3) &amp;&amp; (sortedIndices[2] == 6) &amp;&amp; (sortedIndices[3] == 7)) {
<a name="line245">245: </a>          <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"Back quad"</font> &lt;&lt; std::endl;
<a name="line246">246: </a>          <font color="#4169E1">for</font>(int i = 0; i &lt; 4; ++i) {
<a name="line247">247: </a>            <font color="#4169E1">if</font> (indices[i] == 7) {
<a name="line248">248: </a>              faceVertices-&gt;push_back((*origVertices)[i]); <font color="#4169E1">break</font>;
<a name="line249">249: </a>            }
<a name="line250">250: </a>          }
<a name="line251">251: </a>          <font color="#4169E1">for</font>(int i = 0; i &lt; 4; ++i) {
<a name="line252">252: </a>            <font color="#4169E1">if</font> (indices[i] == 6) {
<a name="line253">253: </a>              faceVertices-&gt;push_back((*origVertices)[i]); <font color="#4169E1">break</font>;
<a name="line254">254: </a>            }
<a name="line255">255: </a>          }
<a name="line256">256: </a>          <font color="#4169E1">for</font>(int i = 0; i &lt; 4; ++i) {
<a name="line257">257: </a>            <font color="#4169E1">if</font> (indices[i] == 2) {
<a name="line258">258: </a>              faceVertices-&gt;push_back((*origVertices)[i]); <font color="#4169E1">break</font>;
<a name="line259">259: </a>            }
<a name="line260">260: </a>          }
<a name="line261">261: </a>          <font color="#4169E1">for</font>(int i = 0; i &lt; 4; ++i) {
<a name="line262">262: </a>            <font color="#4169E1">if</font> (indices[i] == 3) {
<a name="line263">263: </a>              faceVertices-&gt;push_back((*origVertices)[i]); <font color="#4169E1">break</font>;
<a name="line264">264: </a>            }
<a name="line265">265: </a>          }
<a name="line266">266: </a>          found = true;
<a name="line267">267: </a>        }
<a name="line268">268: </a>        // Case 5: Right quad
<a name="line269">269: </a>        <font color="#4169E1">if</font> ((sortedIndices[0] == 1) &amp;&amp; (sortedIndices[1] == 2) &amp;&amp; (sortedIndices[2] == 5) &amp;&amp; (sortedIndices[3] == 6)) {
<a name="line270">270: </a>          <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"Right quad"</font> &lt;&lt; std::endl;
<a name="line271">271: </a>          <font color="#4169E1">for</font>(int i = 0; i &lt; 4; ++i) {
<a name="line272">272: </a>            <font color="#4169E1">if</font> (indices[i] == 2) {
<a name="line273">273: </a>              faceVertices-&gt;push_back((*origVertices)[i]); <font color="#4169E1">break</font>;
<a name="line274">274: </a>            }
<a name="line275">275: </a>          }
<a name="line276">276: </a>          <font color="#4169E1">for</font>(int i = 0; i &lt; 4; ++i) {
<a name="line277">277: </a>            <font color="#4169E1">if</font> (indices[i] == 6) {
<a name="line278">278: </a>              faceVertices-&gt;push_back((*origVertices)[i]); <font color="#4169E1">break</font>;
<a name="line279">279: </a>            }
<a name="line280">280: </a>          }
<a name="line281">281: </a>          <font color="#4169E1">for</font>(int i = 0; i &lt; 4; ++i) {
<a name="line282">282: </a>            <font color="#4169E1">if</font> (indices[i] == 5) {
<a name="line283">283: </a>              faceVertices-&gt;push_back((*origVertices)[i]); <font color="#4169E1">break</font>;
<a name="line284">284: </a>            }
<a name="line285">285: </a>          }
<a name="line286">286: </a>          <font color="#4169E1">for</font>(int i = 0; i &lt; 4; ++i) {
<a name="line287">287: </a>            <font color="#4169E1">if</font> (indices[i] == 1) {
<a name="line288">288: </a>              faceVertices-&gt;push_back((*origVertices)[i]); <font color="#4169E1">break</font>;
<a name="line289">289: </a>            }
<a name="line290">290: </a>          }
<a name="line291">291: </a>          found = true;
<a name="line292">292: </a>        }
<a name="line293">293: </a>        // Case 6: Left quad
<a name="line294">294: </a>        <font color="#4169E1">if</font> ((sortedIndices[0] == 0) &amp;&amp; (sortedIndices[1] == 3) &amp;&amp; (sortedIndices[2] == 4) &amp;&amp; (sortedIndices[3] == 7)) {
<a name="line295">295: </a>          <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"Left quad"</font> &lt;&lt; std::endl;
<a name="line296">296: </a>          <font color="#4169E1">for</font>(int i = 0; i &lt; 4; ++i) {
<a name="line297">297: </a>            <font color="#4169E1">if</font> (indices[i] == 4) {
<a name="line298">298: </a>              faceVertices-&gt;push_back((*origVertices)[i]); <font color="#4169E1">break</font>;
<a name="line299">299: </a>            }
<a name="line300">300: </a>          }
<a name="line301">301: </a>          <font color="#4169E1">for</font>(int i = 0; i &lt; 4; ++i) {
<a name="line302">302: </a>            <font color="#4169E1">if</font> (indices[i] == 7) {
<a name="line303">303: </a>              faceVertices-&gt;push_back((*origVertices)[i]); <font color="#4169E1">break</font>;
<a name="line304">304: </a>            }
<a name="line305">305: </a>          }
<a name="line306">306: </a>          <font color="#4169E1">for</font>(int i = 0; i &lt; 4; ++i) {
<a name="line307">307: </a>            <font color="#4169E1">if</font> (indices[i] == 3) {
<a name="line308">308: </a>              faceVertices-&gt;push_back((*origVertices)[i]); <font color="#4169E1">break</font>;
<a name="line309">309: </a>            }
<a name="line310">310: </a>          }
<a name="line311">311: </a>          <font color="#4169E1">for</font>(int i = 0; i &lt; 4; ++i) {
<a name="line312">312: </a>            <font color="#4169E1">if</font> (indices[i] == 0) {
<a name="line313">313: </a>              faceVertices-&gt;push_back((*origVertices)[i]); <font color="#4169E1">break</font>;
<a name="line314">314: </a>            }
<a name="line315">315: </a>          }
<a name="line316">316: </a>          found = true;
<a name="line317">317: </a>        }
<a name="line318">318: </a>        <font color="#4169E1">if</font> (!found) {throw ALE::Exception(<font color="#666666">"Invalid hex crossface"</font>);}
<a name="line319">319: </a>        <font color="#4169E1">return</font> true;
<a name="line320">320: </a>      }
<a name="line321">321: </a>      <font color="#4169E1">if</font> (!posOrient) {
<a name="line322">322: </a>        <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"  Reversing initial face orientation"</font> &lt;&lt; std::endl;
<a name="line323">323: </a>        faceVertices-&gt;insert(faceVertices-&gt;end(), (*origVertices).rbegin(), (*origVertices).rend());
<a name="line324">324: </a>      } <font color="#4169E1">else</font> {
<a name="line325">325: </a>        <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"  Keeping initial face orientation"</font> &lt;&lt; std::endl;
<a name="line326">326: </a>        faceVertices-&gt;insert(faceVertices-&gt;end(), (*origVertices).begin(), (*origVertices).end());
<a name="line327">327: </a>      }
<a name="line328">328: </a>      <font color="#4169E1">return</font> posOrient;
<a name="line329">329: </a>    };
<a name="line330">330: </a>    // Given a cell and a face, as a set of vertices,
<a name="line331">331: </a>    //   <font color="#4169E1">return</font> the oriented face, as a set of vertices, in faceVertices
<a name="line332">332: </a>    // The orientation is such that the face normal points out of the cell
<a name="line333">333: </a>    template&lt;typename Mesh, typename FaceType&gt;
<a name="line334">334: </a>    static bool getOrientedFace(const Obj&lt;Mesh&gt;&amp; mesh, const point_type&amp; cell, FaceType face,
<a name="line335">335: </a>                                const int numCorners, int indices[], PointArray *origVertices, PointArray *faceVertices)
<a name="line336">336: </a>    {
<a name="line337">337: </a>      FaceVisitor&lt;typename Mesh::sieve_type,FaceType&gt; v(face, *origVertices, *faceVertices, indices, mesh-&gt;debug());

<a name="line339">339: </a>      origVertices-&gt;clear();
<a name="line340">340: </a>      faceVertices-&gt;clear();
<a name="line341">341: </a>      mesh-&gt;getSieve()-&gt;cone(cell, v);
<a name="line342">342: </a>      <font color="#4169E1">return</font> faceOrientation(cell, mesh, numCorners, indices, v.getOppositeVertex(), origVertices, faceVertices);
<a name="line343">343: </a>    };
<a name="line344">344: </a>    template&lt;typename FaceType&gt;
<a name="line345">345: </a>    static bool getOrientedFace(const Obj&lt;ALE::Mesh&gt;&amp; mesh, const point_type&amp; cell, FaceType face,
<a name="line346">346: </a>                                const int numCorners, int indices[], PointArray *origVertices, PointArray *faceVertices)
<a name="line347">347: </a>    {
<a name="line348">348: </a>      const Obj&lt;typename ALE::Mesh::sieve_type::traits::coneSequence&gt;&amp; cone = mesh-&gt;getSieve()-&gt;cone(cell);
<a name="line349">349: </a>      const int debug = mesh-&gt;debug();
<a name="line350">350: </a>      int       v     = 0;
<a name="line351">351: </a>      int       oppositeVertex;

<a name="line353">353: </a>      origVertices-&gt;clear();
<a name="line354">354: </a>      faceVertices-&gt;clear();
<a name="line355">355: </a>      <font color="#4169E1">for</font>(typename ALE::Mesh::sieve_type::traits::coneSequence::iterator v_iter = cone-&gt;begin(); v_iter != cone-&gt;end(); ++v_iter, ++v) {
<a name="line356">356: </a>        <font color="#4169E1">if</font> (face-&gt;find(*v_iter) != face-&gt;end()) {
<a name="line357">357: </a>          <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"    vertex "</font> &lt;&lt; *v_iter &lt;&lt; std::endl;
<a name="line358">358: </a>          indices[origVertices-&gt;size()] = v;
<a name="line359">359: </a>          origVertices-&gt;insert(origVertices-&gt;end(), *v_iter);
<a name="line360">360: </a>        } <font color="#4169E1">else</font> {
<a name="line361">361: </a>          <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"    vertex "</font> &lt;&lt; *v_iter &lt;&lt; std::endl;
<a name="line362">362: </a>          oppositeVertex = v;
<a name="line363">363: </a>        }
<a name="line364">364: </a>      }
<a name="line365">365: </a>      <font color="#4169E1">return</font> faceOrientation(cell, mesh, numCorners, indices, oppositeVertex, origVertices, faceVertices);
<a name="line366">366: </a>    };
<a name="line367">367: </a>    template&lt;typename Sieve&gt;
<a name="line368">368: </a>    static void insertFace(const Obj&lt;mesh_type&gt;&amp; mesh, const Obj&lt;Sieve&gt;&amp; subSieve, const Obj&lt;PointSet&gt;&amp; face, point_type&amp; f,
<a name="line369">369: </a>                           const point_type&amp; cell, const int numCorners, int indices[], PointArray *origVertices, PointArray *faceVertices)
<a name="line370">370: </a>    {
<a name="line371">371: </a>      const Obj&lt;typename Sieve::supportSet&gt; preFace = subSieve-&gt;nJoin1(face);
<a name="line372">372: </a>      const int                             debug   = subSieve-&gt;debug();

<a name="line374">374: </a>      <font color="#4169E1">if</font> (preFace-&gt;size() &gt; 1) {
<a name="line375">375: </a>        throw ALE::Exception(<font color="#666666">"Invalid fault sieve: Multiple faces from vertex set"</font>);
<a name="line376">376: </a>      } <font color="#4169E1">else</font> <font color="#4169E1">if</font> (preFace-&gt;size() == 1) {
<a name="line377">377: </a>        // Add the other cell neighbor <font color="#4169E1">for</font> this face
<a name="line378">378: </a>        subSieve-&gt;addArrow(*preFace-&gt;begin(), cell);
<a name="line379">379: </a>      } <font color="#4169E1">else</font> <font color="#4169E1">if</font> (preFace-&gt;size() == 0) {
<a name="line380">380: </a>        <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"  Orienting face "</font> &lt;&lt; f &lt;&lt; std::endl;
<a name="line381">381: </a>        try {
<a name="line382">382: </a>          getOrientedFace(mesh, cell, face, numCorners, indices, origVertices, faceVertices);
<a name="line383">383: </a>          <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"  Adding face "</font> &lt;&lt; f &lt;&lt; std::endl;
<a name="line384">384: </a>          int color = 0;
<a name="line385">385: </a>          <font color="#4169E1">for</font>(typename PointArray::const_iterator f_iter = faceVertices-&gt;begin(); f_iter != faceVertices-&gt;end(); ++f_iter) {
<a name="line386">386: </a>            <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"    vertex "</font> &lt;&lt; *f_iter &lt;&lt; std::endl;
<a name="line387">387: </a>            subSieve-&gt;addArrow(*f_iter, f, color++);
<a name="line388">388: </a>          }
<a name="line389">389: </a>          subSieve-&gt;addArrow(f, cell);
<a name="line390">390: </a>          f++;
<a name="line391">391: </a>        } catch (ALE::Exception e) {
<a name="line392">392: </a>          <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"  Did not add invalid face "</font> &lt;&lt; f &lt;&lt; std::endl;
<a name="line393">393: </a>        }
<a name="line394">394: </a>      }
<a name="line395">395: </a>    };
<a name="line396">396: </a><strong><font color="#FF0000">  public:</font></strong>
<a name="line397">397: </a>    class FaceInserter {
<a name="line398">398: </a><font color="#A020F0">#if 0</font>
<a name="line399">399: </a><strong><font color="#FF0000">    public:</font></strong>
<a name="line400">400: </a>      <font color="#4169E1">typedef</font> Mesh_                                mesh_type;
<a name="line401">401: </a>      <font color="#4169E1">typedef</font> typename mesh_type::sieve_type       sieve_type;
<a name="line402">402: </a>      <font color="#4169E1">typedef</font> typename mesh_type::point_type       point_type;
<a name="line403">403: </a>      <font color="#4169E1">typedef</font> std::set&lt;point_type&gt;                 PointSet;
<a name="line404">404: </a>      <font color="#4169E1">typedef</font> std::vector&lt;point_type&gt;              PointArray;
<a name="line405">405: </a><font color="#A020F0">#endif</font>
<a name="line406">406: </a><strong><font color="#FF0000">    protected:</font></strong>
<a name="line407">407: </a>      const Obj&lt;mesh_type&gt;  mesh;
<a name="line408">408: </a>      const Obj&lt;sieve_type&gt; sieve;
<a name="line409">409: </a>      const Obj&lt;sieve_type&gt; subSieve;
<a name="line410">410: </a>      point_type&amp;           f;
<a name="line411">411: </a>      const point_type      cell;
<a name="line412">412: </a>      const int             numCorners;
<a name="line413">413: </a>      int                  *indices;
<a name="line414">414: </a>      PointArray           *origVertices;
<a name="line415">415: </a>      PointArray           *faceVertices;
<a name="line416">416: </a>      PointSet             *subCells;
<a name="line417">417: </a>      const int             debug;
<a name="line418">418: </a><strong><font color="#FF0000">    public:</font></strong>
<a name="line419">419: </a>      FaceInserter(const Obj&lt;mesh_type&gt;&amp; mesh, const Obj&lt;sieve_type&gt;&amp; sieve, const Obj&lt;sieve_type&gt;&amp; subSieve, point_type&amp; f, const point_type&amp; cell, const int numCorners, int indices[], PointArray *origVertices, PointArray *faceVertices, PointSet *subCells) : mesh(mesh), sieve(sieve), subSieve(subSieve), f(f), cell(cell), numCorners(numCorners), indices(indices), origVertices(origVertices), faceVertices(faceVertices), subCells(subCells), debug(mesh-&gt;debug()) {};
<a name="line420">420: </a>      virtual ~FaceInserter() {};
<a name="line421">421: </a><strong><font color="#FF0000">    public:</font></strong>
<a name="line422">422: </a>      void operator()(const Obj&lt;PointArray&gt;&amp; face) {
<a name="line423">423: </a>        const Obj&lt;typename sieve_type::supportSet&gt; sievePreFace = sieve-&gt;nJoin1(face);

<a name="line425">425: </a>        <font color="#4169E1">if</font> (sievePreFace-&gt;size() == 1) {
<a name="line426">426: </a>          <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"  Contains a boundary face on the submesh"</font> &lt;&lt; std::endl;
<a name="line427">427: </a>          PointSet faceSet(face-&gt;begin(), face-&gt;end());
<a name="line428">428: </a><strong><font color="#FF0000">          ALE:</font></strong>:Selection&lt;mesh_type&gt;::insertFace(mesh, subSieve, faceSet, f, cell, numCorners, indices, origVertices, faceVertices);
<a name="line429">429: </a>          subCells-&gt;insert(cell);
<a name="line430">430: </a>        }
<a name="line431">431: </a>      };
<a name="line432">432: </a>    };
<a name="line433">433: </a>    template&lt;typename Sieve&gt;
<a name="line434">434: </a>    class FaceInserterV {
<a name="line435">435: </a><strong><font color="#FF0000">    protected:</font></strong>
<a name="line436">436: </a>      const Obj&lt;mesh_type&gt;&amp;  mesh;
<a name="line437">437: </a>      const Obj&lt;sieve_type&gt;&amp; sieve;
<a name="line438">438: </a>      const Obj&lt;Sieve&gt;&amp;      subSieve;
<a name="line439">439: </a>      point_type&amp;            f;
<a name="line440">440: </a>      const point_type       cell;
<a name="line441">441: </a>      const int              numCorners;
<a name="line442">442: </a>      int                   *indices;
<a name="line443">443: </a>      PointArray            *origVertices;
<a name="line444">444: </a>      PointArray            *faceVertices;
<a name="line445">445: </a>      PointSet              *subCells;
<a name="line446">446: </a>      const int              debug;
<a name="line447">447: </a><strong><font color="#FF0000">    public:</font></strong>
<a name="line448">448: </a>      FaceInserterV(const Obj&lt;mesh_type&gt;&amp; mesh, const Obj&lt;sieve_type&gt;&amp; sieve, const Obj&lt;Sieve&gt;&amp; subSieve, point_type&amp; f, const point_type&amp; cell, const int numCorners, int indices[], PointArray *origVertices, PointArray *faceVertices, PointSet *subCells) : mesh(mesh), sieve(sieve), subSieve(subSieve), f(f), cell(cell), numCorners(numCorners), indices(indices), origVertices(origVertices), faceVertices(faceVertices), subCells(subCells), debug(mesh-&gt;debug()) {};
<a name="line449">449: </a>      virtual ~FaceInserterV() {};
<a name="line450">450: </a><strong><font color="#FF0000">    public:</font></strong>
<a name="line451">451: </a>      void operator()(const Obj&lt;PointArray&gt;&amp; face) {
<a name="line452">452: </a><strong><font color="#FF0000">        ISieveVisitor:</font></strong>:PointRetriever&lt;sieve_type&gt; jV(sieve-&gt;getMaxSupportSize());

<a name="line454">454: </a>        sieve-&gt;join(*face, jV);
<a name="line455">455: </a>        <font color="#4169E1">if</font> (jV.getSize() == 1) {
<a name="line456">456: </a>          <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"  Contains a boundary face on the submesh"</font> &lt;&lt; std::endl;
<a name="line457">457: </a>          PointSet faceSet(face-&gt;begin(), face-&gt;end());
<a name="line458">458: </a><strong><font color="#FF0000">          ALE:</font></strong>:Selection&lt;mesh_type&gt;::insertFace(mesh, subSieve, faceSet, f, cell, numCorners, indices, origVertices, faceVertices);
<a name="line459">459: </a>          subCells-&gt;insert(cell);
<a name="line460">460: </a>        }
<a name="line461">461: </a>      };
<a name="line462">462: </a>    };
<a name="line463">463: </a><strong><font color="#FF0000">  protected:</font></strong>
<a name="line464">464: </a>    static int binomial(const int i, const int j) {
<a name="line465">465: </a>      assert(j &lt;= i);
<a name="line466">466: </a>      assert(i &lt; 34);
<a name="line467">467: </a>      <font color="#4169E1">if</font> (j == 0) {
<a name="line468">468: </a>        <font color="#4169E1">return</font> 1;
<a name="line469">469: </a>      } <font color="#4169E1">else</font> <font color="#4169E1">if</font> (j == i) {
<a name="line470">470: </a>        <font color="#4169E1">return</font> 1;
<a name="line471">471: </a>      } <font color="#4169E1">else</font> {
<a name="line472">472: </a>        <font color="#4169E1">return</font> binomial(i-1, j) + binomial(i-1, j-1);
<a name="line473">473: </a>      }
<a name="line474">474: </a>    };
<a name="line475">475: </a><strong><font color="#FF0000">  public:</font></strong>
<a name="line476">476: </a>    // This takes in a section and creates a submesh from the vertices in the section chart
<a name="line477">477: </a>    //   This is a hyperplane of one dimension lower than the mesh
<a name="line478">478: </a>    static Obj&lt;mesh_type&gt; submesh_uninterpolated(const Obj&lt;mesh_type&gt;&amp; mesh, const Obj&lt;int_section_type&gt;&amp; label, const int dimension = -1, const bool boundaryFaces = true) {
<a name="line479">479: </a>      // A challenge here is to coordinate the extra numbering of new faces
<a name="line480">480: </a>      //   In serial, it is enough to number after the last point:
<a name="line481">481: </a>      //     Use sieve-&gt;base()-&gt;size() + sieve-&gt;cap()-&gt;size(), or determine the greatest point
<a name="line482">482: </a>      //   In parallel, there are two steps:
<a name="line483">483: </a>      //     1) Use the serial result, and reduce either with add (<font color="#4169E1">for</font> size) or max (<font color="#4169E1">for</font> greatest point)
<a name="line484">484: </a>      //     2) Determine how many faces will be created on each process
<a name="line485">485: </a>      //        This will be bounded by C(numCorners, faceSize)*submeshCells
<a name="line486">486: </a>      //        Thus it looks like we should first accumulate submeshCells, and then create faces
<a name="line487">487: </a>      <font color="#4169E1">typedef</font> typename mesh_type::label_type        label_type;
<a name="line488">488: </a>      <font color="#4169E1">typedef</font> typename int_section_type::chart_type chart_type;
<a name="line489">489: </a>      const int                  dim        = (dimension &gt; 0) ? dimension : mesh-&gt;getDimension()-1;
<a name="line490">490: </a>      const Obj&lt;sieve_type&gt;&amp;     sieve      = mesh-&gt;getSieve();
<a name="line491">491: </a>      Obj&lt;mesh_type&gt;             submesh    = new mesh_type(mesh-&gt;comm(), dim, mesh-&gt;debug());
<a name="line492">492: </a>      Obj&lt;sieve_type&gt;            subSieve   = new sieve_type(mesh-&gt;comm(), mesh-&gt;debug());
<a name="line493">493: </a>      const bool                 censor     = mesh-&gt;hasLabel(<font color="#666666">"censored depth"</font>);
<a name="line494">494: </a>      const Obj&lt;label_type&gt;&amp;     depthLabel = censor ? mesh-&gt;getLabel(<font color="#666666">"censored depth"</font>) : mesh-&gt;getLabel(<font color="#666666">"depth"</font>);
<a name="line495">495: </a>      const int                  depth      = mesh-&gt;depth();
<a name="line496">496: </a>      const int                  height     = mesh-&gt;height();
<a name="line497">497: </a>      const chart_type&amp;          chart      = label-&gt;getChart();
<a name="line498">498: </a>      const int                  numCorners = sieve-&gt;nCone(*mesh-&gt;heightStratum(0)-&gt;begin(), depth)-&gt;size();
<a name="line499">499: </a>      const int                  faceSize   = numFaceVertices(mesh);
<a name="line500">500: </a>      Obj&lt;PointSet&gt;              face       = new PointSet();
<a name="line501">501: </a>      int                        f          = sieve-&gt;base()-&gt;size() + sieve-&gt;cap()-&gt;size();
<a name="line502">502: </a>      const int                  debug      = mesh-&gt;debug();
<a name="line503">503: </a>      int                       *indices    = new int[faceSize];
<a name="line504">504: </a>      PointArray                 origVertices, faceVertices;
<a name="line505">505: </a>      PointSet                   submeshVertices, submeshCells;


<a name="line508">508: </a>      const typename chart_type::iterator chartEnd = chart.end();
<a name="line509">509: </a>      <font color="#4169E1">for</font>(typename chart_type::iterator c_iter = chart.begin(); c_iter != chartEnd; ++c_iter) {
<a name="line510">510: </a>        <font color="#4169E1">if</font> (label-&gt;getFiberDimension(*c_iter)) submeshVertices.insert(*c_iter);
<a name="line511">511: </a>      }
<a name="line512">512: </a>      const typename PointSet::const_iterator svBegin = submeshVertices.begin();
<a name="line513">513: </a>      const typename PointSet::const_iterator svEnd   = submeshVertices.end();

<a name="line515">515: </a>      <font color="#4169E1">for</font>(typename PointSet::const_iterator sv_iter = svBegin; sv_iter != svEnd; ++sv_iter) {
<a name="line516">516: </a>        const Obj&lt;typename sieveAlg::supportArray&gt;&amp;     cells  = sieveAlg::nSupport(mesh, *sv_iter, depth);
<a name="line517">517: </a>        const typename sieveAlg::supportArray::iterator cBegin = cells-&gt;begin();
<a name="line518">518: </a>        const typename sieveAlg::supportArray::iterator cEnd   = cells-&gt;end();

<a name="line520">520: </a>        <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"Checking submesh vertex "</font> &lt;&lt; *sv_iter &lt;&lt; std::endl;
<a name="line521">521: </a>        <font color="#4169E1">for</font>(typename sieveAlg::supportArray::iterator c_iter = cBegin; c_iter != cEnd; ++c_iter) {
<a name="line522">522: </a>          <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"  Checking cell "</font> &lt;&lt; *c_iter &lt;&lt; std::endl;
<a name="line523">523: </a>          <font color="#4169E1">if</font> (submeshCells.find(*c_iter) != submeshCells.end())        <font color="#4169E1">continue</font>;
<a name="line524">524: </a>          <font color="#4169E1">if</font> (censor &amp;&amp; (!mesh-&gt;getValue(depthLabel, *c_iter))) <font color="#4169E1">continue</font>;
<a name="line525">525: </a>          const Obj&lt;typename sieveAlg::coneArray&gt;&amp; cone = sieveAlg::nCone(mesh, *c_iter, height);
<a name="line526">526: </a>          const typename sieveAlg::coneArray::iterator vBegin = cone-&gt;begin();
<a name="line527">527: </a>          const typename sieveAlg::coneArray::iterator vEnd   = cone-&gt;end();

<a name="line529">529: </a>          face-&gt;clear();
<a name="line530">530: </a>          <font color="#4169E1">for</font>(typename sieveAlg::coneArray::iterator v_iter = vBegin; v_iter != vEnd; ++v_iter) {
<a name="line531">531: </a>            <font color="#4169E1">if</font> (submeshVertices.find(*v_iter) != svEnd) {
<a name="line532">532: </a>              <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"    contains submesh vertex "</font> &lt;&lt; *v_iter &lt;&lt; std::endl;
<a name="line533">533: </a>              face-&gt;insert(face-&gt;end(), *v_iter);
<a name="line534">534: </a>            }
<a name="line535">535: </a>          }
<a name="line536">536: </a>          <font color="#4169E1">if</font> ((int) face-&gt;size() &gt; faceSize) {
<a name="line537">537: </a>            <font color="#4169E1">if</font> (!boundaryFaces) throw ALE::Exception(<font color="#666666">"Invalid fault mesh: Too many vertices of an element on the fault"</font>);
<a name="line538">538: </a>            <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"  Has all boundary faces on the submesh"</font> &lt;&lt; std::endl;
<a name="line539">539: </a>            submeshCells.insert(*c_iter);
<a name="line540">540: </a>          }
<a name="line541">541: </a>          <font color="#4169E1">if</font> ((int) face-&gt;size() == faceSize) {
<a name="line542">542: </a>            <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"  Contains a face on the submesh"</font> &lt;&lt; std::endl;
<a name="line543">543: </a>            submeshCells.insert(*c_iter);
<a name="line544">544: </a>          }
<a name="line545">545: </a>        }
<a name="line546">546: </a>      }
<a name="line547">547: </a>      <font color="#4169E1">if</font> (mesh-&gt;commSize() &gt; 1) {
<a name="line548">548: </a>        int localF     = f;
<a name="line549">549: </a>        int localFaces = binomial(numCorners, faceSize)*submeshCells.size();
<a name="line550">550: </a>        int maxFaces;

<a name="line552">552: </a>        <A href="http://www.mcs.anl.gov/mpi/www/www3/MPI_Allreduce.html#MPI_Allreduce">MPI_Allreduce</A>(&amp;localF, &amp;f, 1, MPI_INT, MPI_SUM, mesh-&gt;comm());
<a name="line553">553: </a>        //     2) Determine how many faces will be created on each process
<a name="line554">554: </a>        //        This will be bounded by faceSize*submeshCells
<a name="line555">555: </a>        //        Thus it looks like we should first accumulate submeshCells, and then create faces
<a name="line556">556: </a>        <A href="http://www.mcs.anl.gov/mpi/www/www3/MPI_Scan.html#MPI_Scan">MPI_Scan</A>(&amp;localFaces, &amp;maxFaces, 1, MPI_INT, MPI_SUM, mesh-&gt;comm());
<a name="line557">557: </a>        f += maxFaces - localFaces;
<a name="line558">558: </a>      }
<a name="line559">559: </a>      <font color="#4169E1">for</font>(typename PointSet::const_iterator c_iter = submeshCells.begin(); c_iter != submeshCells.end(); ++c_iter) {
<a name="line560">560: </a>        <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"  Processing submesh cell "</font> &lt;&lt; *c_iter &lt;&lt; std::endl;
<a name="line561">561: </a>        const Obj&lt;typename sieveAlg::coneArray&gt;&amp; cone = sieveAlg::nCone(mesh, *c_iter, height);
<a name="line562">562: </a>        const typename sieveAlg::coneArray::iterator vBegin = cone-&gt;begin();
<a name="line563">563: </a>        const typename sieveAlg::coneArray::iterator vEnd   = cone-&gt;end();

<a name="line565">565: </a>        face-&gt;clear();
<a name="line566">566: </a>        <font color="#4169E1">for</font>(typename sieveAlg::coneArray::iterator v_iter = vBegin; v_iter != vEnd; ++v_iter) {
<a name="line567">567: </a>          <font color="#4169E1">if</font> (submeshVertices.find(*v_iter) != svEnd) {
<a name="line568">568: </a>            <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"    contains submesh vertex "</font> &lt;&lt; *v_iter &lt;&lt; std::endl;
<a name="line569">569: </a>            face-&gt;insert(face-&gt;end(), *v_iter);
<a name="line570">570: </a>          }
<a name="line571">571: </a>        }
<a name="line572">572: </a>        <font color="#4169E1">if</font> ((int) face-&gt;size() &gt; faceSize) {
<a name="line573">573: </a>          // Here we allow a set of vertices to lie completely on a boundary cell (like a corner tetrahedron)
<a name="line574">574: </a>          //   We have to take all the faces, and discard those in the interior
<a name="line575">575: </a>          FaceInserter inserter(mesh, sieve, subSieve, f, *c_iter, numCorners, indices, &amp;origVertices, &amp;faceVertices, &amp;submeshCells);
<a name="line576">576: </a>          PointArray   faceVec(face-&gt;begin(), face-&gt;end());

<a name="line578">578: </a>          subsets(faceVec, faceSize, inserter);
<a name="line579">579: </a>        }
<a name="line580">580: </a>        <font color="#4169E1">if</font> ((int) face-&gt;size() == faceSize) {
<a name="line581">581: </a>          insertFace(mesh, subSieve, face, f, *c_iter, numCorners, indices, &amp;origVertices, &amp;faceVertices);
<a name="line582">582: </a>        }
<a name="line583">583: </a>      }
<a name="line584">584: </a>      delete [] indices;
<a name="line585">585: </a>      submesh-&gt;setSieve(subSieve);
<a name="line586">586: </a>      submesh-&gt;stratify();
<a name="line587">587: </a>      <font color="#4169E1">if</font> (debug) submesh-&gt;view(<font color="#666666">"Submesh"</font>);
<a name="line588">588: </a>      <font color="#4169E1">return</font> submesh;
<a name="line589">589: </a>    };
<a name="line590">590: </a>    // This takes in a section and creates a submesh from the vertices in the section chart
<a name="line591">591: </a>    //   This is a hyperplane of one dimension lower than the mesh
<a name="line592">592: </a>    static Obj&lt;mesh_type&gt; submesh_interpolated(const Obj&lt;mesh_type&gt;&amp; mesh, const Obj&lt;int_section_type&gt;&amp; label, const int dimension = -1, const bool boundaryFaces = true) {
<a name="line593">593: </a>      const int debug  = mesh-&gt;debug();
<a name="line594">594: </a>      const int depth  = mesh-&gt;depth();
<a name="line595">595: </a>      const int height = mesh-&gt;height();
<a name="line596">596: </a>      const typename int_section_type::chart_type&amp;                chart        = label-&gt;getChart();
<a name="line597">597: </a>      const typename int_section_type::chart_type::const_iterator chartEnd     = chart.end();
<a name="line598">598: </a>      const Obj&lt;PointSet&gt;                                         submeshFaces = new PointSet();
<a name="line599">599: </a>      PointSet submeshVertices;

<a name="line601">601: </a>      <font color="#4169E1">for</font>(typename int_section_type::chart_type::const_iterator c_iter = chart.begin(); c_iter != chartEnd; ++c_iter) {
<a name="line602">602: </a>        //assert(!mesh-&gt;depth(*c_iter));
<a name="line603">603: </a>        submeshVertices.insert(*c_iter);
<a name="line604">604: </a>      }
<a name="line605">605: </a>      const typename PointSet::const_iterator svBegin = submeshVertices.begin();
<a name="line606">606: </a>      const typename PointSet::const_iterator svEnd   = submeshVertices.end();

<a name="line608">608: </a>      <font color="#4169E1">for</font>(typename PointSet::const_iterator sv_iter = svBegin; sv_iter != svEnd; ++sv_iter) {
<a name="line609">609: </a>        const Obj&lt;typename sieveAlg::supportArray&gt;&amp; faces = sieveAlg::nSupport(mesh, *sv_iter, depth-1);
<a name="line610">610: </a>        const typename sieveAlg::supportArray::iterator fBegin = faces-&gt;begin();
<a name="line611">611: </a>        const typename sieveAlg::supportArray::iterator fEnd   = faces-&gt;end();
<a name="line612">612: </a>
<a name="line613">613: </a>        <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"Checking submesh vertex "</font> &lt;&lt; *sv_iter &lt;&lt; std::endl;
<a name="line614">614: </a>        <font color="#4169E1">for</font>(typename sieveAlg::supportArray::iterator f_iter = fBegin; f_iter != fEnd; ++f_iter) {
<a name="line615">615: </a>          <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"  Checking face "</font> &lt;&lt; *f_iter &lt;&lt; std::endl;
<a name="line616">616: </a>          <font color="#4169E1">if</font> (submeshFaces-&gt;find(*f_iter) != submeshFaces-&gt;end())        <font color="#4169E1">continue</font>;
<a name="line617">617: </a>          const Obj&lt;typename sieveAlg::coneArray&gt;&amp; cone = sieveAlg::nCone(mesh, *f_iter, height-1);
<a name="line618">618: </a>          const typename sieveAlg::coneArray::iterator vBegin = cone-&gt;begin();
<a name="line619">619: </a>          const typename sieveAlg::coneArray::iterator vEnd   = cone-&gt;end();
<a name="line620">620: </a>          bool                                         found  = true;

<a name="line622">622: </a>          <font color="#4169E1">for</font>(typename sieveAlg::coneArray::iterator v_iter = vBegin; v_iter != vEnd; ++v_iter) {
<a name="line623">623: </a>            <font color="#4169E1">if</font> (submeshVertices.find(*v_iter) != svEnd) {
<a name="line624">624: </a>              <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"    contains submesh vertex "</font> &lt;&lt; *v_iter &lt;&lt; std::endl;
<a name="line625">625: </a>            } <font color="#4169E1">else</font> {
<a name="line626">626: </a>              found = false;
<a name="line627">627: </a>            }
<a name="line628">628: </a>          }
<a name="line629">629: </a>          <font color="#4169E1">if</font> (found) {
<a name="line630">630: </a>            <font color="#4169E1">if</font> (boundaryFaces) {throw ALE::Exception(<font color="#666666">"Not finished: should check that it is a boundary face"</font>);}
<a name="line631">631: </a>            <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"  Is a face on the submesh"</font> &lt;&lt; std::endl;
<a name="line632">632: </a>            submeshFaces-&gt;insert(*f_iter);
<a name="line633">633: </a>          }
<a name="line634">634: </a>        }
<a name="line635">635: </a>      }
<a name="line636">636: </a>      <font color="#4169E1">return</font> submesh(mesh, submeshFaces, mesh-&gt;getDimension()-1);
<a name="line637">637: </a>    };
<a name="line638">638: </a>    template&lt;typename output_mesh_type&gt;
<a name="line639">639: </a>    static Obj&lt;output_mesh_type&gt; submeshV_uninterpolated(const Obj&lt;mesh_type&gt;&amp; mesh, const Obj&lt;int_section_type&gt;&amp; label, const int dimension = -1, const bool boundaryFaces = true) {
<a name="line640">640: </a>      <font color="#4169E1">typedef</font> typename mesh_type::label_type        label_type;
<a name="line641">641: </a>      <font color="#4169E1">typedef</font> typename int_section_type::chart_type chart_type;
<a name="line642">642: </a>      const int                           dim        = (dimension &gt; 0) ? dimension : mesh-&gt;getDimension()-1;
<a name="line643">643: </a>      const Obj&lt;sieve_type&gt;&amp;              sieve      = mesh-&gt;getSieve();
<a name="line644">644: </a>      Obj&lt;ALE::Mesh&gt;                      submesh    = new ALE::Mesh(mesh-&gt;comm(), dim, mesh-&gt;debug());
<a name="line645">645: </a>      Obj&lt;typename ALE::Mesh::sieve_type&gt; subSieve   = new typename ALE::Mesh::sieve_type(mesh-&gt;comm(), mesh-&gt;debug());
<a name="line646">646: </a>      const bool                          censor     = mesh-&gt;hasLabel(<font color="#666666">"censored depth"</font>);
<a name="line647">647: </a>      const Obj&lt;label_type&gt;&amp;              depthLabel = censor ? mesh-&gt;getLabel(<font color="#666666">"censored depth"</font>) : mesh-&gt;getLabel(<font color="#666666">"depth"</font>);
<a name="line648">648: </a>      const chart_type&amp;                   chart      = label-&gt;getChart();
<a name="line649">649: </a>      const int                           numCorners = mesh-&gt;getNumCellCorners();
<a name="line650">650: </a>      const int                           faceSize   = numFaceVertices(mesh);
<a name="line651">651: </a>      Obj&lt;PointSet&gt;                       face       = new PointSet();
<a name="line652">652: </a>      int                                 f          = sieve-&gt;getBaseSize() + sieve-&gt;getCapSize();
<a name="line653">653: </a>      const int                           debug      = mesh-&gt;debug();
<a name="line654">654: </a>      int                                *indices    = new int[faceSize];
<a name="line655">655: </a>      PointArray                          origVertices, faceVertices;
<a name="line656">656: </a>      PointSet                            submeshVertices, submeshCells;

<a name="line658">658: </a>      const typename chart_type::const_iterator chartEnd = chart.end();
<a name="line659">659: </a>      <font color="#4169E1">for</font>(typename chart_type::const_iterator c_iter = chart.begin(); c_iter != chartEnd; ++c_iter) {
<a name="line660">660: </a>        <font color="#4169E1">if</font> (label-&gt;getFiberDimension(*c_iter)) submeshVertices.insert(*c_iter);
<a name="line661">661: </a>      }
<a name="line662">662: </a>      const typename PointSet::const_iterator svBegin = submeshVertices.begin();
<a name="line663">663: </a>      const typename PointSet::const_iterator svEnd   = submeshVertices.end();
<a name="line664">664: </a>      typename ISieveVisitor::PointRetriever&lt;sieve_type&gt; sV(sieve-&gt;getMaxSupportSize());
<a name="line665">665: </a>      typename ISieveVisitor::PointRetriever&lt;sieve_type&gt; cV(sieve-&gt;getMaxConeSize());

<a name="line667">667: </a>      <font color="#4169E1">for</font>(typename PointSet::const_iterator sv_iter = svBegin; sv_iter != svEnd; ++sv_iter) {
<a name="line668">668: </a>        sieve-&gt;support(*sv_iter, sV);
<a name="line669">669: </a>        const int         numCells = sV.getSize();
<a name="line670">670: </a>        const point_type *cells    = sV.getPoints();
<a name="line671">671: </a>
<a name="line672">672: </a>        <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"Checking submesh vertex "</font> &lt;&lt; *sv_iter &lt;&lt; std::endl;
<a name="line673">673: </a>        <font color="#4169E1">for</font>(int c = 0; c &lt; numCells; ++c) {
<a name="line674">674: </a>          <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"  Checking cell "</font> &lt;&lt; cells[c] &lt;&lt; std::endl;
<a name="line675">675: </a>          <font color="#4169E1">if</font> (submeshCells.find(cells[c]) != submeshCells.end()) <font color="#4169E1">continue</font>;
<a name="line676">676: </a>          <font color="#4169E1">if</font> (censor &amp;&amp; (!mesh-&gt;getValue(depthLabel, cells[c]))) <font color="#4169E1">continue</font>;
<a name="line677">677: </a>          sieve-&gt;cone(cells[c], cV);
<a name="line678">678: </a>          const int         numVertices = cV.getSize();
<a name="line679">679: </a>          const point_type *vertices    = cV.getPoints();

<a name="line681">681: </a>          face-&gt;clear();
<a name="line682">682: </a>          <font color="#4169E1">for</font>(int v = 0; v &lt; numVertices; ++v) {
<a name="line683">683: </a>            <font color="#4169E1">if</font> (submeshVertices.find(vertices[v]) != svEnd) {
<a name="line684">684: </a>              <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"    contains submesh vertex "</font> &lt;&lt; vertices[v] &lt;&lt; std::endl;
<a name="line685">685: </a>              face-&gt;insert(face-&gt;end(), vertices[v]);
<a name="line686">686: </a>            }
<a name="line687">687: </a>          }
<a name="line688">688: </a>          <font color="#4169E1">if</font> ((int) face-&gt;size() &gt; faceSize) {
<a name="line689">689: </a>            <font color="#4169E1">if</font> (!boundaryFaces) throw ALE::Exception(<font color="#666666">"Invalid fault mesh: Too many vertices of an element on the fault"</font>);
<a name="line690">690: </a>            <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"  Has all boundary faces on the submesh"</font> &lt;&lt; std::endl;
<a name="line691">691: </a>            submeshCells.insert(cells[c]);
<a name="line692">692: </a>          }
<a name="line693">693: </a>          <font color="#4169E1">if</font> ((int) face-&gt;size() == faceSize) {
<a name="line694">694: </a>            <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"  Contains a face on the submesh"</font> &lt;&lt; std::endl;
<a name="line695">695: </a>            submeshCells.insert(cells[c]);
<a name="line696">696: </a>          }
<a name="line697">697: </a>          cV.clear();
<a name="line698">698: </a>        }
<a name="line699">699: </a>        sV.clear();
<a name="line700">700: </a>      }
<a name="line701">701: </a>      <font color="#4169E1">if</font> (mesh-&gt;commSize() &gt; 1) {
<a name="line702">702: </a>        int localF     = f;
<a name="line703">703: </a>        int localFaces = binomial(numCorners, faceSize)*submeshCells.size();
<a name="line704">704: </a>        int maxFaces;

<a name="line706">706: </a>        <A href="http://www.mcs.anl.gov/mpi/www/www3/MPI_Allreduce.html#MPI_Allreduce">MPI_Allreduce</A>(&amp;localF, &amp;f, 1, MPI_INT, MPI_SUM, mesh-&gt;comm());
<a name="line707">707: </a>        //     2) Determine how many faces will be created on each process
<a name="line708">708: </a>        //        This will be bounded by faceSize*submeshCells
<a name="line709">709: </a>        //        Thus it looks like we should first accumulate submeshCells, and then create faces
<a name="line710">710: </a>        <A href="http://www.mcs.anl.gov/mpi/www/www3/MPI_Scan.html#MPI_Scan">MPI_Scan</A>(&amp;localFaces, &amp;maxFaces, 1, MPI_INT, MPI_SUM, mesh-&gt;comm());
<a name="line711">711: </a>        f += maxFaces - localFaces;
<a name="line712">712: </a>      }
<a name="line713">713: </a>      <font color="#4169E1">for</font>(typename PointSet::const_iterator c_iter = submeshCells.begin(); c_iter != submeshCells.end(); ++c_iter) {
<a name="line714">714: </a>        <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"  Processing submesh cell "</font> &lt;&lt; *c_iter &lt;&lt; std::endl;
<a name="line715">715: </a>        sieve-&gt;cone(*c_iter, cV);
<a name="line716">716: </a>        const int         numVertices = cV.getSize();
<a name="line717">717: </a>        const point_type *vertices    = cV.getPoints();

<a name="line719">719: </a>        face-&gt;clear();
<a name="line720">720: </a>        <font color="#4169E1">for</font>(int v = 0; v &lt; numVertices; ++v) {
<a name="line721">721: </a>          <font color="#4169E1">if</font> (submeshVertices.find(vertices[v]) != svEnd) {
<a name="line722">722: </a>            <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"    contains submesh vertex "</font> &lt;&lt; vertices[v] &lt;&lt; std::endl;
<a name="line723">723: </a>            face-&gt;insert(face-&gt;end(), vertices[v]);
<a name="line724">724: </a>          }
<a name="line725">725: </a>        }
<a name="line726">726: </a>        <font color="#4169E1">if</font> ((int) face-&gt;size() &gt; faceSize) {
<a name="line727">727: </a>          <font color="#4169E1">if</font> (!boundaryFaces) throw ALE::Exception(<font color="#666666">"Invalid fault mesh: Too many vertices of an element on the fault"</font>);
<a name="line728">728: </a>          // Here we allow a set of vertices to lie completely on a boundary cell (like a corner tetrahedron)
<a name="line729">729: </a>          //   We have to take all the faces, and discard those in the interior
<a name="line730">730: </a>          FaceInserterV&lt;ALE::Mesh::sieve_type&gt; inserter(mesh, sieve, subSieve, f, *c_iter, numCorners, indices, &amp;origVertices, &amp;faceVertices, &amp;submeshCells);
<a name="line731">731: </a>          PointArray                           faceVec(face-&gt;begin(), face-&gt;end());

<a name="line733">733: </a>          subsets(faceVec, faceSize, inserter);
<a name="line734">734: </a>        }
<a name="line735">735: </a>        <font color="#4169E1">if</font> ((int) face-&gt;size() == faceSize) {
<a name="line736">736: </a>          insertFace(mesh, subSieve, face, f, *c_iter, numCorners, indices, &amp;origVertices, &amp;faceVertices);
<a name="line737">737: </a>        }
<a name="line738">738: </a>        cV.clear();
<a name="line739">739: </a>      }
<a name="line740">740: </a>      delete [] indices;
<a name="line741">741: </a>      submesh-&gt;setSieve(subSieve);
<a name="line742">742: </a>      submesh-&gt;stratify();
<a name="line743">743: </a>      <font color="#4169E1">if</font> (debug) submesh-&gt;view(<font color="#666666">"Submesh"</font>);

<a name="line745">745: </a>      Obj&lt;output_mesh_type&gt; isubmesh = new output_mesh_type(submesh-&gt;comm(), submesh-&gt;getDimension(), submesh-&gt;debug());
<a name="line746">746: </a>      Obj&lt;typename output_mesh_type::sieve_type&gt; isieve = new typename output_mesh_type::sieve_type(submesh-&gt;comm(), submesh-&gt;debug());
<a name="line747">747: </a><strong><font color="#FF0000">      std:</font></strong>:map&lt;typename output_mesh_type::point_type,typename output_mesh_type::point_type&gt; renumbering;
<a name="line748">748: </a>      isubmesh-&gt;setSieve(isieve);
<a name="line749">749: </a><strong><font color="#FF0000">      ALE:</font></strong>:ISieveConverter::convertMesh(*submesh, *isubmesh, renumbering, false);
<a name="line750">750: </a>      <font color="#4169E1">return</font> isubmesh;
<a name="line751">751: </a>    };
<a name="line752">752: </a><strong><font color="#FF0000">  public:</font></strong>
<a name="line753">753: </a>    // This takes in a section and creates a submesh from the vertices in the section chart
<a name="line754">754: </a>    //   This is a hyperplane of one dimension lower than the mesh
<a name="line755">755: </a>    static Obj&lt;mesh_type&gt; submesh(const Obj&lt;mesh_type&gt;&amp; mesh, const Obj&lt;int_section_type&gt;&amp; label, const int dimension = -1) {
<a name="line756">756: </a>      const int dim   = mesh-&gt;getDimension();
<a name="line757">757: </a>      const int depth = mesh-&gt;depth();

<a name="line759">759: </a>      <font color="#4169E1">if</font> (dim == depth) {
<a name="line760">760: </a>        <font color="#4169E1">return</font> submesh_interpolated(mesh, label, dimension, false);
<a name="line761">761: </a>      } <font color="#4169E1">else</font> <font color="#4169E1">if</font> (depth == 1) {
<a name="line762">762: </a>        <font color="#4169E1">return</font> submesh_uninterpolated(mesh, label, dimension);
<a name="line763">763: </a>      }
<a name="line764">764: </a>      throw ALE::Exception(<font color="#666666">"Cannot handle partially interpolated meshes"</font>);
<a name="line765">765: </a>    };
<a name="line766">766: </a>    template&lt;typename output_mesh_type&gt;
<a name="line767">767: </a>    static Obj&lt;output_mesh_type&gt; submeshV(const Obj&lt;mesh_type&gt;&amp; mesh, const Obj&lt;int_section_type&gt;&amp; label, const int dimension = -1) {
<a name="line768">768: </a>      const int dim   = mesh-&gt;getDimension();
<a name="line769">769: </a>      const int depth = mesh-&gt;depth();

<a name="line771">771: </a><font color="#A020F0">#if 0</font>
<a name="line772">772: </a>      <font color="#4169E1">if</font> (dim == depth) {
<a name="line773">773: </a>        //<font color="#4169E1">return</font> submesh_interpolated(mesh, label, dimension, false);
<a name="line774">774: </a>        throw ALE::Exception(<font color="#666666">"Cannot handle interpolated meshes"</font>);
<a name="line775">775: </a>      } <font color="#4169E1">else</font> <font color="#4169E1">if</font> (depth == 1) {
<a name="line776">776: </a>        <font color="#4169E1">return</font> submeshV_uninterpolated&lt;output_mesh_type&gt;(mesh, label, dimension);
<a name="line777">777: </a>      }
<a name="line778">778: </a><font color="#A020F0">#else</font>
<a name="line779">779: </a>      <font color="#4169E1">if</font> (depth == 1) {
<a name="line780">780: </a>        <font color="#4169E1">return</font> submeshV_uninterpolated&lt;output_mesh_type&gt;(mesh, label, dimension);
<a name="line781">781: </a>      } <font color="#4169E1">else</font> <font color="#4169E1">if</font> (dim == depth) {
<a name="line782">782: </a>        //<font color="#4169E1">return</font> submesh_interpolated(mesh, label, dimension, false);
<a name="line783">783: </a>        throw ALE::Exception(<font color="#666666">"Cannot handle interpolated meshes"</font>);
<a name="line784">784: </a>      }
<a name="line785">785: </a><font color="#A020F0">#endif</font>
<a name="line786">786: </a>      throw ALE::Exception(<font color="#666666">"Cannot handle partially interpolated meshes"</font>);
<a name="line787">787: </a>    };
<a name="line788">788: </a>    // This creates a submesh consisting of the <font color="#4169E1">union</font> of the closures of the given points
<a name="line789">789: </a>    //   This mesh is the same dimension as in the input mesh
<a name="line790">790: </a>    template&lt;typename Points&gt;
<a name="line791">791: </a>    static Obj&lt;mesh_type&gt; submesh(const Obj&lt;mesh_type&gt;&amp; mesh, const Obj&lt;Points&gt;&amp; points, const int dim = -1) {
<a name="line792">792: </a>      const Obj&lt;sieve_type&gt;&amp; sieve     = mesh-&gt;getSieve();
<a name="line793">793: </a>      Obj&lt;mesh_type&gt;         newMesh   = new mesh_type(mesh-&gt;comm(), dim &gt;= 0 ? dim : mesh-&gt;getDimension(), mesh-&gt;debug());
<a name="line794">794: </a>      Obj&lt;sieve_type&gt;        newSieve  = new sieve_type(mesh-&gt;comm(), mesh-&gt;debug());
<a name="line795">795: </a>      Obj&lt;PointSet&gt;          newPoints = new PointSet();
<a name="line796">796: </a>      Obj&lt;PointSet&gt;          modPoints = new PointSet();
<a name="line797">797: </a>      Obj&lt;PointSet&gt;          tmpPoints;

<a name="line799">799: </a>      newMesh-&gt;setSieve(newSieve);
<a name="line800">800: </a>      <font color="#4169E1">for</font>(typename Points::iterator p_iter = points-&gt;begin(); p_iter != points-&gt;end(); ++p_iter) {
<a name="line801">801: </a>        newPoints-&gt;insert(*p_iter);
<a name="line802">802: </a>        <font color="#4169E1">do</font> {
<a name="line803">803: </a>          modPoints-&gt;clear();
<a name="line804">804: </a>          <font color="#4169E1">for</font>(typename PointSet::iterator np_iter = newPoints-&gt;begin(); np_iter != newPoints-&gt;end(); ++np_iter) {
<a name="line805">805: </a>            const Obj&lt;typename sieve_type::traits::coneSequence&gt;&amp;     cone = sieve-&gt;cone(*np_iter);
<a name="line806">806: </a>            const typename sieve_type::traits::coneSequence::iterator end  = cone-&gt;end();
<a name="line807">807: </a>            int c = 0;

<a name="line809">809: </a>            <font color="#4169E1">for</font>(typename sieve_type::traits::coneSequence::iterator c_iter = cone-&gt;begin(); c_iter != end; ++c_iter, ++c) {
<a name="line810">810: </a>              newSieve-&gt;addArrow(*c_iter, *np_iter, c);
<a name="line811">811: </a>            }
<a name="line812">812: </a>            modPoints-&gt;insert(cone-&gt;begin(), cone-&gt;end());
<a name="line813">813: </a>          }
<a name="line814">814: </a>          tmpPoints = newPoints;
<a name="line815">815: </a>          newPoints = modPoints;
<a name="line816">816: </a>          modPoints = tmpPoints;
<a name="line817">817: </a>        } <font color="#4169E1">while</font>(newPoints-&gt;size());
<a name="line818">818: </a>        newPoints-&gt;insert(*p_iter);
<a name="line819">819: </a>        <font color="#4169E1">do</font> {
<a name="line820">820: </a>          modPoints-&gt;clear();
<a name="line821">821: </a>          <font color="#4169E1">for</font>(typename PointSet::iterator np_iter = newPoints-&gt;begin(); np_iter != newPoints-&gt;end(); ++np_iter) {
<a name="line822">822: </a>            const Obj&lt;typename sieve_type::traits::supportSequence&gt;&amp;     support = sieve-&gt;support(*np_iter);
<a name="line823">823: </a>            const typename sieve_type::traits::supportSequence::iterator end     = support-&gt;end();
<a name="line824">824: </a>            int s = 0;

<a name="line826">826: </a>            <font color="#4169E1">for</font>(typename sieve_type::traits::supportSequence::iterator s_iter = support-&gt;begin(); s_iter != end; ++s_iter, ++s) {
<a name="line827">827: </a>              newSieve-&gt;addArrow(*np_iter, *s_iter, s);
<a name="line828">828: </a>            }
<a name="line829">829: </a>            modPoints-&gt;insert(support-&gt;begin(), support-&gt;end());
<a name="line830">830: </a>          }
<a name="line831">831: </a>          tmpPoints = newPoints;
<a name="line832">832: </a>          newPoints = modPoints;
<a name="line833">833: </a>          modPoints = tmpPoints;
<a name="line834">834: </a>        } <font color="#4169E1">while</font>(newPoints-&gt;size());
<a name="line835">835: </a>      }
<a name="line836">836: </a>      newMesh-&gt;stratify();
<a name="line837">837: </a>      newMesh-&gt;setRealSection(<font color="#666666">"coordinates"</font>, mesh-&gt;getRealSection(<font color="#666666">"coordinates"</font>));
<a name="line838">838: </a>      newMesh-&gt;setArrowSection(<font color="#666666">"orientation"</font>, mesh-&gt;getArrowSection(<font color="#666666">"orientation"</font>));
<a name="line839">839: </a>      <font color="#4169E1">return</font> newMesh;
<a name="line840">840: </a>    };
<a name="line841">841: </a><strong><font color="#FF0000">  protected:</font></strong>
<a name="line842">842: </a>    static Obj&lt;mesh_type&gt; boundary_uninterpolated(const Obj&lt;mesh_type&gt;&amp; mesh) {
<a name="line843">843: </a>      throw ALE::Exception(<font color="#666666">"Not yet implemented"</font>);
<a name="line844">844: </a>      const Obj&lt;typename mesh_type::label_sequence&gt;&amp;     cells    = mesh-&gt;heightStratum(0);
<a name="line845">845: </a>      const Obj&lt;sieve_type&gt;&amp;                             sieve    = mesh-&gt;getSieve();
<a name="line846">846: </a>      const typename mesh_type::label_sequence::iterator cBegin   = cells-&gt;begin();
<a name="line847">847: </a>      const typename mesh_type::label_sequence::iterator cEnd     = cells-&gt;end();
<a name="line848">848: </a>      const int                                          faceSize = numFaceVertices(mesh);

<a name="line850">850: </a>      <font color="#4169E1">for</font>(typename mesh_type::label_sequence::iterator c_iter = cBegin; c_iter != cEnd; ++c_iter) {
<a name="line851">851: </a>        const Obj&lt;typename sieve_type::traits::coneSequence&gt;&amp;     vertices = sieve-&gt;cone(*c_iter);
<a name="line852">852: </a>        const typename sieve_type::traits::coneSequence::iterator vBegin   = vertices-&gt;begin();
<a name="line853">853: </a>        const typename sieve_type::traits::coneSequence::iterator vEnd     = vertices-&gt;end();
<a name="line854">854: </a>        //PointArray cell(vertices-&gt;begin(), vertices-&gt;end());

<a name="line856">856: </a>        // For each vertex, gather
<a name="line857">857: </a>        <font color="#4169E1">for</font>(typename sieve_type::traits::coneSequence::iterator v_iter = vBegin; v_iter != vEnd; ++v_iter) {
<a name="line858">858: </a>          const Obj&lt;typename sieve_type::traits::supportSequence&gt;&amp;     neighbors = sieve-&gt;support(*v_iter);
<a name="line859">859: </a>          const typename sieve_type::traits::supportSequence::iterator nBegin    = neighbors-&gt;begin();
<a name="line860">860: </a>          const typename sieve_type::traits::supportSequence::iterator nEnd      = neighbors-&gt;end();

<a name="line862">862: </a>          <font color="#4169E1">for</font>(typename sieve_type::traits::supportSequence::iterator n_iter = nBegin; n_iter != nEnd; ++n_iter) {
<a name="line863">863: </a>            const Obj&lt;typename sieve_type::coneSet&gt;&amp; preFace = sieve-&gt;nMeet(*c_iter, *n_iter, 1);

<a name="line865">865: </a>            <font color="#4169E1">if</font> (preFace-&gt;size() == faceSize) {
<a name="line866">866: </a>            }
<a name="line867">867: </a>          }
<a name="line868">868: </a>        }
<a name="line869">869: </a>        // For each face
<a name="line870">870: </a>        // - determine <font color="#4169E1">if</font> its legal
<a name="line871">871: </a>
<a name="line872">872: </a>        // - determine <font color="#4169E1">if</font> its part of a neighboring cell
<a name="line873">873: </a>        // - <font color="#4169E1">if</font> not, its a boundary face
<a name="line874">874: </a>        //subsets(cell, faceSize, inserter);
<a name="line875">875: </a>      }
<a name="line876">876: </a>    };
<a name="line877">877: </a>    static void addClosure(const Obj&lt;sieve_type&gt;&amp; sieveA, const Obj&lt;sieve_type&gt;&amp; sieveB, const point_type&amp; p, const int depth = 1) {
<a name="line878">878: </a>      Obj&lt;typename sieve_type::coneSet&gt; current = new typename sieve_type::coneSet();
<a name="line879">879: </a>      Obj&lt;typename sieve_type::coneSet&gt; next    = new typename sieve_type::coneSet();
<a name="line880">880: </a>      Obj&lt;typename sieve_type::coneSet&gt; tmp;

<a name="line882">882: </a>      current-&gt;insert(p);
<a name="line883">883: </a>      <font color="#4169E1">while</font>(current-&gt;size()) {
<a name="line884">884: </a>        <font color="#4169E1">for</font>(typename sieve_type::coneSet::const_iterator p_iter = current-&gt;begin(); p_iter != current-&gt;end(); ++p_iter) {
<a name="line885">885: </a>          const Obj&lt;typename sieve_type::traits::coneSequence&gt;&amp;     cone  = sieveA-&gt;cone(*p_iter);
<a name="line886">886: </a>          const typename sieve_type::traits::coneSequence::iterator begin = cone-&gt;begin();
<a name="line887">887: </a>          const typename sieve_type::traits::coneSequence::iterator end   = cone-&gt;end();

<a name="line889">889: </a>          <font color="#4169E1">for</font>(typename sieve_type::traits::coneSequence::iterator c_iter = begin; c_iter != end; ++c_iter) {
<a name="line890">890: </a>            sieveB-&gt;addArrow(*c_iter, *p_iter, c_iter.color());
<a name="line891">891: </a>            next-&gt;insert(*c_iter);
<a name="line892">892: </a>          }
<a name="line893">893: </a>        }
<a name="line894">894: </a>        tmp = current; current = next; next = tmp;
<a name="line895">895: </a>        next-&gt;clear();
<a name="line896">896: </a>      }
<a name="line897">897: </a>      <font color="#4169E1">if</font> (!depth) {
<a name="line898">898: </a>        const Obj&lt;typename sieve_type::traits::supportSequence&gt;&amp;     support = sieveA-&gt;support(p);
<a name="line899">899: </a>        const typename sieve_type::traits::supportSequence::iterator begin   = support-&gt;begin();
<a name="line900">900: </a>        const typename sieve_type::traits::supportSequence::iterator end     = support-&gt;end();
<a name="line901">901: </a>
<a name="line902">902: </a>        <font color="#4169E1">for</font>(typename sieve_type::traits::supportSequence::iterator s_iter = begin; s_iter != end; ++s_iter) {
<a name="line903">903: </a>          sieveB-&gt;addArrow(p, *s_iter, s_iter.color());
<a name="line904">904: </a>          next-&gt;insert(*s_iter);
<a name="line905">905: </a>        }
<a name="line906">906: </a>      }
<a name="line907">907: </a>    };
<a name="line908">908: </a>    static Obj&lt;mesh_type&gt; boundary_interpolated(const Obj&lt;mesh_type&gt;&amp; mesh, const int faceHeight = 1) {
<a name="line909">909: </a>      Obj&lt;mesh_type&gt;                                     newMesh  = new mesh_type(mesh-&gt;comm(), mesh-&gt;getDimension()-1, mesh-&gt;debug());
<a name="line910">910: </a>      Obj&lt;sieve_type&gt;                                    newSieve = new sieve_type(mesh-&gt;comm(), mesh-&gt;debug());
<a name="line911">911: </a>      const Obj&lt;sieve_type&gt;&amp;                             sieve    = mesh-&gt;getSieve();
<a name="line912">912: </a>      const Obj&lt;typename mesh_type::label_sequence&gt;&amp;     faces    = mesh-&gt;heightStratum(faceHeight);
<a name="line913">913: </a>      const typename mesh_type::label_sequence::iterator fBegin   = faces-&gt;begin();
<a name="line914">914: </a>      const typename mesh_type::label_sequence::iterator fEnd     = faces-&gt;end();
<a name="line915">915: </a>      const int                                          depth    = faceHeight - mesh-&gt;depth();

<a name="line917">917: </a>      <font color="#4169E1">for</font>(typename mesh_type::label_sequence::iterator f_iter = fBegin; f_iter != fEnd; ++f_iter) {
<a name="line918">918: </a>        const Obj&lt;typename sieve_type::traits::supportSequence&gt;&amp; support = sieve-&gt;support(*f_iter);

<a name="line920">920: </a>        <font color="#4169E1">if</font> (support-&gt;size() == 1) {
<a name="line921">921: </a>          addClosure(sieve, newSieve, *f_iter, depth);
<a name="line922">922: </a>        }
<a name="line923">923: </a>      }
<a name="line924">924: </a>      newMesh-&gt;setSieve(newSieve);
<a name="line925">925: </a>      newMesh-&gt;stratify();
<a name="line926">926: </a>      <font color="#4169E1">return</font> newMesh;
<a name="line927">927: </a>    };
<a name="line928">928: </a>    template&lt;typename SieveTypeA, typename SieveTypeB&gt;
<a name="line929">929: </a>    static void addClosureV(const Obj&lt;SieveTypeA&gt;&amp; sieveA, const Obj&lt;SieveTypeB&gt;&amp; sieveB, const point_type&amp; p, const int depth = 1) {
<a name="line930">930: </a>      <font color="#4169E1">typedef</font> std::set&lt;typename SieveTypeA::point_type&gt; coneSet;
<a name="line931">931: </a><strong><font color="#FF0000">      ALE:</font></strong>:ISieveVisitor::PointRetriever&lt;SieveTypeA&gt; cV(std::max(1, sieveA-&gt;getMaxConeSize()));
<a name="line932">932: </a>      Obj&lt;coneSet&gt; current = new coneSet();
<a name="line933">933: </a>      Obj&lt;coneSet&gt; next    = new coneSet();
<a name="line934">934: </a>      Obj&lt;coneSet&gt; tmp;

<a name="line936">936: </a>      current-&gt;insert(p);
<a name="line937">937: </a>      <font color="#4169E1">while</font>(current-&gt;size()) {
<a name="line938">938: </a>        <font color="#4169E1">for</font>(typename coneSet::const_iterator p_iter = current-&gt;begin(); p_iter != current-&gt;end(); ++p_iter) {
<a name="line939">939: </a>          sieveA-&gt;cone(*p_iter, cV);
<a name="line940">940: </a>          const typename SieveTypeA::point_type *cone = cV.getPoints();

<a name="line942">942: </a>          <font color="#4169E1">for</font>(int c = 0; c &lt; (int) cV.getSize(); ++c) {
<a name="line943">943: </a>            sieveB-&gt;addArrow(cone[c], *p_iter);
<a name="line944">944: </a>            next-&gt;insert(cone[c]);
<a name="line945">945: </a>          }
<a name="line946">946: </a>          cV.clear();
<a name="line947">947: </a>        }
<a name="line948">948: </a>        tmp = current; current = next; next = tmp;
<a name="line949">949: </a>        next-&gt;clear();
<a name="line950">950: </a>      }
<a name="line951">951: </a>      <font color="#4169E1">if</font> (!depth) {
<a name="line952">952: </a><strong><font color="#FF0000">        ALE:</font></strong>:ISieveVisitor::PointRetriever&lt;SieveTypeA&gt; sV(std::max(1, sieveA-&gt;getMaxSupportSize()));

<a name="line954">954: </a>        sieveA-&gt;support(p, sV);
<a name="line955">955: </a>        const typename SieveTypeA::point_type *support = sV.getPoints();
<a name="line956">956: </a>
<a name="line957">957: </a>        <font color="#4169E1">for</font>(int s = 0; s &lt; (int) sV.getSize(); ++s) {
<a name="line958">958: </a>          sieveB-&gt;addArrow(p, support[s]);
<a name="line959">959: </a>        }
<a name="line960">960: </a>        sV.clear();
<a name="line961">961: </a>      }
<a name="line962">962: </a>    };
<a name="line963">963: </a><strong><font color="#FF0000">  public:</font></strong>
<a name="line964">964: </a>    static Obj&lt;mesh_type&gt; boundary(const Obj&lt;mesh_type&gt;&amp; mesh) {
<a name="line965">965: </a>      const int dim   = mesh-&gt;getDimension();
<a name="line966">966: </a>      const int depth = mesh-&gt;depth();

<a name="line968">968: </a>      <font color="#4169E1">if</font> (dim == depth) {
<a name="line969">969: </a>        <font color="#4169E1">return</font> boundary_interpolated(mesh);
<a name="line970">970: </a>      } <font color="#4169E1">else</font> <font color="#4169E1">if</font> (depth == dim+1) {
<a name="line971">971: </a>        <font color="#4169E1">return</font> boundary_interpolated(mesh, 2);
<a name="line972">972: </a>      } <font color="#4169E1">else</font> <font color="#4169E1">if</font> (depth == 1) {
<a name="line973">973: </a>        <font color="#4169E1">return</font> boundary_uninterpolated(mesh);
<a name="line974">974: </a>      } <font color="#4169E1">else</font> <font color="#4169E1">if</font> (depth == -1) {
<a name="line975">975: </a>        Obj&lt;mesh_type&gt;  newMesh  = new mesh_type(mesh-&gt;comm(), mesh-&gt;getDimension()-1, mesh-&gt;debug());
<a name="line976">976: </a>        Obj&lt;sieve_type&gt; newSieve = new sieve_type(mesh-&gt;comm(), mesh-&gt;debug());

<a name="line978">978: </a>        newMesh-&gt;setSieve(newSieve);
<a name="line979">979: </a>        newMesh-&gt;stratify();
<a name="line980">980: </a>        <font color="#4169E1">return</font> newMesh;
<a name="line981">981: </a>      }
<a name="line982">982: </a>      throw ALE::Exception(<font color="#666666">"Cannot handle partially interpolated meshes"</font>);
<a name="line983">983: </a>    };
<a name="line984">984: </a>    template&lt;typename MeshTypeQ&gt;
<a name="line985">985: </a>    static Obj&lt;ALE::Mesh&gt; boundaryV_uninterpolated(const Obj&lt;MeshTypeQ&gt;&amp; mesh, const int faceHeight = 1) {
<a name="line986">986: </a>        throw ALE::Exception(<font color="#666666">"Cannot handle uninterpolated meshes"</font>);
<a name="line987">987: </a>    };
<a name="line988">988: </a>    // This method takes in an interpolated mesh, and returns the boundary
<a name="line989">989: </a>    template&lt;typename MeshTypeQ&gt;
<a name="line990">990: </a>    static Obj&lt;ALE::Mesh&gt; boundaryV_interpolated(const Obj&lt;MeshTypeQ&gt;&amp; mesh, const int faceHeight = 1) {
<a name="line991">991: </a>      Obj&lt;ALE::Mesh&gt;                                      newMesh  = new ALE::Mesh(mesh-&gt;comm(), mesh-&gt;getDimension()-1, mesh-&gt;debug());
<a name="line992">992: </a>      Obj&lt;typename ALE::Mesh::sieve_type&gt;                 newSieve = new typename ALE::Mesh::sieve_type(mesh-&gt;comm(), mesh-&gt;debug());
<a name="line993">993: </a>      const Obj&lt;typename MeshTypeQ::sieve_type&gt;&amp;          sieve    = mesh-&gt;getSieve();
<a name="line994">994: </a>      const Obj&lt;typename MeshTypeQ::label_sequence&gt;&amp;      faces    = mesh-&gt;heightStratum(faceHeight);
<a name="line995">995: </a>      const typename MeshTypeQ::label_sequence::iterator  fBegin   = faces-&gt;begin();
<a name="line996">996: </a>      const typename MeshTypeQ::label_sequence::iterator  fEnd     = faces-&gt;end();
<a name="line997">997: </a>      const int                                           depth    = faceHeight - mesh-&gt;depth();
<a name="line998">998: </a><strong><font color="#FF0000">      ALE:</font></strong>:ISieveVisitor::PointRetriever&lt;sieve_type&gt;      sV(std::max(1, sieve-&gt;getMaxSupportSize()));

<a name="line1000">1000: </a>      <font color="#4169E1">for</font>(typename MeshTypeQ::label_sequence::iterator f_iter = fBegin; f_iter != fEnd; ++f_iter) {
<a name="line1001">1001: </a>        sieve-&gt;support(*f_iter, sV);

<a name="line1003">1003: </a>        <font color="#4169E1">if</font> (sV.getSize() == 1) {
<a name="line1004">1004: </a>          addClosureV(sieve, newSieve, *f_iter, depth);
<a name="line1005">1005: </a>        }
<a name="line1006">1006: </a>        sV.clear();
<a name="line1007">1007: </a>      }
<a name="line1008">1008: </a>      newMesh-&gt;setSieve(newSieve);
<a name="line1009">1009: </a>      newMesh-&gt;stratify();
<a name="line1010">1010: </a>      <font color="#4169E1">return</font> newMesh;
<a name="line1011">1011: </a>    };
<a name="line1012">1012: </a>    template&lt;typename MeshTypeQ&gt;
<a name="line1013">1013: </a>    static Obj&lt;ALE::Mesh&gt; boundaryV(const Obj&lt;MeshTypeQ&gt;&amp; mesh, const int faceHeight = 1) {
<a name="line1014">1014: </a>      const int dim   = mesh-&gt;getDimension();
<a name="line1015">1015: </a>      const int depth = mesh-&gt;depth();

<a name="line1017">1017: </a>      <font color="#4169E1">if</font> (dim == depth) {
<a name="line1018">1018: </a>        <font color="#4169E1">return</font> boundaryV_interpolated(mesh);
<a name="line1019">1019: </a>      } <font color="#4169E1">else</font> <font color="#4169E1">if</font> (depth == dim+1) {
<a name="line1020">1020: </a>        <font color="#4169E1">return</font> boundaryV_interpolated(mesh, 2);
<a name="line1021">1021: </a>      } <font color="#4169E1">else</font> <font color="#4169E1">if</font> (depth == 1) {
<a name="line1022">1022: </a>        throw ALE::Exception(<font color="#666666">"Cannot handle uninterpolated meshes"</font>);
<a name="line1023">1023: </a>      } <font color="#4169E1">else</font> <font color="#4169E1">if</font> (depth == -1) {
<a name="line1024">1024: </a>        Obj&lt;mesh_type&gt;  newMesh  = new mesh_type(mesh-&gt;comm(), mesh-&gt;getDimension()-1, mesh-&gt;debug());
<a name="line1025">1025: </a>        Obj&lt;sieve_type&gt; newSieve = new sieve_type(mesh-&gt;comm(), mesh-&gt;debug());

<a name="line1027">1027: </a>        newMesh-&gt;setSieve(newSieve);
<a name="line1028">1028: </a>        newMesh-&gt;stratify();
<a name="line1029">1029: </a>        <font color="#4169E1">return</font> newMesh;
<a name="line1030">1030: </a>      }
<a name="line1031">1031: </a>      throw ALE::Exception(<font color="#666666">"Cannot handle partially interpolated meshes"</font>);
<a name="line1032">1032: </a>    };
<a name="line1033">1033: </a><strong><font color="#FF0000">  public:</font></strong>
<a name="line1034">1034: </a>    static Obj&lt;mesh_type&gt; interpolateMesh(const Obj&lt;mesh_type&gt;&amp; mesh) {
<a name="line1035">1035: </a>      const Obj&lt;sieve_type&gt;                              sieve       = mesh-&gt;getSieve();
<a name="line1036">1036: </a>      const int  dim         = mesh-&gt;getDimension();
<a name="line1037">1037: </a>      const int  numVertices = mesh-&gt;depthStratum(0)-&gt;size();
<a name="line1038">1038: </a>      const Obj&lt;typename mesh_type::label_sequence&gt;&amp;     cells       = mesh-&gt;heightStratum(0);
<a name="line1039">1039: </a>      const int  numCells    = cells-&gt;size();
<a name="line1040">1040: </a>      const int  corners     = sieve-&gt;cone(*cells-&gt;begin())-&gt;size();
<a name="line1041">1041: </a>      const int  firstVertex = numCells;
<a name="line1042">1042: </a>      const int  debug       = sieve-&gt;debug();
<a name="line1043">1043: </a>      Obj&lt;mesh_type&gt;                                     newMesh     = new mesh_type(mesh-&gt;comm(), dim, mesh-&gt;debug());
<a name="line1044">1044: </a>      Obj&lt;sieve_type&gt;                                    newSieve    = new sieve_type(mesh-&gt;comm(), mesh-&gt;debug());
<a name="line1045">1045: </a>      const Obj&lt;typename mesh_type::arrow_section_type&gt;&amp; orientation = newMesh-&gt;getArrowSection(<font color="#666666">"orientation"</font>);

<a name="line1047">1047: </a>      newMesh-&gt;setSieve(newSieve);
<a name="line1048">1048: </a>      // Create a map from dimension to the current element number <font color="#4169E1">for</font> that dimension
<a name="line1049">1049: </a><strong><font color="#FF0000">      std:</font></strong>:map&lt;int,point_type*&gt; curElement;
<a name="line1050">1050: </a><strong><font color="#FF0000">      std:</font></strong>:map&lt;int,PointArray&gt;  bdVertices;
<a name="line1051">1051: </a><strong><font color="#FF0000">      std:</font></strong>:map&lt;int,PointArray&gt;  faces;
<a name="line1052">1052: </a><strong><font color="#FF0000">      std:</font></strong>:map&lt;int,oPointArray&gt; oFaces;
<a name="line1053">1053: </a>      int                       curCell    = 0;
<a name="line1054">1054: </a>      int                       curVertex  = firstVertex;
<a name="line1055">1055: </a>      int                       newElement = firstVertex+numVertices;
<a name="line1056">1056: </a>      int                       o;

<a name="line1058">1058: </a>      curElement[0]   = &amp;curVertex;
<a name="line1059">1059: </a>      curElement[dim] = &amp;curCell;
<a name="line1060">1060: </a>      <font color="#4169E1">for</font>(int d = 1; d &lt; dim; d++) {
<a name="line1061">1061: </a>        curElement[d] = &amp;newElement;
<a name="line1062">1062: </a>      }
<a name="line1063">1063: </a>      typename mesh_type::label_sequence::iterator cBegin = cells-&gt;begin();
<a name="line1064">1064: </a>      typename mesh_type::label_sequence::iterator cEnd   = cells-&gt;end();

<a name="line1066">1066: </a>      <font color="#4169E1">for</font>(typename mesh_type::label_sequence::iterator c_iter = cBegin; c_iter != cEnd; ++c_iter) {
<a name="line1067">1067: </a>        typename sieve_type::point_type                           cell   = *c_iter;
<a name="line1068">1068: </a>        const Obj&lt;typename sieve_type::traits::coneSequence&gt;&amp;     cone   = sieve-&gt;cone(cell);
<a name="line1069">1069: </a>        const typename sieve_type::traits::coneSequence::iterator vBegin = cone-&gt;begin();
<a name="line1070">1070: </a>        const typename sieve_type::traits::coneSequence::iterator vEnd   = cone-&gt;end();

<a name="line1072">1072: </a>        // Build the cell
<a name="line1073">1073: </a>        bdVertices[dim].clear();
<a name="line1074">1074: </a>        <font color="#4169E1">for</font>(typename sieve_type::traits::coneSequence::iterator v_iter = vBegin; v_iter != vEnd; ++v_iter) {
<a name="line1075">1075: </a>          typename sieve_type::point_type vertex(*v_iter);

<a name="line1077">1077: </a>          <font color="#4169E1">if</font> (debug &gt; 1) {std::cout &lt;&lt; <font color="#666666">"Adding boundary vertex "</font> &lt;&lt; vertex &lt;&lt; std::endl;}
<a name="line1078">1078: </a>          bdVertices[dim].push_back(vertex);
<a name="line1079">1079: </a>        }
<a name="line1080">1080: </a>        <font color="#4169E1">if</font> (debug) {std::cout &lt;&lt; <font color="#666666">"cell "</font> &lt;&lt; cell &lt;&lt; <font color="#666666">" num boundary vertices "</font> &lt;&lt; bdVertices[dim].size() &lt;&lt; std::endl;}

<a name="line1082">1082: </a>        <font color="#4169E1">if</font> (corners != dim+1) {
<a name="line1083">1083: </a><strong><font color="#FF0000">          ALE:</font></strong>:SieveBuilder&lt;mesh_type&gt;::buildHexFaces(newSieve, dim, curElement, bdVertices, faces, cell);
<a name="line1084">1084: </a>        } <font color="#4169E1">else</font> {
<a name="line1085">1085: </a><strong><font color="#FF0000">          ALE:</font></strong>:SieveBuilder&lt;mesh_type&gt;::buildFaces(newSieve, orientation, dim, curElement, bdVertices, oFaces, cell, o);
<a name="line1086">1086: </a>        }
<a name="line1087">1087: </a>      }
<a name="line1088">1088: </a>      newMesh-&gt;stratify();
<a name="line1089">1089: </a>      newMesh-&gt;setRealSection(<font color="#666666">"coordinates"</font>, mesh-&gt;getRealSection(<font color="#666666">"coordinates"</font>));
<a name="line1090">1090: </a>      <font color="#4169E1">return</font> newMesh;
<a name="line1091">1091: </a>    };
<a name="line1092">1092: </a>  };
<a name="line1093">1093: </a>}

<a name="line1095">1095: </a><font color="#A020F0">#if 0</font>
<a name="line1096">1096: </a>namespace ALE {
<a name="line1097">1097: </a>  class MySelection {
<a name="line1098">1098: </a><strong><font color="#FF0000">  public:</font></strong>
<a name="line1099">1099: </a>    <font color="#4169E1">typedef</font> ALE::SieveAlg&lt;ALE::Mesh&gt; sieveAlg;
<a name="line1100">1100: </a>    <font color="#4169E1">typedef</font> ALE::Selection&lt;ALE::Mesh&gt; selection;
<a name="line1101">1101: </a>    <font color="#4169E1">typedef</font> ALE::Mesh::sieve_type sieve_type;
<a name="line1102">1102: </a>    <font color="#4169E1">typedef</font> ALE::Mesh::int_section_type int_section_type;
<a name="line1103">1103: </a>    <font color="#4169E1">typedef</font> ALE::Mesh::real_section_type real_section_type;
<a name="line1104">1104: </a>    <font color="#4169E1">typedef</font> std::set&lt;ALE::Mesh::point_type&gt; PointSet;
<a name="line1105">1105: </a>    <font color="#4169E1">typedef</font> std::vector&lt;ALE::Mesh::point_type&gt; PointArray;
<a name="line1106">1106: </a><strong><font color="#FF0000">  public:</font></strong>
<a name="line1107">1107: </a>    template&lt;class InputPoints&gt;
<a name="line1108">1108: </a>    static bool _compatibleOrientation(const Obj&lt;Mesh&gt;&amp; mesh,
<a name="line1109">1109: </a>                                       const ALE::Mesh::point_type&amp; p,
<a name="line1110">1110: </a>                                       const ALE::Mesh::point_type&amp; q,
<a name="line1111">1111: </a>                                       const int numFaultCorners,
<a name="line1112">1112: </a>                                       const int faultFaceSize,
<a name="line1113">1113: </a>                                       const int faultDepth,
<a name="line1114">1114: </a>                                       const Obj&lt;InputPoints&gt;&amp; points,
<a name="line1115">1115: </a>                                       int indices[],
<a name="line1116">1116: </a>                                       PointArray *origVertices,
<a name="line1117">1117: </a>                                       PointArray *faceVertices,
<a name="line1118">1118: </a>                                       PointArray *neighborVertices)
<a name="line1119">1119: </a>    {
<a name="line1120">1120: </a>      <font color="#4169E1">typedef</font> ALE::Selection&lt;ALE::Mesh&gt; selection;
<a name="line1121">1121: </a>      const int debug = mesh-&gt;debug();
<a name="line1122">1122: </a>      bool compatible;

<a name="line1124">1124: </a>      bool eOrient = selection::getOrientedFace(mesh, p, points, numFaultCorners, indices, origVertices, faceVertices);
<a name="line1125">1125: </a>      bool nOrient = selection::getOrientedFace(mesh, q, points, numFaultCorners, indices, origVertices, neighborVertices);

<a name="line1127">1127: </a>      <font color="#4169E1">if</font> (faultFaceSize &gt; 1) {
<a name="line1128">1128: </a>        <font color="#4169E1">if</font> (debug) {
<a name="line1129">1129: </a>          <font color="#4169E1">for</font>(PointArray::iterator v_iter = faceVertices-&gt;begin(); v_iter != faceVertices-&gt;end(); ++v_iter) {
<a name="line1130">1130: </a><strong><font color="#FF0000">            std:</font></strong>:cout &lt;&lt; <font color="#666666">"  face vertex "</font> &lt;&lt; *v_iter &lt;&lt; std::endl;
<a name="line1131">1131: </a>          }
<a name="line1132">1132: </a>          <font color="#4169E1">for</font>(PointArray::iterator v_iter = neighborVertices-&gt;begin(); v_iter != neighborVertices-&gt;end(); ++v_iter) {
<a name="line1133">1133: </a><strong><font color="#FF0000">            std:</font></strong>:cout &lt;&lt; <font color="#666666">"  neighbor vertex "</font> &lt;&lt; *v_iter &lt;&lt; std::endl;
<a name="line1134">1134: </a>          }
<a name="line1135">1135: </a>        }
<a name="line1136">1136: </a>        compatible = !(*faceVertices-&gt;begin() == *neighborVertices-&gt;begin());
<a name="line1137">1137: </a>      } <font color="#4169E1">else</font> {
<a name="line1138">1138: </a>        compatible = !(nOrient == eOrient);
<a name="line1139">1139: </a>      }
<a name="line1140">1140: </a>      <font color="#4169E1">return</font> compatible;
<a name="line1141">1141: </a>    };
<a name="line1142">1142: </a>    static void _replaceCell(const Obj&lt;sieve_type&gt;&amp; sieve,
<a name="line1143">1143: </a>                             const ALE::Mesh::point_type cell,
<a name="line1144">1144: </a><strong><font color="#FF0000">                             std:</font></strong>:map&lt;int,int&gt; *vertexRenumber,
<a name="line1145">1145: </a>                             const int debug)
<a name="line1146">1146: </a>    {
<a name="line1147">1147: </a>      bool       replace = false;
<a name="line1148">1148: </a>      PointArray newVertices;

<a name="line1150">1150: </a>      const Obj&lt;sieve_type::traits::coneSequence&gt;&amp; cCone = sieve-&gt;cone(cell);

<a name="line1152">1152: </a>      <font color="#4169E1">for</font>(sieve_type::traits::coneSequence::iterator v_iter = cCone-&gt;begin(); v_iter != cCone-&gt;end(); ++v_iter) {
<a name="line1153">1153: </a>        <font color="#4169E1">if</font> (vertexRenumber-&gt;find(*v_iter) != vertexRenumber-&gt;end()) {
<a name="line1154">1154: </a>          <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"    vertex "</font> &lt;&lt; (*vertexRenumber)[*v_iter] &lt;&lt; std::endl;
<a name="line1155">1155: </a>          newVertices.insert(newVertices.end(), (*vertexRenumber)[*v_iter]);
<a name="line1156">1156: </a>          replace = true;
<a name="line1157">1157: </a>        } <font color="#4169E1">else</font> {
<a name="line1158">1158: </a>          <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"    vertex "</font> &lt;&lt; *v_iter &lt;&lt; std::endl;
<a name="line1159">1159: </a>          newVertices.insert(newVertices.end(), *v_iter);
<a name="line1160">1160: </a>        } // <font color="#4169E1">if</font>/<font color="#4169E1">else</font>
<a name="line1161">1161: </a>      } // <font color="#4169E1">for</font>
<a name="line1162">1162: </a>      <font color="#4169E1">if</font> (replace) {
<a name="line1163">1163: </a>        <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"  Replacing cell "</font> &lt;&lt; cell &lt;&lt; std::endl;
<a name="line1164">1164: </a>        sieve-&gt;clearCone(cell);
<a name="line1165">1165: </a>        int color = 0;
<a name="line1166">1166: </a>        <font color="#4169E1">for</font>(PointArray::const_iterator v_iter = newVertices.begin(); v_iter != newVertices.end(); ++v_iter) {
<a name="line1167">1167: </a>          sieve-&gt;addArrow(*v_iter, cell, color++);
<a name="line1168">1168: </a>        } // <font color="#4169E1">for</font>
<a name="line1169">1169: </a>      }
<a name="line1170">1170: </a>    };
<a name="line1171">1171: </a>    template&lt;class InputPoints&gt;
<a name="line1172">1172: </a>    static void _computeCensoredDepth(const Obj&lt;ALE::Mesh&gt;&amp; mesh,
<a name="line1173">1173: </a>                                      const Obj&lt;ALE::Mesh::label_type&gt;&amp; depth,
<a name="line1174">1174: </a>                                      const Obj&lt;ALE::Mesh::sieve_type&gt;&amp; sieve,
<a name="line1175">1175: </a>                                      const Obj&lt;InputPoints&gt;&amp; points,
<a name="line1176">1176: </a>                                      const ALE::Mesh::point_type&amp; firstCohesiveCell,
<a name="line1177">1177: </a>                                      const Obj&lt;std::set&lt;ALE::Mesh::point_type&gt; &gt;&amp; modifiedPoints)
<a name="line1178">1178: </a>    {
<a name="line1179">1179: </a>      modifiedPoints-&gt;clear();

<a name="line1181">1181: </a>      <font color="#4169E1">for</font>(typename InputPoints::iterator p_iter = points-&gt;begin(); p_iter != points-&gt;end(); ++p_iter) {
<a name="line1182">1182: </a>        <font color="#4169E1">if</font> (*p_iter &gt;= firstCohesiveCell) <font color="#4169E1">continue</font>;
<a name="line1183">1183: </a>        // Compute the max depth of the points in the cone of p, and add 1
<a name="line1184">1184: </a>        int d0 = mesh-&gt;getValue(depth, *p_iter, -1);
<a name="line1185">1185: </a>        int d1 = mesh-&gt;getMaxValue(depth, sieve-&gt;cone(*p_iter), -1) + 1;

<a name="line1187">1187: </a>        <font color="#4169E1">if</font>(d1 != d0) {
<a name="line1188">1188: </a>          mesh-&gt;setValue(depth, *p_iter, d1);
<a name="line1189">1189: </a>          modifiedPoints-&gt;insert(*p_iter);
<a name="line1190">1190: </a>        }
<a name="line1191">1191: </a>      }
<a name="line1192">1192: </a>      // FIX: We would like to avoid the copy here with support()
<a name="line1193">1193: </a>      <font color="#4169E1">if</font>(modifiedPoints-&gt;size() &gt; 0) {
<a name="line1194">1194: </a>        _computeCensoredDepth(mesh, depth, sieve, sieve-&gt;support(modifiedPoints), firstCohesiveCell, modifiedPoints);
<a name="line1195">1195: </a>      }
<a name="line1196">1196: </a>    };
<a name="line1197">1197: </a>    static void create(const Obj&lt;Mesh&gt;&amp; mesh, Obj&lt;Mesh&gt; fault, const Obj&lt;Mesh::int_section_type&gt;&amp; groupField) {
<a name="line1198">1198: </a>      static <A href="../../docs/manualpages/Sys/PetscLogEvent.html#PetscLogEvent">PetscLogEvent</A> CreateFaultMesh_Event = 0, OrientFaultMesh_Event = 0, AddCohesivePoints_Event = 0, SplitMesh_Event = 0;

<a name="line1200">1200: </a>      <font color="#4169E1">if</font> (!CreateFaultMesh_Event) {
<a name="line1201">1201: </a>        <A href="../../docs/manualpages/Profiling/PetscLogEventRegister.html#PetscLogEventRegister">PetscLogEventRegister</A>(<font color="#666666">"CreateFaultMesh"</font>, 0,&amp;CreateFaultMesh_Event);
<a name="line1202">1202: </a>      }
<a name="line1203">1203: </a>      <font color="#4169E1">if</font> (!OrientFaultMesh_Event) {
<a name="line1204">1204: </a>        <A href="../../docs/manualpages/Profiling/PetscLogEventRegister.html#PetscLogEventRegister">PetscLogEventRegister</A>(<font color="#666666">"OrientFaultMesh"</font>, 0,&amp;OrientFaultMesh_Event);
<a name="line1205">1205: </a>      }
<a name="line1206">1206: </a>      <font color="#4169E1">if</font> (!AddCohesivePoints_Event) {
<a name="line1207">1207: </a>        <A href="../../docs/manualpages/Profiling/PetscLogEventRegister.html#PetscLogEventRegister">PetscLogEventRegister</A>(<font color="#666666">"AddCohesivePoints"</font>, 0,&amp;AddCohesivePoints_Event);
<a name="line1208">1208: </a>      }
<a name="line1209">1209: </a>      <font color="#4169E1">if</font> (!SplitMesh_Event) {
<a name="line1210">1210: </a>        <A href="../../docs/manualpages/Profiling/PetscLogEventRegister.html#PetscLogEventRegister">PetscLogEventRegister</A>(<font color="#666666">"SplitMesh"</font>, 0,&amp;SplitMesh_Event);
<a name="line1211">1211: </a>      }

<a name="line1213">1213: </a>      const Obj&lt;sieve_type&gt;&amp; sieve = mesh-&gt;getSieve();
<a name="line1214">1214: </a>      const int  debug      = mesh-&gt;debug();
<a name="line1215">1215: </a>      int        numCorners = 0;    // The number of vertices in a mesh cell
<a name="line1216">1216: </a>      int        faceSize   = 0;    // The number of vertices in a mesh face
<a name="line1217">1217: </a>      int       *indices    = NULL; // The indices of a face vertex set in a cell
<a name="line1218">1218: </a>      PointArray origVertices;
<a name="line1219">1219: </a>      PointArray faceVertices;
<a name="line1220">1220: </a>      PointArray neighborVertices;
<a name="line1221">1221: </a>      const bool constraintCell = false;

<a name="line1223">1223: </a>      <font color="#4169E1">if</font> (!mesh-&gt;commRank()) {
<a name="line1224">1224: </a>        numCorners = sieve-&gt;nCone(*mesh-&gt;heightStratum(0)-&gt;begin(), mesh-&gt;depth())-&gt;size();
<a name="line1225">1225: </a>        faceSize   = selection::numFaceVertices(mesh);
<a name="line1226">1226: </a>        indices    = new int[faceSize];
<a name="line1227">1227: </a>      }

<a name="line1229">1229: </a>      //int f = sieve-&gt;base()-&gt;size() + sieve-&gt;cap()-&gt;size();
<a name="line1230">1230: </a>      //ALE::Obj&lt;PointSet&gt; face = new PointSet();
<a name="line1231">1231: </a>
<a name="line1232">1232: </a>      // Create a sieve which captures the fault
<a name="line1233">1233: </a>      <A href="../../docs/manualpages/Profiling/PetscLogEventBegin.html#PetscLogEventBegin">PetscLogEventBegin</A>(CreateFaultMesh_Event,0,0,0,0);
<a name="line1234">1234: </a>      fault = ALE::Selection&lt;ALE::Mesh&gt;::submesh(mesh, groupField);
<a name="line1235">1235: </a>      <font color="#4169E1">if</font> (debug) {fault-&gt;view(<font color="#666666">"Fault mesh"</font>);}
<a name="line1236">1236: </a>      <A href="../../docs/manualpages/Profiling/PetscLogEventEnd.html#PetscLogEventEnd">PetscLogEventEnd</A>(CreateFaultMesh_Event,0,0,0,0);
<a name="line1237">1237: </a>      // Orient the fault sieve
<a name="line1238">1238: </a>      <A href="../../docs/manualpages/Profiling/PetscLogEventBegin.html#PetscLogEventBegin">PetscLogEventBegin</A>(OrientFaultMesh_Event,0,0,0,0);
<a name="line1239">1239: </a>      const Obj&lt;sieve_type&gt;&amp;                faultSieve = fault-&gt;getSieve();
<a name="line1240">1240: </a>      const ALE::Obj&lt;Mesh::label_sequence&gt;&amp; fFaces     = fault-&gt;heightStratum(1);
<a name="line1241">1241: </a>      int faultDepth      = fault-&gt;depth()-1; // Depth of fault cells
<a name="line1242">1242: </a>      int numFaultCorners = 0; // The number of vertices in a fault cell

<a name="line1244">1244: </a>      <font color="#4169E1">if</font> (!fault-&gt;commRank()) {
<a name="line1245">1245: </a>        numFaultCorners = faultSieve-&gt;nCone(*fFaces-&gt;begin(), faultDepth)-&gt;size();
<a name="line1246">1246: </a>        <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"  Fault corners "</font> &lt;&lt; numFaultCorners &lt;&lt; std::endl;
<a name="line1247">1247: </a>        assert(numFaultCorners == faceSize);
<a name="line1248">1248: </a>      }
<a name="line1249">1249: </a>      <A href="../../docs/manualpages/Profiling/PetscLogEventEnd.html#PetscLogEventEnd">PetscLogEventEnd</A>(OrientFaultMesh_Event,0,0,0,0);

<a name="line1251">1251: </a>      // Add new shadow vertices and possibly Lagrange multipler vertices
<a name="line1252">1252: </a>      <A href="../../docs/manualpages/Profiling/PetscLogEventBegin.html#PetscLogEventBegin">PetscLogEventBegin</A>(AddCohesivePoints_Event,0,0,0,0);
<a name="line1253">1253: </a>      const ALE::Obj&lt;Mesh::label_sequence&gt;&amp;   fVertices  = fault-&gt;depthStratum(0);
<a name="line1254">1254: </a>      const ALE::Obj&lt;std::set&lt;std::string&gt; &gt;&amp; groupNames = mesh-&gt;getIntSections();
<a name="line1255">1255: </a><strong><font color="#FF0000">      Mesh:</font></strong>:point_type newPoint = sieve-&gt;base()-&gt;size() + sieve-&gt;cap()-&gt;size();
<a name="line1256">1256: </a><strong><font color="#FF0000">      std:</font></strong>:map&lt;int,int&gt; vertexRenumber;
<a name="line1257">1257: </a>
<a name="line1258">1258: </a>      <font color="#4169E1">for</font>(Mesh::label_sequence::iterator v_iter = fVertices-&gt;begin(); v_iter != fVertices-&gt;end(); ++v_iter, ++newPoint) {
<a name="line1259">1259: </a>        vertexRenumber[*v_iter] = newPoint;
<a name="line1260">1260: </a>        <font color="#4169E1">if</font> (debug) {std::cout &lt;&lt; <font color="#666666">"Duplicating "</font> &lt;&lt; *v_iter &lt;&lt; <font color="#666666">" to "</font> &lt;&lt; vertexRenumber[*v_iter] &lt;&lt; std::endl;}

<a name="line1262">1262: </a>        // Add shadow and constraint vertices (<font color="#4169E1">if</font> they exist) to group
<a name="line1263">1263: </a>        // associated with fault
<a name="line1264">1264: </a>        groupField-&gt;addPoint(newPoint, 1);
<a name="line1265">1265: </a>        <font color="#4169E1">if</font> (constraintCell) groupField-&gt;addPoint(newPoint+1, 1);

<a name="line1267">1267: </a>        // Add shadow vertices to other groups, don't add constraint
<a name="line1268">1268: </a>        // vertices (<font color="#4169E1">if</font> they exist) because we don't want BC, etc to act
<a name="line1269">1269: </a>        // on constraint vertices
<a name="line1270">1270: </a>        <font color="#4169E1">for</font>(std::set&lt;std::string&gt;::const_iterator name = groupNames-&gt;begin(); name != groupNames-&gt;end(); ++name) {
<a name="line1271">1271: </a>          const ALE::Obj&lt;int_section_type&gt;&amp; group = mesh-&gt;getIntSection(*name);
<a name="line1272">1272: </a>          <font color="#4169E1">if</font> (group-&gt;hasPoint(*v_iter)) group-&gt;addPoint(newPoint, 1);
<a name="line1273">1273: </a>        }
<a name="line1274">1274: </a>        <font color="#4169E1">if</font> (constraintCell) newPoint++;
<a name="line1275">1275: </a>      }
<a name="line1276">1276: </a>      <font color="#4169E1">for</font>(std::set&lt;std::string&gt;::const_iterator name = groupNames-&gt;begin(); name != groupNames-&gt;end(); ++name) {
<a name="line1277">1277: </a>        mesh-&gt;reallocate(mesh-&gt;getIntSection(*name));
<a name="line1278">1278: </a>      }

<a name="line1280">1280: </a>      // Split the mesh along the fault sieve and create cohesive elements
<a name="line1281">1281: </a>      const Obj&lt;ALE::Mesh::label_sequence&gt;&amp;     faces       = fault-&gt;depthStratum(1);
<a name="line1282">1282: </a>      const Obj&lt;ALE::Mesh::arrow_section_type&gt;&amp; orientation = mesh-&gt;getArrowSection(<font color="#666666">"orientation"</font>);
<a name="line1283">1283: </a>      int firstCohesiveCell = newPoint;
<a name="line1284">1284: </a>      PointSet replaceCells;
<a name="line1285">1285: </a>      PointSet noReplaceCells;

<a name="line1287">1287: </a>      <font color="#4169E1">for</font>(ALE::Mesh::label_sequence::iterator f_iter = faces-&gt;begin(); f_iter != faces-&gt;end(); ++f_iter, ++newPoint) {
<a name="line1288">1288: </a>        <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"Considering fault face "</font> &lt;&lt; *f_iter &lt;&lt; std::endl;
<a name="line1289">1289: </a>        const ALE::Obj&lt;sieve_type::traits::supportSequence&gt;&amp; cells = faultSieve-&gt;support(*f_iter);
<a name="line1290">1290: </a>        const ALE::Mesh::arrow_section_type::point_type arrow(*cells-&gt;begin(), *f_iter);
<a name="line1291">1291: </a>        bool reversed = orientation-&gt;restrictPoint(arrow)[0] &lt; 0;
<a name="line1292">1292: </a>        const ALE::Mesh::point_type cell = *cells-&gt;begin();

<a name="line1294">1294: </a>        <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"  Checking orientation against cell "</font> &lt;&lt; cell &lt;&lt; std::endl;
<a name="line1295">1295: </a>        <font color="#4169E1">if</font> (numFaultCorners == 2) reversed = orientation-&gt;restrictPoint(arrow)[0] == -2;
<a name="line1296">1296: </a>        <font color="#4169E1">if</font> (reversed) {
<a name="line1297">1297: </a>          replaceCells.insert(cell);
<a name="line1298">1298: </a>          noReplaceCells.insert(*(++cells-&gt;begin()));
<a name="line1299">1299: </a>        } <font color="#4169E1">else</font> {
<a name="line1300">1300: </a>          replaceCells.insert(*(++cells-&gt;begin()));
<a name="line1301">1301: </a>          noReplaceCells.insert(cell);
<a name="line1302">1302: </a>        }
<a name="line1303">1303: </a>        //selection::getOrientedFace(mesh, cell, &amp;vertexRenumber, numCorners, indices, &amp;origVertices, &amp;faceVertices);
<a name="line1304">1304: </a>        //const Obj&lt;sieve_type::coneArray&gt; faceCone = faultSieve-&gt;nCone(*f_iter, faultDepth);

<a name="line1306">1306: </a>        // Adding cohesive cell (not interpolated)
<a name="line1307">1307: </a>        const Obj&lt;sieve_type::coneArray&gt;&amp;     fCone  = faultSieve-&gt;nCone(*f_iter, faultDepth);
<a name="line1308">1308: </a>        const sieve_type::coneArray::iterator fBegin = fCone-&gt;begin();
<a name="line1309">1309: </a>        const sieve_type::coneArray::iterator fEnd   = fCone-&gt;end();
<a name="line1310">1310: </a>        int color = 0;

<a name="line1312">1312: </a>        <font color="#4169E1">if</font> (debug) {std::cout &lt;&lt; <font color="#666666">"  Creating cohesive cell "</font> &lt;&lt; newPoint &lt;&lt; std::endl;}
<a name="line1313">1313: </a>        <font color="#4169E1">for</font>(sieve_type::coneArray::iterator v_iter = fBegin; v_iter != fEnd; ++v_iter) {
<a name="line1314">1314: </a>          <font color="#4169E1">if</font> (debug) {std::cout &lt;&lt; <font color="#666666">"    vertex "</font> &lt;&lt; *v_iter &lt;&lt; std::endl;}
<a name="line1315">1315: </a>          sieve-&gt;addArrow(*v_iter, newPoint, color++);
<a name="line1316">1316: </a>        }
<a name="line1317">1317: </a>        <font color="#4169E1">for</font>(sieve_type::coneArray::iterator v_iter = fBegin; v_iter != fEnd; ++v_iter) {
<a name="line1318">1318: </a>          <font color="#4169E1">if</font> (debug) {std::cout &lt;&lt; <font color="#666666">"    shadow vertex "</font> &lt;&lt; vertexRenumber[*v_iter] &lt;&lt; std::endl;}
<a name="line1319">1319: </a>          sieve-&gt;addArrow(vertexRenumber[*v_iter], newPoint, color++);
<a name="line1320">1320: </a>        }
<a name="line1321">1321: </a>      }
<a name="line1322">1322: </a>      <A href="../../docs/manualpages/Profiling/PetscLogEventEnd.html#PetscLogEventEnd">PetscLogEventEnd</A>(AddCohesivePoints_Event,0,0,0,0);
<a name="line1323">1323: </a>      // Replace all cells with a vertex on the fault that share a face with this one, or with one that does
<a name="line1324">1324: </a>      <A href="../../docs/manualpages/Profiling/PetscLogEventBegin.html#PetscLogEventBegin">PetscLogEventBegin</A>(SplitMesh_Event,0,0,0,0);
<a name="line1325">1325: </a>      const int_section_type::chart_type&amp;          chart    = groupField-&gt;getChart();
<a name="line1326">1326: </a>      const int_section_type::chart_type::iterator chartEnd = chart.end();

<a name="line1328">1328: </a>      <font color="#4169E1">for</font>(PointSet::const_iterator v_iter = chart.begin(); v_iter != chartEnd; ++v_iter) {
<a name="line1329">1329: </a>        bool modified = true;

<a name="line1331">1331: </a>        <font color="#4169E1">while</font>(modified) {
<a name="line1332">1332: </a>          modified = false;
<a name="line1333">1333: </a>          const Obj&lt;sieve_type::traits::supportSequence&gt;&amp;     neighbors = sieve-&gt;support(*v_iter);
<a name="line1334">1334: </a>          const sieve_type::traits::supportSequence::iterator end       = neighbors-&gt;end();

<a name="line1336">1336: </a>          <font color="#4169E1">for</font>(sieve_type::traits::supportSequence::iterator n_iter = neighbors-&gt;begin(); n_iter != end; ++n_iter) {
<a name="line1337">1337: </a>            <font color="#4169E1">if</font> (replaceCells.find(*n_iter)   != replaceCells.end())   <font color="#4169E1">continue</font>;
<a name="line1338">1338: </a>            <font color="#4169E1">if</font> (noReplaceCells.find(*n_iter) != noReplaceCells.end()) <font color="#4169E1">continue</font>;
<a name="line1339">1339: </a>            <font color="#4169E1">if</font> (*n_iter &gt;= firstCohesiveCell) <font color="#4169E1">continue</font>;
<a name="line1340">1340: </a>            <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"  Checking fault neighbor "</font> &lt;&lt; *n_iter &lt;&lt; std::endl;
<a name="line1341">1341: </a>            // If neighbors shares a faces with anyone in replaceCells, then add
<a name="line1342">1342: </a>            <font color="#4169E1">for</font>(PointSet::const_iterator c_iter = replaceCells.begin(); c_iter != replaceCells.end(); ++c_iter) {
<a name="line1343">1343: </a>              const ALE::Obj&lt;sieve_type::coneSet&gt;&amp; preFace = sieve-&gt;nMeet(*c_iter, *n_iter, mesh-&gt;depth());

<a name="line1345">1345: </a>              <font color="#4169E1">if</font> ((int) preFace-&gt;size() == faceSize) {
<a name="line1346">1346: </a>                <font color="#4169E1">if</font> (debug) std::cout &lt;&lt; <font color="#666666">"    Scheduling "</font> &lt;&lt; *n_iter &lt;&lt; <font color="#666666">" for replacement"</font> &lt;&lt; std::endl;
<a name="line1347">1347: </a>                replaceCells.insert(*n_iter);
<a name="line1348">1348: </a>                modified = true;
<a name="line1349">1349: </a>                <font color="#4169E1">break</font>;
<a name="line1350">1350: </a>              }
<a name="line1351">1351: </a>            }
<a name="line1352">1352: </a>          }
<a name="line1353">1353: </a>        }
<a name="line1354">1354: </a>      }
<a name="line1355">1355: </a>      <font color="#4169E1">for</font>(PointSet::const_iterator c_iter = replaceCells.begin(); c_iter != replaceCells.end(); ++c_iter) {
<a name="line1356">1356: </a>        _replaceCell(sieve, *c_iter, &amp;vertexRenumber, debug);
<a name="line1357">1357: </a>      }
<a name="line1358">1358: </a>      <font color="#4169E1">if</font> (!fault-&gt;commRank()) delete [] indices;
<a name="line1359">1359: </a>      mesh-&gt;stratify();
<a name="line1360">1360: </a>      const ALE::Obj&lt;Mesh::label_type&gt;&amp; label          = mesh-&gt;createLabel(std::string(<font color="#666666">"censored depth"</font>));
<a name="line1361">1361: </a>      const ALE::Obj&lt;PointSet&gt;          modifiedPoints = new PointSet();
<a name="line1362">1362: </a>      _computeCensoredDepth(mesh, label, mesh-&gt;getSieve(), mesh-&gt;getSieve()-&gt;roots(), firstCohesiveCell, modifiedPoints);
<a name="line1363">1363: </a>      <font color="#4169E1">if</font> (debug) mesh-&gt;view(<font color="#666666">"Mesh with Cohesive Elements"</font>);

<a name="line1365">1365: </a>      // Fix coordinates
<a name="line1366">1366: </a>      const Obj&lt;real_section_type&gt;&amp;         coordinates = mesh-&gt;getRealSection(<font color="#666666">"coordinates"</font>);
<a name="line1367">1367: </a>      const Obj&lt;ALE::Mesh::label_sequence&gt;&amp; fVertices2  = fault-&gt;depthStratum(0);

<a name="line1369">1369: </a>      <font color="#4169E1">for</font>(ALE::Mesh::label_sequence::iterator v_iter = fVertices2-&gt;begin(); v_iter != fVertices2-&gt;end(); ++v_iter) {
<a name="line1370">1370: </a>        coordinates-&gt;addPoint(vertexRenumber[*v_iter], coordinates-&gt;getFiberDimension(*v_iter));
<a name="line1371">1371: </a>        <font color="#4169E1">if</font> (constraintCell) {
<a name="line1372">1372: </a>          coordinates-&gt;addPoint(vertexRenumber[*v_iter]+1, coordinates-&gt;getFiberDimension(*v_iter));
<a name="line1373">1373: </a>        }
<a name="line1374">1374: </a>      }
<a name="line1375">1375: </a>      mesh-&gt;reallocate(coordinates);
<a name="line1376">1376: </a>      <font color="#4169E1">for</font>(ALE::Mesh::label_sequence::iterator v_iter = fVertices2-&gt;begin(); v_iter != fVertices2-&gt;end(); ++v_iter) {
<a name="line1377">1377: </a>        coordinates-&gt;updatePoint(vertexRenumber[*v_iter], coordinates-&gt;restrictPoint(*v_iter));
<a name="line1378">1378: </a>        <font color="#4169E1">if</font> (constraintCell) {
<a name="line1379">1379: </a>        coordinates-&gt;updatePoint(vertexRenumber[*v_iter]+1, coordinates-&gt;restrictPoint(*v_iter));
<a name="line1380">1380: </a>        }
<a name="line1381">1381: </a>      }
<a name="line1382">1382: </a>      <font color="#4169E1">if</font> (debug) coordinates-&gt;view(<font color="#666666">"Coordinates with shadow vertices"</font>);
<a name="line1383">1383: </a>      <A href="../../docs/manualpages/Profiling/PetscLogEventEnd.html#PetscLogEventEnd">PetscLogEventEnd</A>(SplitMesh_Event,0,0,0,0);
<a name="line1384">1384: </a>    };
<a name="line1385">1385: </a>  };
<a name="line1386">1386: </a>};
<a name="line1387">1387: </a><font color="#A020F0">#endif</font>

<a name="line1389">1389: </a><font color="#A020F0">#endif</font>
</pre>
</body>

</html>
