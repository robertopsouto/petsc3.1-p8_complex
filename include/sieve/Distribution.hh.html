<center><a href="Distribution.hh">Actual source code: Distribution.hh</a></center><br>

<html>
<head>
<title></title>
<meta name="generator" content="c2html 0.9.5">
<meta name="date" content="2011-03-17T19:15:17+00:00">
</head>

<body bgcolor="#FFFFFF">
<pre width="80"><a name="line1">  1: </a><font color="#A020F0">#ifndef included_ALE_Distribution_hh</font>
<a name="line2">  2: </a><strong><font color="#228B22">#define included_ALE_Distribution_hh</font></strong>

<a name="line4">  4: </a><font color="#A020F0">#ifndef  included_ALE_Mesh_hh</font>
<a name="line5">  5: </a><font color="#A020F0">#include &lt;Mesh.hh&gt;</font>
<a name="line6">  6: </a><font color="#A020F0">#endif</font>

<a name="line8">  8: </a><font color="#A020F0">#ifndef  included_ALE_Completion_hh</font>
<a name="line9">  9: </a><font color="#A020F0">#include &lt;Completion.hh&gt;</font>
<a name="line10"> 10: </a><font color="#A020F0">#endif</font>

<a name="line12"> 12: </a>// Attempt to unify all of the distribution mechanisms:
<a name="line13"> 13: </a>//   one to many  (distributeMesh)
<a name="line14"> 14: </a>//   many to one  (unifyMesh)
<a name="line15"> 15: </a>//   many to many (Numbering)
<a name="line16"> 16: </a>// as well as things being distributed
<a name="line17"> 17: </a>//   Section
<a name="line18"> 18: </a>//   Sieve        (This sends two sections, the points and cones)
<a name="line19"> 19: </a>//   Numbering    (Should be an integer section)
<a name="line20"> 20: </a>//   Global Order (should be an integer section with extra methods)
<a name="line21"> 21: </a>//
<a name="line22"> 22: </a>// 0) Create the new object to hold the communicated data
<a name="line23"> 23: </a>//
<a name="line24"> 24: </a>// 1) Create Overlap
<a name="line25"> 25: </a>//    There may be special ways to <font color="#4169E1">do</font> this based upon what we know at the time
<a name="line26"> 26: </a>//
<a name="line27"> 27: </a>// 2) Create send and receive sections over the interface
<a name="line28"> 28: </a>//    These have a flat topology now, consisting only of the overlap nodes
<a name="line29"> 29: </a>//    We could make a full topology on the overlap (maybe it is necessary <font color="#4169E1">for</font> higher order)
<a name="line30"> 30: </a>//
<a name="line31"> 31: </a>// 3) Communication section
<a name="line32"> 32: </a>//    Create sizer sections on interface (uses constant sizer)
<a name="line33"> 33: </a>//    Communicate sizes on interface (uses custom filler)
<a name="line34"> 34: </a>//      Fill send section
<a name="line35"> 35: </a>//      sendSection-&gt;startCommunication();
<a name="line36"> 36: </a>//      recvSection-&gt;startCommunication();
<a name="line37"> 37: </a>//      sendSection-&gt;endCommunication();
<a name="line38"> 38: </a>//      recvSection-&gt;endCommunication();
<a name="line39"> 39: </a>//
<a name="line40"> 40: </a>//    Create section on interface (uses previous sizer)
<a name="line41"> 41: </a>//    Communicate values on interface (uses custom filler)
<a name="line42"> 42: </a>//      Same stuff as above
<a name="line43"> 43: </a>//
<a name="line44"> 44: </a>// 4) Update new section with old local values (can be done in between the communication?)
<a name="line45"> 45: </a>//    Loop over patches in new topology
<a name="line46"> 46: </a>//      Loop over chart from patch in old atlas
<a name="line47"> 47: </a>//        If this point is in the new sieve from patch
<a name="line48"> 48: </a>//          Set to old fiber dimension
<a name="line49"> 49: </a>//    Order and allocate new section
<a name="line50"> 50: </a>//    Repeat loop, but update values
<a name="line51"> 51: </a>//
<a name="line52"> 52: </a>// 5) Update new section with old received values
<a name="line53"> 53: </a>//    Loop over patches in discrete topology of receive section (these are ranks)
<a name="line54"> 54: </a>//      Loop over base of discrete sieve (we should transform this to a chart to match above)
<a name="line55"> 55: </a>//        Get new patch from overlap, or should the receive patches be &lt;rank, patch&gt;?
<a name="line56"> 56: </a>//        Guaranteed to be in the new sieve from patch (but we could check anyway)
<a name="line57"> 57: </a>//          Set to recevied fiber dimension
<a name="line58"> 58: </a>//    Order and allocate new section
<a name="line59"> 59: </a>//    Repeat loop, but update values
<a name="line60"> 60: </a>//
<a name="line61"> 61: </a>// 6) Synchronize PETSc tags (can I get around this?)
<a name="line62"> 62: </a>namespace ALE {
<a name="line63"> 63: </a>  template&lt;typename Mesh, typename Partitioner = ALE::Partitioner&lt;&gt; &gt;
<a name="line64"> 64: </a>  class DistributionNew {
<a name="line65"> 65: </a><strong><font color="#FF0000">  public:</font></strong>
<a name="line66"> 66: </a>    <font color="#4169E1">typedef</font> Partitioner                                   partitioner_type;
<a name="line67"> 67: </a>    <font color="#4169E1">typedef</font> typename Mesh::point_type                     point_type;
<a name="line68"> 68: </a>    <font color="#4169E1">typedef</font> OrientedPoint&lt;point_type&gt;                     oriented_point_type;
<a name="line69"> 69: </a>    <font color="#4169E1">typedef</font> typename Partitioner::part_type               rank_type;
<a name="line70"> 70: </a>    <font color="#4169E1">typedef</font> ALE::ISection&lt;rank_type, point_type&gt;          partition_type;
<a name="line71"> 71: </a>    <font color="#4169E1">typedef</font> ALE::Section&lt;ALE::Pair&lt;int, point_type&gt;, point_type&gt;          cones_type;
<a name="line72"> 72: </a>    <font color="#4169E1">typedef</font> ALE::Section&lt;ALE::Pair&lt;int, point_type&gt;, oriented_point_type&gt; oriented_cones_type;
<a name="line73"> 73: </a><strong><font color="#FF0000">  public:</font></strong>
<a name="line74"> 74: </a>    template&lt;typename Sieve, typename NewSieve, typename Renumbering, typename SendOverlap, typename RecvOverlap&gt;
<a name="line75"> 75: </a>    static Obj&lt;cones_type&gt; completeCones(const Obj&lt;Sieve&gt;&amp; sieve, const Obj&lt;NewSieve&gt;&amp; newSieve, Renumbering&amp; renumbering, const Obj&lt;SendOverlap&gt;&amp; sendMeshOverlap, const Obj&lt;RecvOverlap&gt;&amp; recvMeshOverlap) {
<a name="line76"> 76: </a>      <font color="#4169E1">typedef</font> ALE::ConeSection&lt;Sieve&gt; cones_wrapper_type;
<a name="line77"> 77: </a>      Obj&lt;cones_wrapper_type&gt; cones        = new cones_wrapper_type(sieve);
<a name="line78"> 78: </a>      Obj&lt;cones_type&gt;         overlapCones = new cones_type(sieve-&gt;comm(), sieve-&gt;debug());

<a name="line80"> 80: </a><strong><font color="#FF0000">      ALE:</font></strong>:Pullback::SimpleCopy::copy(sendMeshOverlap, recvMeshOverlap, cones, overlapCones);
<a name="line81"> 81: </a>      <font color="#4169E1">if</font> (sieve-&gt;debug()) {overlapCones-&gt;view(<font color="#666666">"Overlap Cones"</font>);}
<a name="line82"> 82: </a>      // Inserts cones into parallelMesh (must renumber here)
<a name="line83"> 83: </a><strong><font color="#FF0000">      ALE:</font></strong>:Pullback::InsertionBinaryFusion::fuse(overlapCones, recvMeshOverlap, renumbering, newSieve);
<a name="line84"> 84: </a>      <font color="#4169E1">return</font> overlapCones;
<a name="line85"> 85: </a>    };
<a name="line86"> 86: </a>    template&lt;typename Sieve, typename NewSieve, typename SendOverlap, typename RecvOverlap&gt;
<a name="line87"> 87: </a>    static Obj&lt;oriented_cones_type&gt; completeConesV(const Obj&lt;Sieve&gt;&amp; sieve, const Obj&lt;NewSieve&gt;&amp; newSieve, const Obj&lt;SendOverlap&gt;&amp; sendMeshOverlap, const Obj&lt;RecvOverlap&gt;&amp; recvMeshOverlap) {
<a name="line88"> 88: </a>      <font color="#4169E1">typedef</font> ALE::OrientedConeSectionV&lt;Sieve&gt; oriented_cones_wrapper_type;
<a name="line89"> 89: </a>      Obj&lt;oriented_cones_wrapper_type&gt; cones        = new oriented_cones_wrapper_type(sieve);
<a name="line90"> 90: </a>      Obj&lt;oriented_cones_type&gt;         overlapCones = new oriented_cones_type(sieve-&gt;comm(), sieve-&gt;debug());

<a name="line92"> 92: </a><strong><font color="#FF0000">      ALE:</font></strong>:Pullback::SimpleCopy::copy(sendMeshOverlap, recvMeshOverlap, cones, overlapCones);
<a name="line93"> 93: </a>      <font color="#4169E1">if</font> (sieve-&gt;debug()) {overlapCones-&gt;view(<font color="#666666">"Overlap Cones"</font>);}
<a name="line94"> 94: </a><strong><font color="#FF0000">      ALE:</font></strong>:Pullback::InsertionBinaryFusion::fuse(overlapCones, recvMeshOverlap, newSieve);
<a name="line95"> 95: </a>      <font color="#4169E1">return</font> overlapCones;
<a name="line96"> 96: </a>    };
<a name="line97"> 97: </a>    template&lt;typename Sieve, typename NewSieve, typename Renumbering, typename SendOverlap, typename RecvOverlap&gt;
<a name="line98"> 98: </a>    static Obj&lt;oriented_cones_type&gt; completeConesV(const Obj&lt;Sieve&gt;&amp; sieve, const Obj&lt;NewSieve&gt;&amp; newSieve, Renumbering&amp; renumbering, const Obj&lt;SendOverlap&gt;&amp; sendMeshOverlap, const Obj&lt;RecvOverlap&gt;&amp; recvMeshOverlap) {
<a name="line99"> 99: </a>      <font color="#4169E1">typedef</font> ALE::OrientedConeSectionV&lt;Sieve&gt; oriented_cones_wrapper_type;
<a name="line100">100: </a>      Obj&lt;oriented_cones_wrapper_type&gt; cones        = new oriented_cones_wrapper_type(sieve);
<a name="line101">101: </a>      Obj&lt;oriented_cones_type&gt;         overlapCones = new oriented_cones_type(sieve-&gt;comm(), sieve-&gt;debug());

<a name="line103">103: </a><strong><font color="#FF0000">      ALE:</font></strong>:Pullback::SimpleCopy::copy(sendMeshOverlap, recvMeshOverlap, cones, overlapCones);
<a name="line104">104: </a>      <font color="#4169E1">if</font> (sieve-&gt;debug()) {overlapCones-&gt;view(<font color="#666666">"Overlap Cones"</font>);}
<a name="line105">105: </a>      // Inserts cones into parallelMesh (must renumber here)
<a name="line106">106: </a><strong><font color="#FF0000">      ALE:</font></strong>:Pullback::InsertionBinaryFusion::fuse(overlapCones, recvMeshOverlap, renumbering, newSieve);
<a name="line107">107: </a>      <font color="#4169E1">return</font> overlapCones;
<a name="line108">108: </a>    };
<a name="line109">109: </a>    // Given a partition of sieve points, copy the mesh pieces to each process and fuse into the new mesh
<a name="line110">110: </a>    //   Return overlaps <font color="#4169E1">for</font> the cone communication
<a name="line111">111: </a>    template&lt;typename Renumbering, typename NewMesh, typename SendOverlap, typename RecvOverlap&gt;
<a name="line112">112: </a>    static void completeMesh(const Obj&lt;Mesh&gt;&amp; mesh, const Obj&lt;partition_type&gt;&amp; partition, Renumbering&amp; renumbering, const Obj&lt;NewMesh&gt;&amp; newMesh, const Obj&lt;SendOverlap&gt;&amp; sendMeshOverlap, const Obj&lt;RecvOverlap&gt;&amp; recvMeshOverlap) {
<a name="line113">113: </a>      <font color="#4169E1">typedef</font> ALE::Sifter&lt;rank_type,rank_type,rank_type&gt; part_send_overlap_type;
<a name="line114">114: </a>      <font color="#4169E1">typedef</font> ALE::Sifter&lt;rank_type,rank_type,rank_type&gt; part_recv_overlap_type;
<a name="line115">115: </a>      const Obj&lt;part_send_overlap_type&gt; sendOverlap = new part_send_overlap_type(partition-&gt;comm());
<a name="line116">116: </a>      const Obj&lt;part_recv_overlap_type&gt; recvOverlap = new part_recv_overlap_type(partition-&gt;comm());

<a name="line118">118: </a>      // Create overlap <font color="#4169E1">for</font> partition points
<a name="line119">119: </a>      //   TODO: This needs to be generalized <font color="#4169E1">for</font> multiple sources
<a name="line120">120: </a><strong><font color="#FF0000">      Partitioner:</font></strong>:createDistributionPartOverlap(sendOverlap, recvOverlap);
<a name="line121">121: </a>      // Communicate partition pieces to processes
<a name="line122">122: </a>      Obj&lt;partition_type&gt; overlapPartition = new partition_type(partition-&gt;comm(), partition-&gt;debug());

<a name="line124">124: </a>      overlapPartition-&gt;setChart(partition-&gt;getChart());
<a name="line125">125: </a><strong><font color="#FF0000">      ALE:</font></strong>:Pullback::SimpleCopy::copy(sendOverlap, recvOverlap, partition, overlapPartition);
<a name="line126">126: </a>      // Create renumbering
<a name="line127">127: </a>      const int         rank           = partition-&gt;commRank();
<a name="line128">128: </a>      const point_type *localPoints    = partition-&gt;restrictPoint(rank);
<a name="line129">129: </a>      const int         numLocalPoints = partition-&gt;getFiberDimension(rank);

<a name="line131">131: </a>      <font color="#4169E1">for</font>(point_type p = 0; p &lt; numLocalPoints; ++p) {
<a name="line132">132: </a>        renumbering[localPoints[p]] = p;
<a name="line133">133: </a>      }
<a name="line134">134: </a>      const Obj&lt;typename part_recv_overlap_type::traits::baseSequence&gt; rPoints    = recvOverlap-&gt;base();
<a name="line135">135: </a>      point_type                                                       localPoint = numLocalPoints;

<a name="line137">137: </a>      <font color="#4169E1">for</font>(typename part_recv_overlap_type::traits::baseSequence::iterator p_iter = rPoints-&gt;begin(); p_iter != rPoints-&gt;end(); ++p_iter) {
<a name="line138">138: </a>        const Obj&lt;typename part_recv_overlap_type::coneSequence&gt;&amp; ranks           = recvOverlap-&gt;cone(*p_iter);
<a name="line139">139: </a>        const rank_type&amp;                                          remotePartPoint = ranks-&gt;begin().color();
<a name="line140">140: </a>        const point_type                                         *points          = overlapPartition-&gt;restrictPoint(remotePartPoint);
<a name="line141">141: </a>        const int                                                 numPoints       = overlapPartition-&gt;getFiberDimension(remotePartPoint);

<a name="line143">143: </a>        <font color="#4169E1">for</font>(int i = 0; i &lt; numPoints; ++i) {
<a name="line144">144: </a>          renumbering[points[i]] = localPoint++;
<a name="line145">145: </a>        }
<a name="line146">146: </a>      }
<a name="line147">147: </a>      // Create mesh overlap from partition overlap
<a name="line148">148: </a>      //   TODO: Generalize to redistribution (receive from multiple sources)
<a name="line149">149: </a><strong><font color="#FF0000">      Partitioner:</font></strong>:createDistributionMeshOverlap(partition, recvOverlap, renumbering, overlapPartition, sendMeshOverlap, recvMeshOverlap);
<a name="line150">150: </a>      // Send cones
<a name="line151">151: </a>      completeCones(mesh-&gt;getSieve(), newMesh-&gt;getSieve(), renumbering, sendMeshOverlap, recvMeshOverlap);
<a name="line152">152: </a>    };
<a name="line153">153: </a>    template&lt;typename Renumbering, typename NewMesh, typename SendOverlap, typename RecvOverlap&gt;
<a name="line154">154: </a>    static void completeBaseV(const Obj&lt;Mesh&gt;&amp; mesh, const Obj&lt;partition_type&gt;&amp; partition, Renumbering&amp; renumbering, const Obj&lt;NewMesh&gt;&amp; newMesh, const Obj&lt;SendOverlap&gt;&amp; sendMeshOverlap, const Obj&lt;RecvOverlap&gt;&amp; recvMeshOverlap) {
<a name="line155">155: </a>      <font color="#4169E1">typedef</font> ALE::Sifter&lt;rank_type,rank_type,rank_type&gt; part_send_overlap_type;
<a name="line156">156: </a>      <font color="#4169E1">typedef</font> ALE::Sifter&lt;rank_type,rank_type,rank_type&gt; part_recv_overlap_type;
<a name="line157">157: </a>      const Obj&lt;part_send_overlap_type&gt; sendOverlap = new part_send_overlap_type(partition-&gt;comm());
<a name="line158">158: </a>      const Obj&lt;part_recv_overlap_type&gt; recvOverlap = new part_recv_overlap_type(partition-&gt;comm());

<a name="line160">160: </a>      // Create overlap <font color="#4169E1">for</font> partition points
<a name="line161">161: </a>      //   TODO: This needs to be generalized <font color="#4169E1">for</font> multiple sources
<a name="line162">162: </a><strong><font color="#FF0000">      Partitioner:</font></strong>:createDistributionPartOverlap(sendOverlap, recvOverlap);
<a name="line163">163: </a>      // Communicate partition pieces to processes
<a name="line164">164: </a>      Obj&lt;partition_type&gt; overlapPartition = new partition_type(partition-&gt;comm(), partition-&gt;debug());

<a name="line166">166: </a>      overlapPartition-&gt;setChart(partition-&gt;getChart());
<a name="line167">167: </a><strong><font color="#FF0000">      ALE:</font></strong>:Pullback::SimpleCopy::copy(sendOverlap, recvOverlap, partition, overlapPartition);
<a name="line168">168: </a>      // Create renumbering
<a name="line169">169: </a>      const int         rank           = partition-&gt;commRank();
<a name="line170">170: </a>      const point_type *localPoints    = partition-&gt;restrictPoint(rank);
<a name="line171">171: </a>      const int         numLocalPoints = partition-&gt;getFiberDimension(rank);

<a name="line173">173: </a>      <font color="#4169E1">for</font>(point_type p = 0; p &lt; numLocalPoints; ++p) {
<a name="line174">174: </a>        ///std::cout &lt;&lt;<font color="#666666">"["</font>&lt;&lt;partition-&gt;commRank()&lt;&lt;<font color="#666666">"]: local renumbering "</font> &lt;&lt; localPoints[p] &lt;&lt; <font color="#666666">" --&gt; "</font> &lt;&lt; p &lt;&lt; std::endl;
<a name="line175">175: </a>        renumbering[localPoints[p]] = p;
<a name="line176">176: </a>      }
<a name="line177">177: </a>      const Obj&lt;typename part_recv_overlap_type::traits::baseSequence&gt; rPoints    = recvOverlap-&gt;base();
<a name="line178">178: </a>      point_type                                                       localPoint = numLocalPoints;

<a name="line180">180: </a>      <font color="#4169E1">for</font>(typename part_recv_overlap_type::traits::baseSequence::iterator p_iter = rPoints-&gt;begin(); p_iter != rPoints-&gt;end(); ++p_iter) {
<a name="line181">181: </a>        const Obj&lt;typename part_recv_overlap_type::coneSequence&gt;&amp; ranks           = recvOverlap-&gt;cone(*p_iter);
<a name="line182">182: </a>        const rank_type&amp;                                          remotePartPoint = ranks-&gt;begin().color();
<a name="line183">183: </a>        const point_type                                         *points          = overlapPartition-&gt;restrictPoint(remotePartPoint);
<a name="line184">184: </a>        const int                                                 numPoints       = overlapPartition-&gt;getFiberDimension(remotePartPoint);

<a name="line186">186: </a>        <font color="#4169E1">for</font>(int i = 0; i &lt; numPoints; ++i) {
<a name="line187">187: </a>          ///std::cout &lt;&lt;<font color="#666666">"["</font>&lt;&lt;partition-&gt;commRank()&lt;&lt;<font color="#666666">"]: remote renumbering "</font> &lt;&lt; points[i] &lt;&lt; <font color="#666666">" --&gt; "</font> &lt;&lt; localPoint &lt;&lt; std::endl;
<a name="line188">188: </a>          renumbering[points[i]] = localPoint++;
<a name="line189">189: </a>        }
<a name="line190">190: </a>      }
<a name="line191">191: </a>      newMesh-&gt;getSieve()-&gt;setChart(typename NewMesh::sieve_type::chart_type(0, renumbering.size()));
<a name="line192">192: </a>      // Create mesh overlap from partition overlap
<a name="line193">193: </a>      //   TODO: Generalize to redistribution (receive from multiple sources)
<a name="line194">194: </a><strong><font color="#FF0000">      Partitioner:</font></strong>:createDistributionMeshOverlap(partition, recvOverlap, renumbering, overlapPartition, sendMeshOverlap, recvMeshOverlap);
<a name="line195">195: </a>    };
<a name="line196">196: </a>    template&lt;typename NewMesh, typename Renumbering, typename SendOverlap, typename RecvOverlap&gt;
<a name="line197">197: </a>    static Obj&lt;partition_type&gt; distributeMesh(const Obj&lt;Mesh&gt;&amp; mesh, const Obj&lt;NewMesh&gt;&amp; newMesh, Renumbering&amp; renumbering, const Obj&lt;SendOverlap&gt;&amp; sendMeshOverlap, const Obj&lt;RecvOverlap&gt;&amp; recvMeshOverlap, const int height = 0) {
<a name="line198">198: </a>      const Obj&lt;partition_type&gt; cellPartition = new partition_type(mesh-&gt;comm(), 0, mesh-&gt;commSize(), mesh-&gt;debug());
<a name="line199">199: </a>      const Obj&lt;partition_type&gt; partition     = new partition_type(mesh-&gt;comm(), 0, mesh-&gt;commSize(), mesh-&gt;debug());

<a name="line201">201: </a>      // Create the cell partition
<a name="line202">202: </a><strong><font color="#FF0000">      Partitioner:</font></strong>:createPartition(mesh, cellPartition, height);
<a name="line203">203: </a>      <font color="#4169E1">if</font> (mesh-&gt;debug()) {
<a name="line204">204: </a>        <A href="../../docs/manualpages/Viewer/PetscViewer.html#PetscViewer">PetscViewer</A>    viewer;

<a name="line207">207: </a>        cellPartition-&gt;view(<font color="#666666">"Cell Partition"</font>);
<a name="line208">208: </a>        <A href="../../docs/manualpages/Viewer/PetscViewerCreate.html#PetscViewerCreate">PetscViewerCreate</A>(mesh-&gt;comm(), &amp;viewer);<A href="../../docs/manualpages/Sys/CHKERRXX.html#CHKERRXX">CHKERRXX</A>(ierr);
<a name="line209">209: </a>        <A href="../../docs/manualpages/Viewer/PetscViewerSetType.html#PetscViewerSetType">PetscViewerSetType</A>(viewer, PETSC_VIEWER_ASCII);<A href="../../docs/manualpages/Sys/CHKERRXX.html#CHKERRXX">CHKERRXX</A>(ierr);
<a name="line210">210: </a>        <A href="../../docs/manualpages/Viewer/PetscViewerFileSetName.html#PetscViewerFileSetName">PetscViewerFileSetName</A>(viewer, <font color="#666666">"mesh.vtk"</font>);<A href="../../docs/manualpages/Sys/CHKERRXX.html#CHKERRXX">CHKERRXX</A>(ierr);
<a name="line211">211: </a>        ///TODO MeshView_Sieve_Ascii(mesh, cellPartition, viewer);<A href="../../docs/manualpages/Sys/CHKERRXX.html#CHKERRXX">CHKERRXX</A>(ierr);
<a name="line212">212: </a>        <A href="../../docs/manualpages/Viewer/PetscViewerDestroy.html#PetscViewerDestroy">PetscViewerDestroy</A>(viewer);<A href="../../docs/manualpages/Sys/CHKERRXX.html#CHKERRXX">CHKERRXX</A>(ierr);
<a name="line213">213: </a>      }
<a name="line214">214: </a>      // Close the partition over sieve points
<a name="line215">215: </a><strong><font color="#FF0000">      Partitioner:</font></strong>:createPartitionClosure(mesh, cellPartition, partition, height);
<a name="line216">216: </a>      <font color="#4169E1">if</font> (mesh-&gt;debug()) {partition-&gt;view(<font color="#666666">"Partition"</font>);}
<a name="line217">217: </a>      // Create the remote meshes
<a name="line218">218: </a>      completeMesh(mesh, partition, renumbering, newMesh, sendMeshOverlap, recvMeshOverlap);
<a name="line219">219: </a>      // Create the local mesh
<a name="line220">220: </a><strong><font color="#FF0000">      Partitioner:</font></strong>:createLocalMesh(mesh, partition, renumbering, newMesh, height);
<a name="line221">221: </a>      newMesh-&gt;stratify();
<a name="line222">222: </a>      <font color="#4169E1">return</font> partition;
<a name="line223">223: </a>    };
<a name="line224">224: </a>    template&lt;typename NewMesh, typename Renumbering, typename SendOverlap, typename RecvOverlap&gt;
<a name="line225">225: </a>    static Obj&lt;partition_type&gt; distributeMeshAndSections(const Obj&lt;Mesh&gt;&amp; mesh, const Obj&lt;NewMesh&gt;&amp; newMesh, Renumbering&amp; renumbering, const Obj&lt;SendOverlap&gt;&amp; sendMeshOverlap, const Obj&lt;RecvOverlap&gt;&amp; recvMeshOverlap, const int height = 0) {
<a name="line226">226: </a>      Obj&lt;partition_type&gt; partition = distributeMesh(mesh, newMesh, renumbering, sendMeshOverlap, recvMeshOverlap, height);

<a name="line228">228: </a>      // Distribute the coordinates
<a name="line229">229: </a>      const Obj&lt;typename Mesh::real_section_type&gt;&amp; coordinates         = mesh-&gt;getRealSection(<font color="#666666">"coordinates"</font>);
<a name="line230">230: </a>      const Obj&lt;typename Mesh::real_section_type&gt;&amp; parallelCoordinates = newMesh-&gt;getRealSection(<font color="#666666">"coordinates"</font>);

<a name="line232">232: </a>      newMesh-&gt;setupCoordinates(parallelCoordinates);
<a name="line233">233: </a>      distributeSection(coordinates, partition, renumbering, sendMeshOverlap, recvMeshOverlap, parallelCoordinates);
<a name="line234">234: </a>      // Distribute other sections
<a name="line235">235: </a>      <font color="#4169E1">if</font> (mesh-&gt;getRealSections()-&gt;size() &gt; 1) {
<a name="line236">236: </a>        Obj&lt;std::set&lt;std::string&gt; &gt; names = mesh-&gt;getRealSections();

<a name="line238">238: </a>        <font color="#4169E1">for</font>(std::set&lt;std::string&gt;::const_iterator n_iter = names-&gt;begin(); n_iter != names-&gt;end(); ++n_iter) {
<a name="line239">239: </a>          <font color="#4169E1">if</font> (*n_iter == <font color="#666666">"coordinates"</font>)   <font color="#4169E1">continue</font>;
<a name="line240">240: </a>          distributeSection(mesh-&gt;getRealSection(*n_iter), partition, renumbering, sendMeshOverlap, recvMeshOverlap, newMesh-&gt;getRealSection(*n_iter));
<a name="line241">241: </a>        }
<a name="line242">242: </a>      }
<a name="line243">243: </a>      <font color="#4169E1">if</font> (mesh-&gt;getIntSections()-&gt;size() &gt; 0) {
<a name="line244">244: </a>        Obj&lt;std::set&lt;std::string&gt; &gt; names = mesh-&gt;getIntSections();

<a name="line246">246: </a>        <font color="#4169E1">for</font>(std::set&lt;std::string&gt;::const_iterator n_iter = names-&gt;begin(); n_iter != names-&gt;end(); ++n_iter) {
<a name="line247">247: </a>          distributeSection(mesh-&gt;getIntSection(*n_iter), partition, renumbering, sendMeshOverlap, recvMeshOverlap, newMesh-&gt;getIntSection(*n_iter));
<a name="line248">248: </a>        }
<a name="line249">249: </a>      }
<a name="line250">250: </a>      <font color="#4169E1">if</font> (mesh-&gt;getArrowSections()-&gt;size() &gt; 1) {
<a name="line251">251: </a>        throw ALE::Exception(<font color="#666666">"Need to distribute more arrow sections"</font>);
<a name="line252">252: </a>      }
<a name="line253">253: </a>      // Distribute labels
<a name="line254">254: </a>      const typename Mesh::labels_type&amp; labels = mesh-&gt;getLabels();

<a name="line256">256: </a>      <font color="#4169E1">for</font>(typename Mesh::labels_type::const_iterator l_iter = labels.begin(); l_iter != labels.end(); ++l_iter) {
<a name="line257">257: </a>        <font color="#4169E1">if</font> (newMesh-&gt;hasLabel(l_iter-&gt;first)) <font color="#4169E1">continue</font>;
<a name="line258">258: </a>        const Obj&lt;typename Mesh::label_type&gt;&amp; origLabel = l_iter-&gt;second;
<a name="line259">259: </a>        const Obj&lt;typename Mesh::label_type&gt;&amp; newLabel  = newMesh-&gt;createLabel(l_iter-&gt;first);
<a name="line260">260: </a>        // Get remote labels
<a name="line261">261: </a><strong><font color="#FF0000">        ALE:</font></strong>:New::Completion&lt;Mesh,typename Mesh::point_type&gt;::scatterCones(origLabel, newLabel, sendMeshOverlap, recvMeshOverlap, renumbering);
<a name="line262">262: </a>        // Create local label
<a name="line263">263: </a>        newLabel-&gt;add(origLabel, newMesh-&gt;getSieve(), renumbering);
<a name="line264">264: </a>      }
<a name="line265">265: </a>      <font color="#4169E1">return</font> partition;
<a name="line266">266: </a>    };
<a name="line267">267: </a>    template&lt;typename NewMesh, typename Renumbering, typename SendOverlap, typename RecvOverlap&gt;
<a name="line268">268: </a>    static Obj&lt;partition_type&gt; distributeMeshV(const Obj&lt;Mesh&gt;&amp; mesh, const Obj&lt;NewMesh&gt;&amp; newMesh, Renumbering&amp; renumbering, const Obj&lt;SendOverlap&gt;&amp; sendMeshOverlap, const Obj&lt;RecvOverlap&gt;&amp; recvMeshOverlap, const int height = 0) {
<a name="line269">269: </a>      const Obj&lt;partition_type&gt; cellPartition = new partition_type(mesh-&gt;comm(), 0, mesh-&gt;commSize(), mesh-&gt;debug());
<a name="line270">270: </a>      const Obj&lt;partition_type&gt; partition     = new partition_type(mesh-&gt;comm(), 0, mesh-&gt;commSize(), mesh-&gt;debug());

<a name="line272">272: </a><strong><font color="#FF0000">      PETSc:</font></strong>:Log::Event(<font color="#666666">"DistributeMesh"</font>).begin();
<a name="line273">273: </a>      // Create the cell partition
<a name="line274">274: </a><strong><font color="#FF0000">      Partitioner:</font></strong>:createPartitionV(mesh, cellPartition, height);
<a name="line275">275: </a>      <font color="#4169E1">if</font> (mesh-&gt;debug()) {
<a name="line276">276: </a>        <A href="../../docs/manualpages/Viewer/PetscViewer.html#PetscViewer">PetscViewer</A>    viewer;

<a name="line279">279: </a>        cellPartition-&gt;view(<font color="#666666">"Cell Partition"</font>);
<a name="line280">280: </a>        <A href="../../docs/manualpages/Viewer/PetscViewerCreate.html#PetscViewerCreate">PetscViewerCreate</A>(mesh-&gt;comm(), &amp;viewer);<A href="../../docs/manualpages/Sys/CHKERRXX.html#CHKERRXX">CHKERRXX</A>(ierr);
<a name="line281">281: </a>        <A href="../../docs/manualpages/Viewer/PetscViewerSetType.html#PetscViewerSetType">PetscViewerSetType</A>(viewer, PETSC_VIEWER_ASCII);<A href="../../docs/manualpages/Sys/CHKERRXX.html#CHKERRXX">CHKERRXX</A>(ierr);
<a name="line282">282: </a>        <A href="../../docs/manualpages/Viewer/PetscViewerFileSetName.html#PetscViewerFileSetName">PetscViewerFileSetName</A>(viewer, <font color="#666666">"mesh.vtk"</font>);<A href="../../docs/manualpages/Sys/CHKERRXX.html#CHKERRXX">CHKERRXX</A>(ierr);
<a name="line283">283: </a>        ///TODO MeshView_Sieve_Ascii(mesh, cellPartition, viewer);<A href="../../docs/manualpages/Sys/CHKERRXX.html#CHKERRXX">CHKERRXX</A>(ierr);
<a name="line284">284: </a>        <A href="../../docs/manualpages/Viewer/PetscViewerDestroy.html#PetscViewerDestroy">PetscViewerDestroy</A>(viewer);<A href="../../docs/manualpages/Sys/CHKERRXX.html#CHKERRXX">CHKERRXX</A>(ierr);
<a name="line285">285: </a>      }
<a name="line286">286: </a>      // Close the partition over sieve points
<a name="line287">287: </a><strong><font color="#FF0000">      Partitioner:</font></strong>:createPartitionClosureV(mesh, cellPartition, partition, height);
<a name="line288">288: </a>      <font color="#4169E1">if</font> (mesh-&gt;debug()) {partition-&gt;view(<font color="#666666">"Partition"</font>);}
<a name="line289">289: </a>      // Create the remote bases
<a name="line290">290: </a>      completeBaseV(mesh, partition, renumbering, newMesh, sendMeshOverlap, recvMeshOverlap);
<a name="line291">291: </a>      // Size the local mesh
<a name="line292">292: </a><strong><font color="#FF0000">      Partitioner:</font></strong>:sizeLocalMeshV(mesh, partition, renumbering, newMesh, height);
<a name="line293">293: </a>      // Create the remote meshes
<a name="line294">294: </a>      completeConesV(mesh-&gt;getSieve(), newMesh-&gt;getSieve(), renumbering, sendMeshOverlap, recvMeshOverlap);
<a name="line295">295: </a>      // Create the local mesh
<a name="line296">296: </a><strong><font color="#FF0000">      Partitioner:</font></strong>:createLocalMeshV(mesh, partition, renumbering, newMesh, height);
<a name="line297">297: </a>      newMesh-&gt;getSieve()-&gt;symmetrize();
<a name="line298">298: </a>      newMesh-&gt;stratify();
<a name="line299">299: </a><strong><font color="#FF0000">      PETSc:</font></strong>:Log::Event(<font color="#666666">"DistributeMesh"</font>).end();
<a name="line300">300: </a>      <font color="#4169E1">return</font> partition;
<a name="line301">301: </a>    };
<a name="line302">302: </a>    // distributeMeshV:
<a name="line303">303: </a>    //   createPartitionV (can be dumb)
<a name="line304">304: </a>    //   createPartitionClosureV (should be low memory)
<a name="line305">305: </a>    //   completeBaseV (???)
<a name="line306">306: </a>    //     Partitioner::createDistributionPartOverlap (low memory)
<a name="line307">307: </a>    //     copy points to partitions (uses small overlap and fake sections)
<a name="line308">308: </a>    //     renumber (map is potentially big, can measure)
<a name="line309">309: </a>    //     Partitioner::createDistributionMeshOverlap (should be large <font color="#4169E1">for</font> distribution)
<a name="line310">310: </a>    //       sendMeshOverlap is localPoint--- remotePoint ---&gt;remoteRank
<a name="line311">311: </a>    //       recvMeshOverlap is remoteRank--- remotePoint ---&gt;localPoint
<a name="line312">312: </a>    //   sizeLocalMeshV (should be low memory)
<a name="line313">313: </a>    //   completeConesV (???)
<a name="line314">314: </a>    //   createLocalMesh (should be low memory)
<a name="line315">315: </a>    //   symmetrize
<a name="line316">316: </a>    //   stratify
<a name="line317">317: </a>    template&lt;typename NewMesh&gt;
<a name="line318">318: </a>    static void distributeMeshAndSectionsV(const Obj&lt;Mesh&gt;&amp; mesh, const Obj&lt;NewMesh&gt;&amp; newMesh) {
<a name="line319">319: </a>      <font color="#4169E1">typedef</font> typename Mesh::point_type point_type;

<a name="line321">321: </a>      const Obj&lt;typename Mesh::send_overlap_type&gt; sendMeshOverlap = new typename Mesh::send_overlap_type(mesh-&gt;comm(), mesh-&gt;debug());
<a name="line322">322: </a>      const Obj&lt;typename Mesh::recv_overlap_type&gt; recvMeshOverlap = new typename Mesh::recv_overlap_type(mesh-&gt;comm(), mesh-&gt;debug());
<a name="line323">323: </a><strong><font color="#FF0000">      std:</font></strong>:map&lt;point_type,point_type&gt;&amp;            renumbering     = newMesh-&gt;getRenumbering();
<a name="line324">324: </a>      // Distribute the mesh
<a name="line325">325: </a>      Obj&lt;partition_type&gt; partition = distributeMeshV(mesh, newMesh, renumbering, sendMeshOverlap, recvMeshOverlap);
<a name="line326">326: </a>      <font color="#4169E1">if</font> (mesh-&gt;debug()) {
<a name="line327">327: </a><strong><font color="#FF0000">        std:</font></strong>:cout &lt;&lt; <font color="#666666">"["</font>&lt;&lt;mesh-&gt;commRank()&lt;&lt;<font color="#666666">"]: Mesh Renumbering:"</font> &lt;&lt; std::endl;
<a name="line328">328: </a>        <font color="#4169E1">for</font>(typename Mesh::renumbering_type::const_iterator r_iter = renumbering.begin(); r_iter != renumbering.end(); ++r_iter) {
<a name="line329">329: </a><strong><font color="#FF0000">          std:</font></strong>:cout &lt;&lt; <font color="#666666">"["</font>&lt;&lt;mesh-&gt;commRank()&lt;&lt;<font color="#666666">"]:   global point "</font> &lt;&lt; r_iter-&gt;first &lt;&lt; <font color="#666666">" --&gt; "</font> &lt;&lt; <font color="#666666">" local point "</font> &lt;&lt; r_iter-&gt;second &lt;&lt; std::endl;
<a name="line330">330: </a>        }
<a name="line331">331: </a>      }
<a name="line332">332: </a>      // Distribute the coordinates
<a name="line333">333: </a><strong><font color="#FF0000">      PETSc:</font></strong>:Log::Event(<font color="#666666">"DistributeCoords"</font>).begin();
<a name="line334">334: </a>      const Obj&lt;typename Mesh::real_section_type&gt;&amp; coordinates         = mesh-&gt;getRealSection(<font color="#666666">"coordinates"</font>);
<a name="line335">335: </a>      const Obj&lt;typename Mesh::real_section_type&gt;&amp; parallelCoordinates = newMesh-&gt;getRealSection(<font color="#666666">"coordinates"</font>);

<a name="line337">337: </a>      newMesh-&gt;setupCoordinates(parallelCoordinates);
<a name="line338">338: </a>      distributeSection(coordinates, partition, renumbering, sendMeshOverlap, recvMeshOverlap, parallelCoordinates);
<a name="line339">339: </a><strong><font color="#FF0000">      PETSc:</font></strong>:Log::Event(<font color="#666666">"DistributeCoords"</font>).end();
<a name="line340">340: </a>      // Distribute other sections
<a name="line341">341: </a>      <font color="#4169E1">if</font> (mesh-&gt;getRealSections()-&gt;size() &gt; 1) {
<a name="line342">342: </a><strong><font color="#FF0000">        PETSc:</font></strong>:Log::Event(<font color="#666666">"DistributeRealSec"</font>).begin();
<a name="line343">343: </a>        Obj&lt;std::set&lt;std::string&gt; &gt; names = mesh-&gt;getRealSections();
<a name="line344">344: </a>        int                         n     = 0;

<a name="line346">346: </a>        <font color="#4169E1">for</font>(std::set&lt;std::string&gt;::const_iterator n_iter = names-&gt;begin(); n_iter != names-&gt;end(); ++n_iter) {
<a name="line347">347: </a>          <font color="#4169E1">if</font> (*n_iter == <font color="#666666">"coordinates"</font>)   <font color="#4169E1">continue</font>;
<a name="line348">348: </a><strong><font color="#FF0000">          std:</font></strong>:cout &lt;&lt; <font color="#666666">"ERROR: Did not distribute real section "</font> &lt;&lt; *n_iter &lt;&lt; std::endl;
<a name="line349">349: </a>          ++n;
<a name="line350">350: </a>        }
<a name="line351">351: </a><strong><font color="#FF0000">        PETSc:</font></strong>:Log::Event(<font color="#666666">"DistributeRealSec"</font>).end();
<a name="line352">352: </a>        <font color="#4169E1">if</font> (n) {throw ALE::Exception(<font color="#666666">"Need to distribute more real sections"</font>);}
<a name="line353">353: </a>      }
<a name="line354">354: </a>      <font color="#4169E1">if</font> (mesh-&gt;getIntSections()-&gt;size() &gt; 0) {
<a name="line355">355: </a><strong><font color="#FF0000">        PETSc:</font></strong>:Log::Event(<font color="#666666">"DistributeIntSec"</font>).begin();
<a name="line356">356: </a>        Obj&lt;std::set&lt;std::string&gt; &gt; names = mesh-&gt;getIntSections();

<a name="line358">358: </a>        <font color="#4169E1">for</font>(std::set&lt;std::string&gt;::const_iterator n_iter = names-&gt;begin(); n_iter != names-&gt;end(); ++n_iter) {
<a name="line359">359: </a>          const Obj&lt;typename Mesh::int_section_type&gt;&amp; section    = mesh-&gt;getIntSection(*n_iter);
<a name="line360">360: </a>          const Obj&lt;typename Mesh::int_section_type&gt;&amp; newSection = newMesh-&gt;getIntSection(*n_iter);
<a name="line361">361: </a>
<a name="line362">362: </a>          // We assume all integer sections are complete sections
<a name="line363">363: </a>          newSection-&gt;setChart(newMesh-&gt;getSieve()-&gt;getChart());
<a name="line364">364: </a>          distributeSection(section, partition, renumbering, sendMeshOverlap, recvMeshOverlap, newSection);
<a name="line365">365: </a>        }
<a name="line366">366: </a><strong><font color="#FF0000">        PETSc:</font></strong>:Log::Event(<font color="#666666">"DistributeIntSec"</font>).end();
<a name="line367">367: </a>      }
<a name="line368">368: </a>      <font color="#4169E1">if</font> (mesh-&gt;getArrowSections()-&gt;size() &gt; 1) {
<a name="line369">369: </a>        throw ALE::Exception(<font color="#666666">"Need to distribute more arrow sections"</font>);
<a name="line370">370: </a>      }
<a name="line371">371: </a>      // Distribute labels
<a name="line372">372: </a><strong><font color="#FF0000">      PETSc:</font></strong>:Log::Event(<font color="#666666">"DistributeLabels"</font>).begin();
<a name="line373">373: </a>      const typename Mesh::labels_type&amp; labels = mesh-&gt;getLabels();

<a name="line375">375: </a>      <font color="#4169E1">for</font>(typename Mesh::labels_type::const_iterator l_iter = labels.begin(); l_iter != labels.end(); ++l_iter) {
<a name="line376">376: </a>        <font color="#4169E1">if</font> (newMesh-&gt;hasLabel(l_iter-&gt;first)) <font color="#4169E1">continue</font>;
<a name="line377">377: </a>        const Obj&lt;typename Mesh::label_type&gt;&amp; origLabel = l_iter-&gt;second;
<a name="line378">378: </a>        const Obj&lt;typename Mesh::label_type&gt;&amp; newLabel  = newMesh-&gt;createLabel(l_iter-&gt;first);

<a name="line380">380: </a><font color="#A020F0">#ifdef IMESH_NEW_LABELS</font>
<a name="line381">381: </a>        newLabel-&gt;setChart(newMesh-&gt;getSieve()-&gt;getChart());
<a name="line382">382: </a>        // Size the local mesh
<a name="line383">383: </a><strong><font color="#FF0000">        Partitioner:</font></strong>:sizeLocalSieveV(origLabel, partition, renumbering, newLabel);
<a name="line384">384: </a>        // Create the remote meshes
<a name="line385">385: </a>        completeConesV(origLabel, newLabel, renumbering, sendMeshOverlap, recvMeshOverlap);
<a name="line386">386: </a>        // Create the local mesh
<a name="line387">387: </a><strong><font color="#FF0000">        Partitioner:</font></strong>:createLocalSieveV(origLabel, partition, renumbering, newLabel);
<a name="line388">388: </a>        newLabel-&gt;symmetrize();
<a name="line389">389: </a><font color="#A020F0">#else</font>
<a name="line390">390: </a>        distributeLabelV(newMesh-&gt;getSieve(), origLabel, partition, renumbering, sendMeshOverlap, recvMeshOverlap, newLabel);
<a name="line391">391: </a><font color="#A020F0">#endif</font>
<a name="line392">392: </a>      }
<a name="line393">393: </a><strong><font color="#FF0000">      PETSc:</font></strong>:Log::Event(<font color="#666666">"DistributeLabels"</font>).end();
<a name="line394">394: </a>      // Create the parallel overlap
<a name="line395">395: </a><strong><font color="#FF0000">      PETSc:</font></strong>:Log::Event(<font color="#666666">"CreateOverlap"</font>).begin();
<a name="line396">396: </a>      Obj&lt;typename Mesh::send_overlap_type&gt; sendParallelMeshOverlap = newMesh-&gt;getSendOverlap();
<a name="line397">397: </a>      Obj&lt;typename Mesh::recv_overlap_type&gt; recvParallelMeshOverlap = newMesh-&gt;getRecvOverlap();
<a name="line398">398: </a>      //   Can I figure this out in a nicer way?
<a name="line399">399: </a><strong><font color="#FF0000">      ALE:</font></strong>:SetFromMap&lt;std::map&lt;point_type,point_type&gt; &gt; globalPoints(renumbering);

<a name="line401">401: </a><strong><font color="#FF0000">      ALE:</font></strong>:OverlapBuilder&lt;&gt;::constructOverlap(globalPoints, renumbering, sendParallelMeshOverlap, recvParallelMeshOverlap);
<a name="line402">402: </a>      newMesh-&gt;setCalculatedOverlap(true);
<a name="line403">403: </a><strong><font color="#FF0000">      PETSc:</font></strong>:Log::Event(<font color="#666666">"CreateOverlap"</font>).end();
<a name="line404">404: </a>    };
<a name="line405">405: </a>    template&lt;typename Label, typename Partition, typename Renumbering, typename SendOverlap, typename RecvOverlap, typename NewLabel&gt;
<a name="line406">406: </a>    static void distributeLabel(const Obj&lt;typename Mesh::sieve_type&gt;&amp; sieve, const Obj&lt;Label&gt;&amp; l, const Obj&lt;Partition&gt;&amp; partition, Renumbering&amp; renumbering, const Obj&lt;SendOverlap&gt;&amp; sendOverlap, const Obj&lt;RecvOverlap&gt;&amp; recvOverlap, const Obj&lt;NewLabel&gt;&amp; newL) {
<a name="line407">407: </a><strong><font color="#FF0000">      Partitioner:</font></strong>:createLocalSifter(l, partition, renumbering, newL);
<a name="line408">408: </a>      //completeCones(l, newL, renumbering, sendMeshOverlap, recvMeshOverlap);
<a name="line409">409: </a>      {
<a name="line410">410: </a>        <font color="#4169E1">typedef</font> ALE::UniformSection&lt;point_type, int&gt;                cones_type;
<a name="line411">411: </a>        <font color="#4169E1">typedef</font> ALE::LabelSection&lt;typename Mesh::sieve_type, Label&gt; cones_wrapper_type;
<a name="line412">412: </a>        Obj&lt;cones_wrapper_type&gt; cones        = new cones_wrapper_type(sieve, l);
<a name="line413">413: </a>        Obj&lt;cones_type&gt;         overlapCones = new cones_type(l-&gt;comm(), l-&gt;debug());

<a name="line415">415: </a><strong><font color="#FF0000">        ALE:</font></strong>:Pullback::SimpleCopy::copy(sendOverlap, recvOverlap, cones, overlapCones);
<a name="line416">416: </a>        <font color="#4169E1">if</font> (l-&gt;debug()) {overlapCones-&gt;view(<font color="#666666">"Overlap Label Values"</font>);}
<a name="line417">417: </a>        // Inserts cones into newL (must renumber here)
<a name="line418">418: </a>        //ALE::Pullback::InsertionBinaryFusion::fuse(overlapCones, recvOverlap, renumbering, newSieve);
<a name="line419">419: </a>        {
<a name="line420">420: </a>          <font color="#4169E1">typedef</font> typename cones_type::point_type overlap_point_type;
<a name="line421">421: </a>          const Obj&lt;typename RecvOverlap::traits::baseSequence&gt;      rPoints = recvOverlap-&gt;base();
<a name="line422">422: </a>          const typename RecvOverlap::traits::baseSequence::iterator rEnd    = rPoints-&gt;end();

<a name="line424">424: </a>          <font color="#4169E1">for</font>(typename RecvOverlap::traits::baseSequence::iterator p_iter = rPoints-&gt;begin(); p_iter != rEnd; ++p_iter) {
<a name="line425">425: </a>            const Obj&lt;typename RecvOverlap::coneSequence&gt;&amp; points       = recvOverlap-&gt;cone(*p_iter);
<a name="line426">426: </a>            const typename RecvOverlap::target_type&amp;       localPoint   = *p_iter;
<a name="line427">427: </a>            const typename cones_type::point_type&amp;         remotePoint  = points-&gt;begin().color();
<a name="line428">428: </a>            const overlap_point_type                       overlapPoint = overlap_point_type(remotePoint.second, remotePoint.first);
<a name="line429">429: </a>            const int                                      size         = overlapCones-&gt;getFiberDimension(overlapPoint);
<a name="line430">430: </a>            const typename cones_type::value_type         *values       = overlapCones-&gt;restrictPoint(overlapPoint);

<a name="line432">432: </a>            newL-&gt;clearCone(localPoint);
<a name="line433">433: </a>            <font color="#4169E1">for</font>(int i = 0; i &lt; size; ++i) {newL-&gt;addCone(values[i], localPoint);}
<a name="line434">434: </a>          }
<a name="line435">435: </a>        }
<a name="line436">436: </a>      }
<a name="line437">437: </a>    };
<a name="line438">438: </a>    template&lt;typename Label, typename Partition, typename Renumbering, typename SendOverlap, typename RecvOverlap, typename NewLabel&gt;
<a name="line439">439: </a>    static void distributeLabelV(const Obj&lt;typename Mesh::sieve_type&gt;&amp; sieve, const Obj&lt;Label&gt;&amp; l, const Obj&lt;Partition&gt;&amp; partition, Renumbering&amp; renumbering, const Obj&lt;SendOverlap&gt;&amp; sendOverlap, const Obj&lt;RecvOverlap&gt;&amp; recvOverlap, const Obj&lt;NewLabel&gt;&amp; newL) {
<a name="line440">440: </a><strong><font color="#FF0000">      Partitioner:</font></strong>:createLocalSifter(l, partition, renumbering, newL);
<a name="line441">441: </a>      //completeCones(l, newL, renumbering, sendMeshOverlap, recvMeshOverlap);
<a name="line442">442: </a>      {
<a name="line443">443: </a>        <font color="#4169E1">typedef</font> typename Label::alloc_type::template rebind&lt;int&gt;::other alloc_type;
<a name="line444">444: </a>        <font color="#4169E1">typedef</font> LabelBaseSectionV&lt;typename Mesh::sieve_type, Label, alloc_type&gt; atlas_type;
<a name="line445">445: </a>        <font color="#4169E1">typedef</font> ALE::UniformSection&lt;ALE::Pair&lt;int, point_type&gt;, int&gt;            cones_type;
<a name="line446">446: </a>        <font color="#4169E1">typedef</font> ALE::LabelSection&lt;typename Mesh::sieve_type, Label, alloc_type, atlas_type&gt; cones_wrapper_type;
<a name="line447">447: </a>        Obj&lt;cones_wrapper_type&gt; cones        = new cones_wrapper_type(sieve, l);
<a name="line448">448: </a>        Obj&lt;cones_type&gt;         overlapCones = new cones_type(l-&gt;comm(), l-&gt;debug());

<a name="line450">450: </a><strong><font color="#FF0000">        ALE:</font></strong>:Pullback::SimpleCopy::copy(sendOverlap, recvOverlap, cones, overlapCones);
<a name="line451">451: </a>        <font color="#4169E1">if</font> (l-&gt;debug()) {overlapCones-&gt;view(<font color="#666666">"Overlap Label Values"</font>);}
<a name="line452">452: </a>        // Inserts cones into newL (must renumber here)
<a name="line453">453: </a>        //ALE::Pullback::InsertionBinaryFusion::fuse(overlapCones, recvOverlap, renumbering, newSieve);
<a name="line454">454: </a>        {
<a name="line455">455: </a>          <font color="#4169E1">typedef</font> typename cones_type::point_type overlap_point_type;
<a name="line456">456: </a>          const Obj&lt;typename RecvOverlap::traits::baseSequence&gt; rPoints = recvOverlap-&gt;base();

<a name="line458">458: </a>          <font color="#4169E1">for</font>(typename RecvOverlap::traits::baseSequence::iterator p_iter = rPoints-&gt;begin(); p_iter != rPoints-&gt;end(); ++p_iter) {
<a name="line459">459: </a>            const Obj&lt;typename RecvOverlap::coneSequence&gt;&amp; points       = recvOverlap-&gt;cone(*p_iter);
<a name="line460">460: </a>            const typename RecvOverlap::target_type&amp;       localPoint   = *p_iter;
<a name="line461">461: </a>            const typename cones_type::point_type&amp;         remotePoint  = points-&gt;begin().color();
<a name="line462">462: </a>            const overlap_point_type                       overlapPoint = overlap_point_type(remotePoint.second, remotePoint.first);
<a name="line463">463: </a>            const int                                      size         = overlapCones-&gt;getFiberDimension(overlapPoint);
<a name="line464">464: </a>            const typename cones_type::value_type         *values       = overlapCones-&gt;restrictPoint(overlapPoint);

<a name="line466">466: </a>            newL-&gt;clearCone(localPoint);
<a name="line467">467: </a>            <font color="#4169E1">for</font>(int i = 0; i &lt; size; ++i) {newL-&gt;addCone(values[i], localPoint);}
<a name="line468">468: </a>          }
<a name="line469">469: </a>        }
<a name="line470">470: </a>      }
<a name="line471">471: </a>    };
<a name="line472">472: </a>    template&lt;typename Section, typename Partition, typename Renumbering, typename SendOverlap, typename RecvOverlap, typename NewSection&gt;
<a name="line473">473: </a>    static void distributeSection(const Obj&lt;Section&gt;&amp; s, const Obj&lt;Partition&gt;&amp; partition, Renumbering&amp; renumbering, const Obj&lt;SendOverlap&gt;&amp; sendOverlap, const Obj&lt;RecvOverlap&gt;&amp; recvOverlap, const Obj&lt;NewSection&gt;&amp; newS) {
<a name="line474">474: </a><strong><font color="#FF0000">      Partitioner:</font></strong>:createLocalSection(s, partition, renumbering, newS);
<a name="line475">475: </a><strong><font color="#FF0000">      ALE:</font></strong>:Completion::completeSection(sendOverlap, recvOverlap, s, newS);
<a name="line476">476: </a>    };
<a name="line477">477: </a>    template&lt;typename NewMesh, typename Renumbering, typename SendOverlap, typename RecvOverlap&gt;
<a name="line478">478: </a>    static Obj&lt;partition_type&gt; unifyMesh(const Obj&lt;Mesh&gt;&amp; mesh, const Obj&lt;NewMesh&gt;&amp; newMesh, Renumbering&amp; renumbering, const Obj&lt;SendOverlap&gt;&amp; sendMeshOverlap, const Obj&lt;RecvOverlap&gt;&amp; recvMeshOverlap) {
<a name="line479">479: </a>      const Obj&lt;partition_type&gt; cellPartition = new partition_type(mesh-&gt;comm(), 0, mesh-&gt;commSize(), mesh-&gt;debug());
<a name="line480">480: </a>      const Obj&lt;partition_type&gt; partition     = new partition_type(mesh-&gt;comm(), 0, mesh-&gt;commSize(), mesh-&gt;debug());
<a name="line481">481: </a>      const Obj&lt;typename Mesh::label_sequence&gt;&amp;     cells  = mesh-&gt;heightStratum(0);
<a name="line482">482: </a>      const typename Mesh::label_sequence::iterator cEnd   = cells-&gt;end();
<a name="line483">483: </a>      typename Mesh::point_type                    *values = new typename Mesh::point_type[cells-&gt;size()];
<a name="line484">484: </a>      int                                           c      = 0;

<a name="line486">486: </a>      cellPartition-&gt;setFiberDimension(0, cells-&gt;size());
<a name="line487">487: </a>      cellPartition-&gt;allocatePoint();
<a name="line488">488: </a>      <font color="#4169E1">for</font>(typename Mesh::label_sequence::iterator c_iter = cells-&gt;begin(); c_iter != cEnd; ++c_iter, ++c) {
<a name="line489">489: </a>        values[c] = *c_iter;
<a name="line490">490: </a>      }
<a name="line491">491: </a>      cellPartition-&gt;updatePoint(0, values);
<a name="line492">492: </a>      delete [] values;
<a name="line493">493: </a>      // Close the partition over sieve points
<a name="line494">494: </a><strong><font color="#FF0000">      Partitioner:</font></strong>:createPartitionClosure(mesh, cellPartition, partition);
<a name="line495">495: </a>      // Create the remote meshes
<a name="line496">496: </a>      completeMesh(mesh, partition, renumbering, newMesh, sendMeshOverlap, recvMeshOverlap);
<a name="line497">497: </a>      // Create the local mesh
<a name="line498">498: </a><strong><font color="#FF0000">      Partitioner:</font></strong>:createLocalMesh(mesh, partition, renumbering, newMesh);
<a name="line499">499: </a>      newMesh-&gt;stratify();
<a name="line500">500: </a>      newMesh-&gt;view(<font color="#666666">"Unified mesh"</font>);
<a name="line501">501: </a>      <font color="#4169E1">return</font> partition;
<a name="line502">502: </a>    };
<a name="line503">503: </a>    static Obj&lt;Mesh&gt; unifyMesh(const Obj&lt;Mesh&gt;&amp; mesh) {
<a name="line504">504: </a>      <font color="#4169E1">typedef</font> ALE::Sifter&lt;point_type,rank_type,point_type&gt; mesh_send_overlap_type;
<a name="line505">505: </a>      <font color="#4169E1">typedef</font> ALE::Sifter&lt;rank_type,point_type,point_type&gt; mesh_recv_overlap_type;
<a name="line506">506: </a>      const Obj&lt;Mesh&gt;                      newMesh         = new Mesh(mesh-&gt;comm(), mesh-&gt;getDimension(), mesh-&gt;debug());
<a name="line507">507: </a>      const Obj&lt;typename Mesh::sieve_type&gt; newSieve        = new typename Mesh::sieve_type(mesh-&gt;comm(), mesh-&gt;debug());
<a name="line508">508: </a>      const Obj&lt;mesh_send_overlap_type&gt;    sendMeshOverlap = new mesh_send_overlap_type(mesh-&gt;comm(), mesh-&gt;debug());
<a name="line509">509: </a>      const Obj&lt;mesh_recv_overlap_type&gt;    recvMeshOverlap = new mesh_recv_overlap_type(mesh-&gt;comm(), mesh-&gt;debug());
<a name="line510">510: </a><strong><font color="#FF0000">      std:</font></strong>:map&lt;point_type,point_type&gt;      renumbering;

<a name="line512">512: </a>      newMesh-&gt;setSieve(newSieve);
<a name="line513">513: </a>      const Obj&lt;partition_type&gt; partition = unifyMesh(mesh, newMesh, renumbering, sendMeshOverlap, recvMeshOverlap);
<a name="line514">514: </a>      // Unify coordinates
<a name="line515">515: </a>      const Obj&lt;typename Mesh::real_section_type&gt;&amp; coordinates    = mesh-&gt;getRealSection(<font color="#666666">"coordinates"</font>);
<a name="line516">516: </a>      const Obj&lt;typename Mesh::real_section_type&gt;&amp; newCoordinates = newMesh-&gt;getRealSection(<font color="#666666">"coordinates"</font>);

<a name="line518">518: </a>      newMesh-&gt;setupCoordinates(newCoordinates);
<a name="line519">519: </a>      distributeSection(coordinates, partition, renumbering, sendMeshOverlap, recvMeshOverlap, newCoordinates);
<a name="line520">520: </a>      // Unify labels
<a name="line521">521: </a>      const typename Mesh::labels_type&amp; labels = mesh-&gt;getLabels();

<a name="line523">523: </a>      <font color="#4169E1">for</font>(typename Mesh::labels_type::const_iterator l_iter = labels.begin(); l_iter != labels.end(); ++l_iter) {
<a name="line524">524: </a>        <font color="#4169E1">if</font> (newMesh-&gt;hasLabel(l_iter-&gt;first)) <font color="#4169E1">continue</font>;
<a name="line525">525: </a>        const Obj&lt;typename Mesh::label_type&gt;&amp; label    = l_iter-&gt;second;
<a name="line526">526: </a>        const Obj&lt;typename Mesh::label_type&gt;&amp; newLabel = newMesh-&gt;createLabel(l_iter-&gt;first);

<a name="line528">528: </a>        //completeCones(label, newLabel, renumbering, sendMeshOverlap, recvMeshOverlap);
<a name="line529">529: </a>        {
<a name="line530">530: </a>          <font color="#4169E1">typedef</font> ALE::UniformSection&lt;point_type, int&gt; cones_type;
<a name="line531">531: </a>          <font color="#4169E1">typedef</font> ALE::LabelSection&lt;typename Mesh::sieve_type,typename Mesh::label_type&gt; cones_wrapper_type;
<a name="line532">532: </a>          Obj&lt;cones_wrapper_type&gt; cones        = new cones_wrapper_type(mesh-&gt;getSieve(), label);
<a name="line533">533: </a>          Obj&lt;cones_type&gt;         overlapCones = new cones_type(label-&gt;comm(), label-&gt;debug());

<a name="line535">535: </a><strong><font color="#FF0000">          ALE:</font></strong>:Pullback::SimpleCopy::copy(sendMeshOverlap, recvMeshOverlap, cones, overlapCones);
<a name="line536">536: </a>          <font color="#4169E1">if</font> (label-&gt;debug()) {overlapCones-&gt;view(<font color="#666666">"Overlap Label Values"</font>);}
<a name="line537">537: </a>          // Inserts cones into parallelMesh (must renumber here)
<a name="line538">538: </a>          //ALE::Pullback::InsertionBinaryFusion::fuse(overlapCones, recvMeshOverlap, renumbering, newSieve);
<a name="line539">539: </a>          {
<a name="line540">540: </a>            const Obj&lt;typename mesh_recv_overlap_type::traits::baseSequence&gt; rPoints = recvMeshOverlap-&gt;base();

<a name="line542">542: </a>            <font color="#4169E1">for</font>(typename mesh_recv_overlap_type::traits::baseSequence::iterator p_iter = rPoints-&gt;begin(); p_iter != rPoints-&gt;end(); ++p_iter) {
<a name="line543">543: </a>              const Obj&lt;typename mesh_recv_overlap_type::coneSequence&gt;&amp; points      = recvMeshOverlap-&gt;cone(*p_iter);
<a name="line544">544: </a>              const typename mesh_recv_overlap_type::target_type&amp;       localPoint  = *p_iter;
<a name="line545">545: </a>              const typename cones_type::point_type&amp;                    remotePoint = points-&gt;begin().color();
<a name="line546">546: </a>              const int                                                 size        = overlapCones-&gt;getFiberDimension(remotePoint);
<a name="line547">547: </a>              const typename cones_type::value_type                    *values      = overlapCones-&gt;restrictPoint(remotePoint);

<a name="line549">549: </a>              newLabel-&gt;clearCone(localPoint);
<a name="line550">550: </a>              <font color="#4169E1">for</font>(int i = 0; i &lt; size; ++i) {newLabel-&gt;addCone(values[i], localPoint);}
<a name="line551">551: </a>            }
<a name="line552">552: </a>          }
<a name="line553">553: </a>        }
<a name="line554">554: </a>        //newLabel-&gt;add(label, newSieve);
<a name="line555">555: </a><strong><font color="#FF0000">        Partitioner:</font></strong>:createLocalSifter(label, partition, renumbering, newLabel);
<a name="line556">556: </a>        newLabel-&gt;view(l_iter-&gt;first.c_str());
<a name="line557">557: </a>      }
<a name="line558">558: </a>      <font color="#4169E1">return</font> newMesh;
<a name="line559">559: </a>    };
<a name="line560">560: </a>  };
<a name="line561">561: </a>  template&lt;typename Bundle_&gt;
<a name="line562">562: </a>  class Distribution {
<a name="line563">563: </a><strong><font color="#FF0000">  public:</font></strong>
<a name="line564">564: </a>    <font color="#4169E1">typedef</font> Bundle_                                                                     bundle_type;
<a name="line565">565: </a>    <font color="#4169E1">typedef</font> typename bundle_type::sieve_type                                            sieve_type;
<a name="line566">566: </a>    <font color="#4169E1">typedef</font> typename bundle_type::point_type                                            point_type;
<a name="line567">567: </a>    <font color="#4169E1">typedef</font> typename bundle_type::alloc_type                                            alloc_type;
<a name="line568">568: </a>    <font color="#4169E1">typedef</font> typename bundle_type::send_overlap_type                                     send_overlap_type;
<a name="line569">569: </a>    <font color="#4169E1">typedef</font> typename bundle_type::recv_overlap_type                                     recv_overlap_type;
<a name="line570">570: </a>    <font color="#4169E1">typedef</font> typename ALE::New::Completion&lt;bundle_type, typename sieve_type::point_type&gt;                            sieveCompletion;
<a name="line571">571: </a>    <font color="#4169E1">typedef</font> typename ALE::New::SectionCompletion&lt;bundle_type, typename bundle_type::real_section_type::value_type&gt; sectionCompletion;
<a name="line572">572: </a><strong><font color="#FF0000">  public:</font></strong>
<a name="line575">575: </a>    static void createPartitionOverlap(const Obj&lt;bundle_type&gt;&amp; bundle, const Obj&lt;send_overlap_type&gt;&amp; sendOverlap, const Obj&lt;recv_overlap_type&gt;&amp; recvOverlap) {
<a name="line576">576: </a>      const Obj&lt;send_overlap_type&gt;&amp; topSendOverlap = bundle-&gt;getSendOverlap();
<a name="line577">577: </a>      const Obj&lt;recv_overlap_type&gt;&amp; topRecvOverlap = bundle-&gt;getRecvOverlap();
<a name="line578">578: </a>      const Obj&lt;typename send_overlap_type::traits::baseSequence&gt; base = topSendOverlap-&gt;base();
<a name="line579">579: </a>      const Obj&lt;typename recv_overlap_type::traits::capSequence&gt;  cap  = topRecvOverlap-&gt;cap();
<a name="line580">580: </a>      const int rank = bundle-&gt;commRank();

<a name="line582">582: </a>      <font color="#4169E1">if</font> (base-&gt;empty()) {
<a name="line583">583: </a>        <font color="#4169E1">if</font> (rank == 0) {
<a name="line584">584: </a>          <font color="#4169E1">for</font>(int p = 1; p &lt; bundle-&gt;commSize(); p++) {
<a name="line585">585: </a>            // The arrow is from local partition point p (source) to remote partition point p (color) on rank p (target)
<a name="line586">586: </a>            sendOverlap-&gt;addCone(p, p, p);
<a name="line587">587: </a>          }
<a name="line588">588: </a>        }
<a name="line589">589: </a>      } <font color="#4169E1">else</font> {
<a name="line590">590: </a>        <font color="#4169E1">for</font>(typename send_overlap_type::traits::baseSequence::iterator b_iter = base-&gt;begin(); b_iter != base-&gt;end(); ++b_iter) {
<a name="line591">591: </a>          const int&amp; p = *b_iter;
<a name="line592">592: </a>          // The arrow is from local partition point p (source) to remote partition point p (color) on rank p (target)
<a name="line593">593: </a>          sendOverlap-&gt;addCone(p, p, p);
<a name="line594">594: </a>        }
<a name="line595">595: </a>      }
<a name="line596">596: </a>      <font color="#4169E1">if</font> (cap-&gt;empty()) {
<a name="line597">597: </a>        <font color="#4169E1">if</font> (rank != 0) {
<a name="line598">598: </a>          // The arrow is from local partition point rank (color) on rank 0 (source) to remote partition point rank (target)
<a name="line599">599: </a>          recvOverlap-&gt;addCone(0, rank, rank);
<a name="line600">600: </a>        }
<a name="line601">601: </a>      } <font color="#4169E1">else</font> {
<a name="line602">602: </a>        <font color="#4169E1">for</font>(typename recv_overlap_type::traits::capSequence::iterator c_iter = cap-&gt;begin(); c_iter != cap-&gt;end(); ++c_iter) {
<a name="line603">603: </a>          const int&amp; p = *c_iter;
<a name="line604">604: </a>          // The arrow is from local partition point rank (color) on rank p (source) to remote partition point rank (target)
<a name="line605">605: </a>          recvOverlap-&gt;addCone(p, rank, rank);
<a name="line606">606: </a>        }
<a name="line607">607: </a>      }
<a name="line608">608: </a>    };
<a name="line611">611: </a>    template&lt;typename Partitioner&gt;
<a name="line612">612: </a>    static typename Partitioner::part_type *createAssignment(const Obj&lt;bundle_type&gt;&amp; bundle, const int dim, const Obj&lt;send_overlap_type&gt;&amp; sendOverlap, const Obj&lt;recv_overlap_type&gt;&amp; recvOverlap, const int height = 0) {
<a name="line613">613: </a>      // 1) Form partition point overlap a priori
<a name="line614">614: </a>      createPartitionOverlap(bundle, sendOverlap, recvOverlap);
<a name="line615">615: </a>      <font color="#4169E1">if</font> (bundle-&gt;debug()) {
<a name="line616">616: </a>        sendOverlap-&gt;view(<font color="#666666">"Send overlap for partition"</font>);
<a name="line617">617: </a>        recvOverlap-&gt;view(<font color="#666666">"Receive overlap for partition"</font>);
<a name="line618">618: </a>      }
<a name="line619">619: </a>      // 2) Partition the mesh
<a name="line620">620: </a>      <font color="#4169E1">if</font> (height == 0) {
<a name="line621">621: </a>        <font color="#4169E1">return</font> Partitioner::partitionSieve(bundle, dim);
<a name="line622">622: </a>      } <font color="#4169E1">else</font> <font color="#4169E1">if</font> (height == 1) {
<a name="line623">623: </a>        <font color="#4169E1">return</font> Partitioner::partitionSieveByFace(bundle, dim);
<a name="line624">624: </a>      }
<a name="line625">625: </a>      throw ALE::Exception(<font color="#666666">"Invalid partition height"</font>);
<a name="line626">626: </a>    };
<a name="line629">629: </a>    // Partition a bundle on process 0 and scatter to all processes
<a name="line630">630: </a>    static void scatterBundle(const Obj&lt;bundle_type&gt;&amp; bundle, const int dim, const Obj&lt;bundle_type&gt;&amp; bundleNew, const Obj&lt;send_overlap_type&gt;&amp; sendOverlap, const Obj&lt;recv_overlap_type&gt;&amp; recvOverlap, const std::string&amp; partitioner, const int height = 0, const Obj&lt;bundle_type&gt;&amp; subBundle = NULL, const Obj&lt;bundle_type&gt;&amp; subBundleNew = NULL) {
<a name="line631">631: </a>      <font color="#4169E1">if</font> (height == 0) {
<a name="line632">632: </a>        <font color="#4169E1">if</font> (partitioner == <font color="#666666">"chaco"</font>) {
<a name="line633">633: </a><font color="#A020F0">#ifdef PETSC_HAVE_CHACO</font>
<a name="line634">634: </a>          <font color="#4169E1">typedef</font> typename ALE::New::Chaco::Partitioner&lt;bundle_type&gt; Partitioner;
<a name="line635">635: </a>          <font color="#4169E1">typedef</font> typename ALE::New::Partitioner&lt;bundle_type&gt;        GenPartitioner;
<a name="line636">636: </a>          <font color="#4169E1">typedef</font> typename Partitioner::part_type                    part_type;

<a name="line638">638: </a>          part_type *assignment = scatterBundle&lt;Partitioner&gt;(bundle, dim, bundleNew, sendOverlap, recvOverlap, height);
<a name="line639">639: </a>          <font color="#4169E1">if</font> (!subBundle.isNull() &amp;&amp; !subBundleNew.isNull()) {
<a name="line640">640: </a>            part_type *subAssignment = GenPartitioner::subordinatePartition(bundle, 1, subBundle, assignment);
<a name="line641">641: </a>            const Obj&lt;sieve_type&gt;&amp; sieve      = subBundle-&gt;getSieve();
<a name="line642">642: </a>            const Obj&lt;sieve_type&gt;&amp; sieveNew   = new Mesh::sieve_type(subBundle-&gt;comm(), subBundle-&gt;debug());
<a name="line643">643: </a>            const int              numCells   = subBundle-&gt;heightStratum(height)-&gt;size();

<a name="line645">645: </a>            subBundleNew-&gt;setSieve(sieveNew);
<a name="line646">646: </a><strong><font color="#FF0000">            sieveCompletion:</font></strong>:scatterSieve(subBundle, sieve, dim, sieveNew, sendOverlap, recvOverlap, height, numCells, subAssignment);
<a name="line647">647: </a>            subBundleNew-&gt;stratify();
<a name="line648">648: </a>            <font color="#4169E1">if</font> (subAssignment != NULL) delete [] subAssignment;
<a name="line649">649: </a>          }
<a name="line650">650: </a>          <font color="#4169E1">if</font> (assignment != NULL) delete [] assignment;
<a name="line651">651: </a><font color="#A020F0">#else</font>
<a name="line652">652: </a>          throw ALE::Exception(<font color="#666666">"Chaco is not installed. Reconfigure with the flag --download-chaco"</font>);
<a name="line653">653: </a><font color="#A020F0">#endif</font>
<a name="line654">654: </a>        } <font color="#4169E1">else</font> <font color="#4169E1">if</font> (partitioner == <font color="#666666">"parmetis"</font>) {
<a name="line655">655: </a><font color="#A020F0">#ifdef PETSC_HAVE_PARMETIS</font>
<a name="line656">656: </a>          <font color="#4169E1">typedef</font> typename ALE::New::ParMetis::Partitioner&lt;bundle_type&gt; Partitioner;
<a name="line657">657: </a>          <font color="#4169E1">typedef</font> typename ALE::New::Partitioner&lt;bundle_type&gt;           GenPartitioner;
<a name="line658">658: </a>          <font color="#4169E1">typedef</font> typename Partitioner::part_type                       part_type;

<a name="line660">660: </a>          part_type *assignment = scatterBundle&lt;Partitioner&gt;(bundle, dim, bundleNew, sendOverlap, recvOverlap, height);
<a name="line661">661: </a>          <font color="#4169E1">if</font> (!subBundle.isNull() &amp;&amp; !subBundleNew.isNull()) {
<a name="line662">662: </a>            part_type *subAssignment = GenPartitioner::subordinatePartition(bundle, 1, subBundle, assignment);
<a name="line663">663: </a>            const Obj&lt;sieve_type&gt;&amp; sieve      = subBundle-&gt;getSieve();
<a name="line664">664: </a>            const Obj&lt;sieve_type&gt;&amp; sieveNew   = new Mesh::sieve_type(subBundle-&gt;comm(), subBundle-&gt;debug());
<a name="line665">665: </a>            const int              numCells   = subBundle-&gt;heightStratum(height)-&gt;size();

<a name="line667">667: </a>            subBundleNew-&gt;setSieve(sieveNew);
<a name="line668">668: </a><strong><font color="#FF0000">            sieveCompletion:</font></strong>:scatterSieve(subBundle, sieve, dim, sieveNew, sendOverlap, recvOverlap, height, numCells, subAssignment);
<a name="line669">669: </a>            subBundleNew-&gt;stratify();
<a name="line670">670: </a>            <font color="#4169E1">if</font> (subAssignment != NULL) delete [] subAssignment;
<a name="line671">671: </a>          }
<a name="line672">672: </a>          <font color="#4169E1">if</font> (assignment != NULL) delete [] assignment;
<a name="line673">673: </a><font color="#A020F0">#else</font>
<a name="line674">674: </a>          throw ALE::Exception(<font color="#666666">"ParMetis is not installed. Reconfigure with the flag --download-parmetis"</font>);
<a name="line675">675: </a><font color="#A020F0">#endif</font>
<a name="line676">676: </a>        } <font color="#4169E1">else</font> {
<a name="line677">677: </a>          throw ALE::Exception(<font color="#666666">"Unknown partitioner"</font>);
<a name="line678">678: </a>        }
<a name="line679">679: </a>      } <font color="#4169E1">else</font> <font color="#4169E1">if</font> (height == 1) {
<a name="line680">680: </a>        <font color="#4169E1">if</font> (partitioner == <font color="#666666">"zoltan"</font>) {
<a name="line681">681: </a><font color="#A020F0">#ifdef PETSC_HAVE_ZOLTAN</font>
<a name="line682">682: </a>          <font color="#4169E1">typedef</font> typename ALE::New::Zoltan::Partitioner&lt;bundle_type&gt; Partitioner;
<a name="line683">683: </a>          <font color="#4169E1">typedef</font> typename Partitioner::part_type                     part_type;

<a name="line685">685: </a>          part_type *assignment = scatterBundle&lt;Partitioner&gt;(bundle, dim, bundleNew, sendOverlap, recvOverlap, height);
<a name="line686">686: </a>          <font color="#4169E1">if</font> (assignment != NULL) delete [] assignment;
<a name="line687">687: </a><font color="#A020F0">#else</font>
<a name="line688">688: </a>          throw ALE::Exception(<font color="#666666">"Zoltan is not installed. Reconfigure with the flag --download-zoltan"</font>);
<a name="line689">689: </a><font color="#A020F0">#endif</font>
<a name="line690">690: </a>        } <font color="#4169E1">else</font> <font color="#4169E1">if</font> (partitioner == <font color="#666666">"parmetis"</font>) {
<a name="line691">691: </a><font color="#A020F0">#ifdef PETSC_HAVE_PARMETIS</font>
<a name="line692">692: </a>          <font color="#4169E1">typedef</font> typename ALE::New::ParMetis::Partitioner&lt;bundle_type&gt; Partitioner;
<a name="line693">693: </a>          <font color="#4169E1">typedef</font> typename Partitioner::part_type                       part_type;

<a name="line695">695: </a>          part_type *assignment = scatterBundle&lt;Partitioner&gt;(bundle, dim, bundleNew, sendOverlap, recvOverlap, height);
<a name="line696">696: </a>          <font color="#4169E1">if</font> (assignment != NULL) delete [] assignment;
<a name="line697">697: </a><font color="#A020F0">#else</font>
<a name="line698">698: </a>          throw ALE::Exception(<font color="#666666">"ParMetis is not installed. Reconfigure with the flag --download-parmetis"</font>);
<a name="line699">699: </a><font color="#A020F0">#endif</font>
<a name="line700">700: </a>        } <font color="#4169E1">else</font> {
<a name="line701">701: </a>          throw ALE::Exception(<font color="#666666">"Unknown partitioner"</font>);
<a name="line702">702: </a>        }
<a name="line703">703: </a>      } <font color="#4169E1">else</font> {
<a name="line704">704: </a>        throw ALE::Exception(<font color="#666666">"Invalid partition height"</font>);
<a name="line705">705: </a>      }
<a name="line706">706: </a>    };
<a name="line707">707: </a>    template&lt;typename Partitioner&gt;
<a name="line708">708: </a>    static typename Partitioner::part_type *scatterBundle(const Obj&lt;bundle_type&gt;&amp; bundle, const int dim, const Obj&lt;bundle_type&gt;&amp; bundleNew, const Obj&lt;send_overlap_type&gt;&amp; sendOverlap, const Obj&lt;recv_overlap_type&gt;&amp; recvOverlap, const int height = 0) {
<a name="line709">709: </a>      typename Partitioner::part_type *assignment = createAssignment&lt;Partitioner&gt;(bundle, dim, sendOverlap, recvOverlap, height);
<a name="line710">710: </a>      const Obj&lt;sieve_type&gt;&amp;           sieve      = bundle-&gt;getSieve();
<a name="line711">711: </a>      const Obj&lt;sieve_type&gt;&amp;           sieveNew   = bundleNew-&gt;getSieve();
<a name="line712">712: </a>      const int                        numPoints  = bundle-&gt;heightStratum(height)-&gt;size();

<a name="line714">714: </a><strong><font color="#FF0000">      sieveCompletion:</font></strong>:scatterSieve(bundle, sieve, dim, sieveNew, sendOverlap, recvOverlap, height, numPoints, assignment);
<a name="line715">715: </a>      bundleNew-&gt;stratify();
<a name="line716">716: </a>      <font color="#4169E1">return</font> assignment;
<a name="line717">717: </a>    };
<a name="line720">720: </a>    static Obj&lt;ALE::Mesh&gt; distributeMesh(const Obj&lt;ALE::Mesh&gt;&amp; serialMesh, const int height = 0, const std::string&amp; partitioner = <font color="#666666">"chaco"</font>) {
<a name="line721">721: </a>      <A href="../../docs/manualpages/Sys/MPI_Comm.html#MPI_Comm">MPI_Comm</A>                          comm          = serialMesh-&gt;comm();
<a name="line722">722: </a>      const int                         dim           = serialMesh-&gt;getDimension();
<a name="line723">723: </a>      Obj&lt;ALE::Mesh&gt;                    parallelMesh  = new ALE::Mesh(comm, dim, serialMesh-&gt;debug());
<a name="line724">724: </a>      const Obj&lt;ALE::Mesh::sieve_type&gt;&amp; parallelSieve = new ALE::Mesh::sieve_type(comm, serialMesh-&gt;debug());

<a name="line726">726: </a>      ALE_LOG_EVENT_BEGIN;
<a name="line727">727: </a>      parallelMesh-&gt;setSieve(parallelSieve);
<a name="line728">728: </a>      <font color="#4169E1">if</font> (serialMesh-&gt;debug()) {serialMesh-&gt;view(<font color="#666666">"Serial mesh"</font>);}

<a name="line730">730: </a>      // Distribute cones
<a name="line731">731: </a>      Obj&lt;send_overlap_type&gt; sendOverlap = new send_overlap_type(comm, serialMesh-&gt;debug());
<a name="line732">732: </a>      Obj&lt;recv_overlap_type&gt; recvOverlap = new recv_overlap_type(comm, serialMesh-&gt;debug());
<a name="line733">733: </a>      scatterBundle(serialMesh, dim, parallelMesh, sendOverlap, recvOverlap, partitioner, height);
<a name="line734">734: </a>      parallelMesh-&gt;setDistSendOverlap(sendOverlap);
<a name="line735">735: </a>      parallelMesh-&gt;setDistRecvOverlap(recvOverlap);

<a name="line737">737: </a>      // Distribute labels
<a name="line738">738: </a>      const typename bundle_type::labels_type&amp; labels = serialMesh-&gt;getLabels();

<a name="line740">740: </a>      <font color="#4169E1">for</font>(typename bundle_type::labels_type::const_iterator l_iter = labels.begin(); l_iter != labels.end(); ++l_iter) {
<a name="line741">741: </a>        <font color="#4169E1">if</font> (parallelMesh-&gt;hasLabel(l_iter-&gt;first)) <font color="#4169E1">continue</font>;
<a name="line742">742: </a>        const Obj&lt;typename bundle_type::label_type&gt;&amp; serialLabel   = l_iter-&gt;second;
<a name="line743">743: </a>        const Obj&lt;typename bundle_type::label_type&gt;&amp; parallelLabel = parallelMesh-&gt;createLabel(l_iter-&gt;first);
<a name="line744">744: </a>        // Create local label
<a name="line745">745: </a><strong><font color="#228B22">#define NEW_LABEL</font></strong>
<a name="line746">746: </a><font color="#A020F0">#ifdef NEW_LABEL</font>
<a name="line747">747: </a>        parallelLabel-&gt;add(serialLabel, parallelSieve);
<a name="line748">748: </a><font color="#A020F0">#else</font>
<a name="line749">749: </a>        const Obj&lt;typename bundle_type::label_type::traits::baseSequence&gt;&amp; base = serialLabel-&gt;base();

<a name="line751">751: </a>        <font color="#4169E1">for</font>(typename bundle_type::label_type::traits::baseSequence::iterator b_iter = base-&gt;begin(); b_iter != base-&gt;end(); ++b_iter) {
<a name="line752">752: </a>          <font color="#4169E1">if</font> (parallelSieve-&gt;capContains(*b_iter) || parallelSieve-&gt;baseContains(*b_iter)) {
<a name="line753">753: </a>            parallelLabel-&gt;addArrow(*serialLabel-&gt;cone(*b_iter)-&gt;begin(), *b_iter);
<a name="line754">754: </a>          }
<a name="line755">755: </a>        }
<a name="line756">756: </a><font color="#A020F0">#endif</font>
<a name="line757">757: </a>        // Get remote labels
<a name="line758">758: </a><strong><font color="#FF0000">        sieveCompletion:</font></strong>:scatterCones(serialLabel, parallelLabel, sendOverlap, recvOverlap);
<a name="line759">759: </a>      }

<a name="line761">761: </a>      // Distribute sections
<a name="line762">762: </a>      Obj&lt;std::set&lt;std::string&gt; &gt; sections = serialMesh-&gt;getRealSections();

<a name="line764">764: </a>      <font color="#4169E1">for</font>(std::set&lt;std::string&gt;::iterator name = sections-&gt;begin(); name != sections-&gt;end(); ++name) {
<a name="line765">765: </a>        parallelMesh-&gt;setRealSection(*name, distributeSection(serialMesh-&gt;getRealSection(*name), parallelMesh, sendOverlap, recvOverlap));
<a name="line766">766: </a>      }
<a name="line767">767: </a>      sections = serialMesh-&gt;getIntSections();
<a name="line768">768: </a>      <font color="#4169E1">for</font>(std::set&lt;std::string&gt;::iterator name = sections-&gt;begin(); name != sections-&gt;end(); ++name) {
<a name="line769">769: </a>        parallelMesh-&gt;setIntSection(*name, distributeSection(serialMesh-&gt;getIntSection(*name), parallelMesh, sendOverlap, recvOverlap));
<a name="line770">770: </a>      }
<a name="line771">771: </a>      sections = serialMesh-&gt;getArrowSections();

<a name="line773">773: </a>      <font color="#4169E1">for</font>(std::set&lt;std::string&gt;::iterator name = sections-&gt;begin(); name != sections-&gt;end(); ++name) {
<a name="line774">774: </a>        parallelMesh-&gt;setArrowSection(*name, distributeArrowSection(serialMesh-&gt;getArrowSection(*name), serialMesh, parallelMesh, sendOverlap, recvOverlap));
<a name="line775">775: </a>      }
<a name="line776">776: </a>      <font color="#4169E1">if</font> (parallelMesh-&gt;debug()) {parallelMesh-&gt;view(<font color="#666666">"Parallel Mesh"</font>);}
<a name="line777">777: </a>      ALE_LOG_EVENT_END;
<a name="line778">778: </a>      <font color="#4169E1">return</font> parallelMesh;
<a name="line779">779: </a>    };
<a name="line782">782: </a>    template&lt;typename Section&gt;
<a name="line783">783: </a>    static void updateSectionLocal(const Obj&lt;Section&gt;&amp; oldSection, const Obj&lt;bundle_type&gt;&amp; newBundle, const Obj&lt;Section&gt;&amp; newSection) {
<a name="line784">784: </a>      const Obj&lt;typename bundle_type::sieve_type&gt;&amp;    newSieve = newBundle-&gt;getSieve();
<a name="line785">785: </a>      const typename Section::atlas_type::chart_type&amp; oldChart = oldSection-&gt;getChart();

<a name="line787">787: </a>      <font color="#4169E1">for</font>(typename Section::atlas_type::chart_type::const_iterator c_iter = oldChart.begin(); c_iter != oldChart.end(); ++c_iter) {
<a name="line788">788: </a>        <font color="#4169E1">if</font> (newSieve-&gt;capContains(*c_iter) || newSieve-&gt;baseContains(*c_iter)) {
<a name="line789">789: </a>          newSection-&gt;setFiberDimension(*c_iter, oldSection-&gt;getFiberDimension(*c_iter));
<a name="line790">790: </a>        }
<a name="line791">791: </a>      }
<a name="line792">792: </a>      newBundle-&gt;allocate(newSection);
<a name="line793">793: </a>      const typename Section::atlas_type::chart_type&amp; newChart = newSection-&gt;getChart();

<a name="line795">795: </a>      <font color="#4169E1">for</font>(typename Section::atlas_type::chart_type::const_iterator c_iter = newChart.begin(); c_iter != newChart.end(); ++c_iter) {
<a name="line796">796: </a>        newSection-&gt;updatePointAll(*c_iter, oldSection-&gt;restrictPoint(*c_iter));
<a name="line797">797: </a>      }
<a name="line798">798: </a>    };
<a name="line801">801: </a>    template&lt;typename RecvSection, typename Section&gt;
<a name="line802">802: </a>    static void updateSectionRemote(const Obj&lt;recv_overlap_type&gt;&amp; recvOverlap, const Obj&lt;RecvSection&gt;&amp; recvSection, const Obj&lt;bundle_type&gt;&amp; newBundle, const Obj&lt;Section&gt;&amp; newSection) {
<a name="line803">803: </a>      Obj&lt;typename recv_overlap_type::traits::baseSequence&gt; recvPoints = recvOverlap-&gt;base();

<a name="line805">805: </a>      <font color="#4169E1">for</font>(typename recv_overlap_type::traits::baseSequence::iterator r_iter = recvPoints-&gt;begin(); r_iter != recvPoints-&gt;end(); ++r_iter) {
<a name="line806">806: </a>        const Obj&lt;typename recv_overlap_type::traits::coneSequence&gt;&amp;     recvPatches = recvOverlap-&gt;cone(*r_iter);
<a name="line807">807: </a>        const typename recv_overlap_type::traits::coneSequence::iterator end         = recvPatches-&gt;end();

<a name="line809">809: </a>        <font color="#4169E1">for</font>(typename recv_overlap_type::traits::coneSequence::iterator p_iter = recvPatches-&gt;begin(); p_iter != end; ++p_iter) {
<a name="line810">810: </a>          newSection-&gt;addPoint(*r_iter, recvSection-&gt;getSection(*p_iter)-&gt;getFiberDimension(*r_iter));
<a name="line811">811: </a>        }
<a name="line812">812: </a>      }
<a name="line813">813: </a>      newBundle-&gt;reallocate(newSection);
<a name="line814">814: </a>      <font color="#4169E1">for</font>(typename recv_overlap_type::traits::baseSequence::iterator r_iter = recvPoints-&gt;begin(); r_iter != recvPoints-&gt;end(); ++r_iter) {
<a name="line815">815: </a>        const Obj&lt;typename recv_overlap_type::traits::coneSequence&gt;&amp;     recvPatches = recvOverlap-&gt;cone(*r_iter);
<a name="line816">816: </a>        const typename recv_overlap_type::traits::coneSequence::iterator end         = recvPatches-&gt;end();

<a name="line818">818: </a>        <font color="#4169E1">for</font>(typename recv_overlap_type::traits::coneSequence::iterator p_iter = recvPatches-&gt;begin(); p_iter != end; ++p_iter) {
<a name="line819">819: </a>          <font color="#4169E1">if</font> (recvSection-&gt;getSection(*p_iter)-&gt;getFiberDimension(*r_iter)) {
<a name="line820">820: </a>            newSection-&gt;updatePointAll(*r_iter, recvSection-&gt;getSection(*p_iter)-&gt;restrictPoint(*r_iter));
<a name="line821">821: </a>          }
<a name="line822">822: </a>        }
<a name="line823">823: </a>      }
<a name="line824">824: </a>    };
<a name="line827">827: </a>    template&lt;typename Section&gt;
<a name="line828">828: </a>    static Obj&lt;Section&gt; distributeSection(const Obj&lt;Section&gt;&amp; serialSection, const Obj&lt;bundle_type&gt;&amp; parallelBundle, const Obj&lt;send_overlap_type&gt;&amp; sendOverlap, const Obj&lt;recv_overlap_type&gt;&amp; recvOverlap) {
<a name="line829">829: </a>      <font color="#4169E1">if</font> (serialSection-&gt;debug()) {
<a name="line830">830: </a>        serialSection-&gt;view(<font color="#666666">"Serial Section"</font>);
<a name="line831">831: </a>      }
<a name="line832">832: </a>      <font color="#4169E1">typedef</font> typename alloc_type::template rebind&lt;typename Section::value_type&gt;::other value_alloc_type;
<a name="line833">833: </a>      <font color="#4169E1">typedef</font> ALE::Field&lt;send_overlap_type, int, ALE::Section&lt;point_type, typename Section::value_type, value_alloc_type&gt; &gt; send_section_type;
<a name="line834">834: </a>      <font color="#4169E1">typedef</font> ALE::Field&lt;recv_overlap_type, int, ALE::Section&lt;point_type, typename Section::value_type, value_alloc_type&gt; &gt; recv_section_type;
<a name="line835">835: </a>      <font color="#4169E1">typedef</font> ALE::New::SizeSection&lt;Section&gt; SectionSizer;
<a name="line836">836: </a>      Obj&lt;Section&gt;                 parallelSection = new Section(serialSection-&gt;comm(), serialSection-&gt;debug());
<a name="line837">837: </a>      const Obj&lt;send_section_type&gt; sendSection     = new send_section_type(serialSection-&gt;comm(), serialSection-&gt;debug());
<a name="line838">838: </a>      const Obj&lt;recv_section_type&gt; recvSection     = new recv_section_type(serialSection-&gt;comm(), sendSection-&gt;getTag(), serialSection-&gt;debug());
<a name="line839">839: </a>      const Obj&lt;SectionSizer&gt;      sizer           = new SectionSizer(serialSection);

<a name="line841">841: </a>      updateSectionLocal(serialSection, parallelBundle, parallelSection);
<a name="line842">842: </a><strong><font color="#FF0000">      sectionCompletion:</font></strong>:completeSection(sendOverlap, recvOverlap, sizer, serialSection, sendSection, recvSection);
<a name="line843">843: </a>      updateSectionRemote(recvOverlap, recvSection, parallelBundle, parallelSection);
<a name="line844">844: </a>      <font color="#4169E1">if</font> (parallelSection-&gt;debug()) {
<a name="line845">845: </a>        parallelSection-&gt;view(<font color="#666666">"Parallel Section"</font>);
<a name="line846">846: </a>      }
<a name="line847">847: </a>      <font color="#4169E1">return</font> parallelSection;
<a name="line848">848: </a>    };
<a name="line851">851: </a>    template&lt;typename Section&gt;
<a name="line852">852: </a>    static void updateArrowSectionLocal(const Obj&lt;Section&gt;&amp; oldSection, const Obj&lt;bundle_type&gt;&amp; newBundle, const Obj&lt;Section&gt;&amp; newSection) {
<a name="line853">853: </a>      const Obj&lt;typename bundle_type::sieve_type&gt;&amp;    newSieve = newBundle-&gt;getSieve();
<a name="line854">854: </a>      const typename Section::atlas_type::chart_type&amp; oldChart = oldSection-&gt;getChart();

<a name="line856">856: </a>      <font color="#4169E1">for</font>(typename Section::atlas_type::chart_type::const_iterator c_iter = oldChart.begin(); c_iter != oldChart.end(); ++c_iter) {
<a name="line857">857: </a>        // Dmitry should provide a Sieve::contains(MinimalArrow) method
<a name="line858">858: </a>        <font color="#4169E1">if</font> (newSieve-&gt;capContains(c_iter-&gt;source) &amp;&amp; newSieve-&gt;baseContains(c_iter-&gt;target)) {
<a name="line859">859: </a>          newSection-&gt;setFiberDimension(*c_iter, oldSection-&gt;getFiberDimension(*c_iter));
<a name="line860">860: </a>        }
<a name="line861">861: </a>      }
<a name="line862">862: </a>      //newBundle-&gt;allocate(newSection);
<a name="line863">863: </a>      const typename Section::atlas_type::chart_type&amp; newChart = newSection-&gt;getChart();

<a name="line865">865: </a>      <font color="#4169E1">for</font>(typename Section::atlas_type::chart_type::const_iterator c_iter = newChart.begin(); c_iter != newChart.end(); ++c_iter) {
<a name="line866">866: </a>        newSection-&gt;updatePointAll(*c_iter, oldSection-&gt;restrictPoint(*c_iter));
<a name="line867">867: </a>      }
<a name="line868">868: </a>    };
<a name="line871">871: </a>    template&lt;typename RecvSection, typename Section&gt;
<a name="line872">872: </a>    static void updateArrowSectionRemote(const Obj&lt;recv_overlap_type&gt;&amp; recvOverlap, const Obj&lt;RecvSection&gt;&amp; recvSection, const Obj&lt;bundle_type&gt;&amp; newBundle, const Obj&lt;Section&gt;&amp; newSection) {
<a name="line873">873: </a>      Obj&lt;typename recv_overlap_type::traits::baseSequence&gt; recvPoints = recvOverlap-&gt;base();

<a name="line875">875: </a>      <font color="#4169E1">for</font>(typename recv_overlap_type::traits::baseSequence::iterator r_iter = recvPoints-&gt;begin(); r_iter != recvPoints-&gt;end(); ++r_iter) {
<a name="line876">876: </a>        const Obj&lt;typename bundle_type::sieve_type::traits::coneSequence&gt;&amp;     cone = newBundle-&gt;getSieve()-&gt;cone(*r_iter);
<a name="line877">877: </a>        const typename bundle_type::sieve_type::traits::coneSequence::iterator end  = cone-&gt;end();

<a name="line879">879: </a>        <font color="#4169E1">for</font>(typename bundle_type::sieve_type::traits::coneSequence::iterator c_iter = cone-&gt;begin(); c_iter != end; ++c_iter) {
<a name="line880">880: </a>          newSection-&gt;setFiberDimension(typename Section::point_type(*c_iter, *r_iter), 1);
<a name="line881">881: </a>        }
<a name="line882">882: </a>      }
<a name="line883">883: </a>      //newBundle-&gt;reallocate(newSection);
<a name="line884">884: </a>      <font color="#4169E1">for</font>(typename recv_overlap_type::traits::baseSequence::iterator r_iter = recvPoints-&gt;begin(); r_iter != recvPoints-&gt;end(); ++r_iter) {
<a name="line885">885: </a>        const Obj&lt;typename recv_overlap_type::traits::coneSequence&gt;&amp;     recvPatches = recvOverlap-&gt;cone(*r_iter);
<a name="line886">886: </a>        const typename recv_overlap_type::traits::coneSequence::iterator recvEnd     = recvPatches-&gt;end();

<a name="line888">888: </a>        <font color="#4169E1">for</font>(typename recv_overlap_type::traits::coneSequence::iterator p_iter = recvPatches-&gt;begin(); p_iter != recvEnd; ++p_iter) {
<a name="line889">889: </a>          const Obj&lt;typename RecvSection::section_type&gt;&amp; section = recvSection-&gt;getSection(*p_iter);

<a name="line891">891: </a>          <font color="#4169E1">if</font> (section-&gt;getFiberDimension(*r_iter)) {
<a name="line892">892: </a>            const Obj&lt;typename bundle_type::sieve_type::traits::coneSequence&gt;&amp;     cone    = newBundle-&gt;getSieve()-&gt;cone(*r_iter);
<a name="line893">893: </a>            const typename bundle_type::sieve_type::traits::coneSequence::iterator end     = cone-&gt;end();
<a name="line894">894: </a>            const typename RecvSection::value_type                                *values  = section-&gt;restrictPoint(*r_iter);
<a name="line895">895: </a>            int                                                                    c       = -1;

<a name="line897">897: </a>            <font color="#4169E1">for</font>(typename bundle_type::sieve_type::traits::coneSequence::iterator c_iter = cone-&gt;begin(); c_iter != end; ++c_iter) {
<a name="line898">898: </a>              newSection-&gt;updatePoint(typename Section::point_type(*c_iter, *r_iter), &amp;values[++c]);
<a name="line899">899: </a>            }
<a name="line900">900: </a>          }
<a name="line901">901: </a>        }
<a name="line902">902: </a>      }
<a name="line903">903: </a>    };
<a name="line906">906: </a>    template&lt;typename Section&gt;
<a name="line907">907: </a>    static Obj&lt;Section&gt; distributeArrowSection(const Obj&lt;Section&gt;&amp; serialSection, const Obj&lt;bundle_type&gt;&amp; serialBundle, const Obj&lt;bundle_type&gt;&amp; parallelBundle, const Obj&lt;send_overlap_type&gt;&amp; sendOverlap, const Obj&lt;recv_overlap_type&gt;&amp; recvOverlap) {
<a name="line908">908: </a>      <font color="#4169E1">if</font> (serialSection-&gt;debug()) {
<a name="line909">909: </a>        serialSection-&gt;view(<font color="#666666">"Serial ArrowSection"</font>);
<a name="line910">910: </a>      }
<a name="line911">911: </a>      <font color="#4169E1">typedef</font> typename alloc_type::template rebind&lt;typename Section::value_type&gt;::other value_alloc_type;
<a name="line912">912: </a>      <font color="#4169E1">typedef</font> ALE::Field&lt;send_overlap_type, int, ALE::Section&lt;point_type, typename Section::value_type, value_alloc_type&gt; &gt; send_section_type;
<a name="line913">913: </a>      <font color="#4169E1">typedef</font> ALE::Field&lt;recv_overlap_type, int, ALE::Section&lt;point_type, typename Section::value_type, value_alloc_type&gt; &gt; recv_section_type;
<a name="line914">914: </a>      <font color="#4169E1">typedef</font> ALE::New::ConeSizeSection&lt;bundle_type, sieve_type&gt; SectionSizer;
<a name="line915">915: </a>      <font color="#4169E1">typedef</font> ALE::New::ArrowSection&lt;sieve_type, Section&gt;        ArrowFiller;
<a name="line916">916: </a>      Obj&lt;Section&gt;                 parallelSection = new Section(serialSection-&gt;comm(), serialSection-&gt;debug());
<a name="line917">917: </a>      const Obj&lt;send_section_type&gt; sendSection     = new send_section_type(serialSection-&gt;comm(), serialSection-&gt;debug());
<a name="line918">918: </a>      const Obj&lt;recv_section_type&gt; recvSection     = new recv_section_type(serialSection-&gt;comm(), sendSection-&gt;getTag(), serialSection-&gt;debug());
<a name="line919">919: </a>      const Obj&lt;SectionSizer&gt;      sizer           = new SectionSizer(serialBundle, serialBundle-&gt;getSieve());
<a name="line920">920: </a>      const Obj&lt;ArrowFiller&gt;       filler          = new ArrowFiller(serialBundle-&gt;getSieve(), serialSection);

<a name="line922">922: </a>      updateArrowSectionLocal(serialSection, parallelBundle, parallelSection);
<a name="line923">923: </a><strong><font color="#FF0000">      sectionCompletion:</font></strong>:completeSection(sendOverlap, recvOverlap, sizer, filler, sendSection, recvSection);
<a name="line924">924: </a>      updateArrowSectionRemote(recvOverlap, recvSection, parallelBundle, parallelSection);
<a name="line925">925: </a>      <font color="#4169E1">if</font> (parallelSection-&gt;debug()) {
<a name="line926">926: </a>        parallelSection-&gt;view(<font color="#666666">"Parallel ArrowSection"</font>);
<a name="line927">927: </a>      }
<a name="line928">928: </a>      <font color="#4169E1">return</font> parallelSection;
<a name="line929">929: </a>    };
<a name="line930">930: </a>    static void unifyBundle(const Obj&lt;bundle_type&gt;&amp; bundle, const int dim, const Obj&lt;bundle_type&gt;&amp; bundleNew, const Obj&lt;send_overlap_type&gt;&amp; sendOverlap, const Obj&lt;recv_overlap_type&gt;&amp; recvOverlap) {
<a name="line931">931: </a>      <font color="#4169E1">typedef</font> int part_type;
<a name="line932">932: </a>      const Obj&lt;sieve_type&gt;&amp; sieve    = bundle-&gt;getSieve();
<a name="line933">933: </a>      const Obj&lt;sieve_type&gt;&amp; sieveNew = bundleNew-&gt;getSieve();
<a name="line934">934: </a>      const int              rank     = bundle-&gt;commRank();
<a name="line935">935: </a>      const int              debug    = bundle-&gt;debug();

<a name="line937">937: </a>      // 1) Form partition point overlap a priori
<a name="line938">938: </a>      <font color="#4169E1">if</font> (rank == 0) {
<a name="line939">939: </a>        <font color="#4169E1">for</font>(int p = 1; p &lt; sieve-&gt;commSize(); p++) {
<a name="line940">940: </a>          // The arrow is from remote partition point 0 on rank p to local partition point 0
<a name="line941">941: </a>          recvOverlap-&gt;addCone(p, 0, 0);
<a name="line942">942: </a>        }
<a name="line943">943: </a>      } <font color="#4169E1">else</font> {
<a name="line944">944: </a>        // The arrow is from local partition point 0 to remote partition point 0 on rank 0
<a name="line945">945: </a>        sendOverlap-&gt;addCone(0, 0, 0);
<a name="line946">946: </a>      }
<a name="line947">947: </a>      <font color="#4169E1">if</font> (debug) {
<a name="line948">948: </a>        sendOverlap-&gt;view(<font color="#666666">"Send overlap for partition"</font>);
<a name="line949">949: </a>        recvOverlap-&gt;view(<font color="#666666">"Receive overlap for partition"</font>);
<a name="line950">950: </a>      }
<a name="line951">951: </a>      // 2) Partition the mesh
<a name="line952">952: </a>      int        numCells   = bundle-&gt;heightStratum(0)-&gt;size();
<a name="line953">953: </a>      part_type *assignment = new part_type[numCells];

<a name="line955">955: </a>      <font color="#4169E1">for</font>(int c = 0; c &lt; numCells; ++c) {
<a name="line956">956: </a>        assignment[c] = 0;
<a name="line957">957: </a>      }
<a name="line958">958: </a>      // 3) Scatter the sieve
<a name="line959">959: </a><strong><font color="#FF0000">      sieveCompletion:</font></strong>:scatterSieve(bundle, sieve, dim, sieveNew, sendOverlap, recvOverlap, 0, numCells, assignment);
<a name="line960">960: </a>      bundleNew-&gt;stratify();
<a name="line961">961: </a>      // 4) Cleanup
<a name="line962">962: </a>      <font color="#4169E1">if</font> (assignment != NULL) delete [] assignment;
<a name="line963">963: </a>    };
<a name="line966">966: </a>    static Obj&lt;ALE::Mesh&gt; unifyMesh(const Obj&lt;ALE::Mesh&gt;&amp; parallelMesh) {
<a name="line967">967: </a>      const int                         dim         = parallelMesh-&gt;getDimension();
<a name="line968">968: </a>      Obj&lt;ALE::Mesh&gt;                    serialMesh  = new ALE::Mesh(parallelMesh-&gt;comm(), dim, parallelMesh-&gt;debug());
<a name="line969">969: </a>      const Obj&lt;ALE::Mesh::sieve_type&gt;&amp; serialSieve = new ALE::Mesh::sieve_type(parallelMesh-&gt;comm(), parallelMesh-&gt;debug());

<a name="line971">971: </a>      ALE_LOG_EVENT_BEGIN;
<a name="line972">972: </a>      serialMesh-&gt;setSieve(serialSieve);
<a name="line973">973: </a>      <font color="#4169E1">if</font> (parallelMesh-&gt;debug()) {
<a name="line974">974: </a>        parallelMesh-&gt;view(<font color="#666666">"Parallel topology"</font>);
<a name="line975">975: </a>      }

<a name="line977">977: </a>      // Unify cones
<a name="line978">978: </a>      Obj&lt;send_overlap_type&gt; sendOverlap = new send_overlap_type(serialMesh-&gt;comm(), serialMesh-&gt;debug());
<a name="line979">979: </a>      Obj&lt;recv_overlap_type&gt; recvOverlap = new recv_overlap_type(serialMesh-&gt;comm(), serialMesh-&gt;debug());
<a name="line980">980: </a>      unifyBundle(parallelMesh, dim, serialMesh, sendOverlap, recvOverlap);
<a name="line981">981: </a>      serialMesh-&gt;setDistSendOverlap(sendOverlap);
<a name="line982">982: </a>      serialMesh-&gt;setDistRecvOverlap(recvOverlap);

<a name="line984">984: </a>      // Unify labels
<a name="line985">985: </a>      const typename bundle_type::labels_type&amp; labels = parallelMesh-&gt;getLabels();

<a name="line987">987: </a>      <font color="#4169E1">for</font>(typename bundle_type::labels_type::const_iterator l_iter = labels.begin(); l_iter != labels.end(); ++l_iter) {
<a name="line988">988: </a>        <font color="#4169E1">if</font> (serialMesh-&gt;hasLabel(l_iter-&gt;first)) <font color="#4169E1">continue</font>;
<a name="line989">989: </a>        const Obj&lt;typename bundle_type::label_type&gt;&amp; parallelLabel = l_iter-&gt;second;
<a name="line990">990: </a>        const Obj&lt;typename bundle_type::label_type&gt;&amp; serialLabel   = serialMesh-&gt;createLabel(l_iter-&gt;first);

<a name="line992">992: </a><strong><font color="#FF0000">        sieveCompletion:</font></strong>:scatterCones(parallelLabel, serialLabel, sendOverlap, recvOverlap);
<a name="line993">993: </a>      }

<a name="line995">995: </a>      // Unify coordinates
<a name="line996">996: </a>      Obj&lt;std::set&lt;std::string&gt; &gt; sections = parallelMesh-&gt;getRealSections();

<a name="line998">998: </a>      <font color="#4169E1">for</font>(std::set&lt;std::string&gt;::iterator name = sections-&gt;begin(); name != sections-&gt;end(); ++name) {
<a name="line999">999: </a>        serialMesh-&gt;setRealSection(*name, distributeSection(parallelMesh-&gt;getRealSection(*name), serialMesh, sendOverlap, recvOverlap));
<a name="line1000">1000: </a>      }
<a name="line1001">1001: </a>      sections = parallelMesh-&gt;getIntSections();
<a name="line1002">1002: </a>      <font color="#4169E1">for</font>(std::set&lt;std::string&gt;::iterator name = sections-&gt;begin(); name != sections-&gt;end(); ++name) {
<a name="line1003">1003: </a>        serialMesh-&gt;setIntSection(*name, distributeSection(parallelMesh-&gt;getIntSection(*name), serialMesh, sendOverlap, recvOverlap));
<a name="line1004">1004: </a>      }
<a name="line1005">1005: </a>      sections = parallelMesh-&gt;getArrowSections();
<a name="line1006">1006: </a>      <font color="#4169E1">for</font>(std::set&lt;std::string&gt;::iterator name = sections-&gt;begin(); name != sections-&gt;end(); ++name) {
<a name="line1007">1007: </a>        serialMesh-&gt;setArrowSection(*name, distributeArrowSection(parallelMesh-&gt;getArrowSection(*name), parallelMesh, serialMesh, sendOverlap, recvOverlap));
<a name="line1008">1008: </a>      }
<a name="line1009">1009: </a>      <font color="#4169E1">if</font> (serialMesh-&gt;debug()) {serialMesh-&gt;view(<font color="#666666">"Serial Mesh"</font>);}
<a name="line1010">1010: </a>      ALE_LOG_EVENT_END;
<a name="line1011">1011: </a>      <font color="#4169E1">return</font> serialMesh;
<a name="line1012">1012: </a>    };
<a name="line1013">1013: </a><strong><font color="#FF0000">  public:</font></strong> // Do not like these
<a name="line1016">1016: </a>    // This is just crappy. We could introduce another phase to find out exactly what
<a name="line1017">1017: </a>    //   indices people <font color="#4169E1">do</font> not have in the global order after communication
<a name="line1018">1018: </a>    template&lt;typename OrigSendOverlap, typename OrigRecvOverlap, typename SendSection, typename RecvSection&gt;
<a name="line1019">1019: </a>    static void updateOverlap(const Obj&lt;OrigSendOverlap&gt;&amp; origSendOverlap, const Obj&lt;OrigRecvOverlap&gt;&amp; origRecvOverlap, const Obj&lt;SendSection&gt;&amp; sendSection, const Obj&lt;RecvSection&gt;&amp; recvSection, const Obj&lt;send_overlap_type&gt;&amp; sendOverlap, const Obj&lt;recv_overlap_type&gt;&amp; recvOverlap) {
<a name="line1020">1020: </a>      const typename SendSection::sheaf_type&amp; sendRanks = sendSection-&gt;getPatches();
<a name="line1021">1021: </a>      const typename RecvSection::sheaf_type&amp; recvRanks = recvSection-&gt;getPatches();

<a name="line1023">1023: </a>      <font color="#4169E1">for</font>(typename SendSection::sheaf_type::const_iterator p_iter = sendRanks.begin(); p_iter != sendRanks.end(); ++p_iter) {
<a name="line1024">1024: </a>        const typename SendSection::patch_type&amp;               rank    = p_iter-&gt;first;
<a name="line1025">1025: </a>        const Obj&lt;typename SendSection::section_type&gt;&amp;        section = p_iter-&gt;second;
<a name="line1026">1026: </a>        const typename SendSection::section_type::chart_type&amp; chart   = section-&gt;getChart();

<a name="line1028">1028: </a>        <font color="#4169E1">for</font>(typename SendSection::section_type::chart_type::const_iterator b_iter = chart.begin(); b_iter != chart.end(); ++b_iter) {
<a name="line1029">1029: </a>          const typename SendSection::value_type *points = section-&gt;restrictPoint(*b_iter);
<a name="line1030">1030: </a>          const int                               size   = section-&gt;getFiberDimension(*b_iter);

<a name="line1032">1032: </a>          <font color="#4169E1">for</font>(int p = 0; p &lt; size; p++) {
<a name="line1033">1033: </a>            <font color="#4169E1">if</font> (origSendOverlap-&gt;support(points[p])-&gt;size() == 0) {
<a name="line1034">1034: </a>              sendOverlap-&gt;addArrow(points[p], rank, points[p]);
<a name="line1035">1035: </a>            }
<a name="line1036">1036: </a>          }
<a name="line1037">1037: </a>        }
<a name="line1038">1038: </a>      }
<a name="line1039">1039: </a>      <font color="#4169E1">for</font>(typename RecvSection::sheaf_type::const_iterator p_iter = recvRanks.begin(); p_iter != recvRanks.end(); ++p_iter) {
<a name="line1040">1040: </a>        const typename RecvSection::patch_type&amp;               rank    = p_iter-&gt;first;
<a name="line1041">1041: </a>        const Obj&lt;typename RecvSection::section_type&gt;&amp;        section = p_iter-&gt;second;
<a name="line1042">1042: </a>        const typename RecvSection::section_type::chart_type&amp; chart   = section-&gt;getChart();

<a name="line1044">1044: </a>        <font color="#4169E1">for</font>(typename RecvSection::section_type::chart_type::const_iterator b_iter = chart.begin(); b_iter != chart.end(); ++b_iter) {
<a name="line1045">1045: </a>          const typename RecvSection::value_type *points = section-&gt;restrictPoint(*b_iter);
<a name="line1046">1046: </a>          const int                               size   = section-&gt;getFiberDimension(*b_iter);

<a name="line1048">1048: </a>          <font color="#4169E1">for</font>(int p = 0; p &lt; size; p++) {
<a name="line1049">1049: </a>            <font color="#4169E1">if</font> (origRecvOverlap-&gt;support(rank, points[p])-&gt;size() == 0) {
<a name="line1050">1050: </a>              recvOverlap-&gt;addArrow(rank, points[p], points[p]);
<a name="line1051">1051: </a>            }
<a name="line1052">1052: </a>          }
<a name="line1053">1053: </a>        }
<a name="line1054">1054: </a>      }
<a name="line1055">1055: </a>    };
<a name="line1058">1058: </a>    template&lt;typename RecvOverlap, typename RecvSection&gt;
<a name="line1059">1059: </a>    static void updateSieve(const Obj&lt;RecvOverlap&gt;&amp; recvOverlap, const Obj&lt;RecvSection&gt;&amp; recvSection, const Obj&lt;sieve_type&gt;&amp; sieve) {
<a name="line1060">1060: </a><font color="#A020F0">#if 1</font>
<a name="line1061">1061: </a>      Obj&lt;typename RecvOverlap::traits::baseSequence&gt; recvPoints = recvOverlap-&gt;base();

<a name="line1063">1063: </a>      <font color="#4169E1">for</font>(typename RecvOverlap::traits::baseSequence::iterator p_iter = recvPoints-&gt;begin(); p_iter != recvPoints-&gt;end(); ++p_iter) {
<a name="line1064">1064: </a>        const Obj&lt;typename RecvOverlap::traits::coneSequence&gt;&amp; ranks      = recvOverlap-&gt;cone(*p_iter);
<a name="line1065">1065: </a>        const typename RecvOverlap::target_type&amp;               localPoint = *p_iter;

<a name="line1067">1067: </a>        <font color="#4169E1">for</font>(typename RecvOverlap::traits::coneSequence::iterator r_iter = ranks-&gt;begin(); r_iter != ranks-&gt;end(); ++r_iter) {
<a name="line1068">1068: </a>          const typename RecvOverlap::target_type&amp;       remotePoint = r_iter.color();
<a name="line1069">1069: </a>          const int                                      rank        = *r_iter;
<a name="line1070">1070: </a>          const Obj&lt;typename RecvSection::section_type&gt;&amp; section     = recvSection-&gt;getSection(rank);
<a name="line1071">1071: </a>          const typename RecvSection::value_type        *points      = section-&gt;restrictPoint(remotePoint);
<a name="line1072">1072: </a>          const int                                      size        = section-&gt;getFiberDimension(remotePoint);
<a name="line1073">1073: </a>          int                                            c           = 0;

<a name="line1075">1075: </a>          ///std::cout &lt;&lt; <font color="#666666">"["</font>&lt;&lt;recvSection-&gt;commRank()&lt;&lt;<font color="#666666">"]: Receiving "</font> &lt;&lt; size &lt;&lt; <font color="#666666">" points from rank "</font> &lt;&lt; rank &lt;&lt; std::endl;
<a name="line1076">1076: </a>          <font color="#4169E1">for</font>(int p = 0; p &lt; size; p++) {
<a name="line1077">1077: </a>            // rank -- remote point --&gt; local point
<a name="line1078">1078: </a>            <font color="#4169E1">if</font> (recvOverlap-&gt;support(rank, points[p])-&gt;size()) {
<a name="line1079">1079: </a>              sieve-&gt;addArrow(*recvOverlap-&gt;support(rank, points[p])-&gt;begin(), localPoint, c);
<a name="line1080">1080: </a>              ///std::cout &lt;&lt; <font color="#666666">"["</font>&lt;&lt;recvSection-&gt;commRank()&lt;&lt;<font color="#666666">"]:   1Adding arrow "</font> &lt;&lt; *recvOverlap-&gt;support(rank, points[p])-&gt;begin() &lt;&lt; <font color="#666666">"("</font>&lt;&lt;points[p]&lt;&lt;<font color="#666666">") --&gt; "</font> &lt;&lt; localPoint &lt;&lt; std::endl;
<a name="line1081">1081: </a>            } <font color="#4169E1">else</font> {
<a name="line1082">1082: </a>              sieve-&gt;addArrow(points[p], localPoint, c);
<a name="line1083">1083: </a>              ///std::cout &lt;&lt; <font color="#666666">"["</font>&lt;&lt;recvSection-&gt;commRank()&lt;&lt;<font color="#666666">"]:   2Adding arrow "</font> &lt;&lt; points[p] &lt;&lt; <font color="#666666">" --&gt; "</font> &lt;&lt; localPoint &lt;&lt; std::endl;
<a name="line1084">1084: </a>            }
<a name="line1085">1085: </a>          }
<a name="line1086">1086: </a>        }
<a name="line1087">1087: </a>      }
<a name="line1088">1088: </a><font color="#A020F0">#else</font>
<a name="line1089">1089: </a>      const typename RecvSection::sheaf_type&amp; ranks = recvSection-&gt;getPatches();

<a name="line1091">1091: </a>      <font color="#4169E1">for</font>(typename RecvSection::sheaf_type::const_iterator p_iter = ranks.begin(); p_iter != ranks.end(); ++p_iter) {
<a name="line1092">1092: </a>        const Obj&lt;typename RecvSection::section_type&gt;&amp;        section = p_iter-&gt;second;
<a name="line1093">1093: </a>        const typename RecvSection::section_type::chart_type&amp; chart   = section-&gt;getChart();

<a name="line1095">1095: </a>        <font color="#4169E1">for</font>(typename RecvSection::section_type::chart_type::const_iterator b_iter = chart.begin(); b_iter != chart.end(); ++b_iter) {
<a name="line1096">1096: </a>          const typename RecvSection::value_type *points = section-&gt;restrictPoint(*b_iter);
<a name="line1097">1097: </a>          int                                     size   = section-&gt;getFiberDimension(*b_iter);
<a name="line1098">1098: </a>          int                                     c      = 0;

<a name="line1100">1100: </a><strong><font color="#FF0000">          std:</font></strong>:cout &lt;&lt; <font color="#666666">"["</font>&lt;&lt;recvSection-&gt;commRank()&lt;&lt;<font color="#666666">"]: Receiving "</font> &lt;&lt; size &lt;&lt; <font color="#666666">" points from rank "</font> &lt;&lt; p_iter-&gt;first &lt;&lt; std::endl;
<a name="line1101">1101: </a>          <font color="#4169E1">for</font>(int p = 0; p &lt; size; p++) {
<a name="line1102">1102: </a>            //sieve-&gt;addArrow(points[p], *b_iter, c++);
<a name="line1103">1103: </a>            sieve-&gt;addArrow(points[p], *b_iter, c);
<a name="line1104">1104: </a><strong><font color="#FF0000">            std:</font></strong>:cout &lt;&lt; <font color="#666666">"["</font>&lt;&lt;recvSection-&gt;commRank()&lt;&lt;<font color="#666666">"]:   Adding arrow "</font> &lt;&lt; points[p] &lt;&lt; <font color="#666666">" --&gt; "</font> &lt;&lt; *b_iter &lt;&lt; std::endl;
<a name="line1105">1105: </a>          }
<a name="line1106">1106: </a>        }
<a name="line1107">1107: </a>      }
<a name="line1108">1108: </a><font color="#A020F0">#endif</font>
<a name="line1109">1109: </a>    };
<a name="line1112">1112: </a>    template&lt;typename SendOverlap, typename RecvOverlap, typename SendSection, typename RecvSection&gt;
<a name="line1113">1113: </a>    static void coneCompletion(const Obj&lt;SendOverlap&gt;&amp; sendOverlap, const Obj&lt;RecvOverlap&gt;&amp; recvOverlap, const Obj&lt;bundle_type&gt;&amp; bundle, const Obj&lt;SendSection&gt;&amp; sendSection, const Obj&lt;RecvSection&gt;&amp; recvSection) {
<a name="line1114">1114: </a>      <font color="#4169E1">if</font> (sendOverlap-&gt;commSize() == 1) <font color="#4169E1">return</font>;
<a name="line1115">1115: </a>      // Distribute cones
<a name="line1116">1116: </a>      const Obj&lt;sieve_type&gt;&amp;                                 sieve           = bundle-&gt;getSieve();
<a name="line1117">1117: </a>      const Obj&lt;typename sieveCompletion::topology_type&gt;     secTopology     = sieveCompletion::completion::createSendTopology(sendOverlap);
<a name="line1118">1118: </a>      const Obj&lt;typename sieveCompletion::cone_size_section&gt; coneSizeSection = new typename sieveCompletion::cone_size_section(bundle, sieve);
<a name="line1119">1119: </a>      const Obj&lt;typename sieveCompletion::cone_section&gt;      coneSection     = new typename sieveCompletion::cone_section(sieve);
<a name="line1120">1120: </a><strong><font color="#FF0000">      sieveCompletion:</font></strong>:completion::completeSection(sendOverlap, recvOverlap, coneSizeSection, coneSection, sendSection, recvSection);
<a name="line1121">1121: </a>      // Update cones
<a name="line1122">1122: </a>      updateSieve(recvOverlap, recvSection, sieve);
<a name="line1123">1123: </a>    };
<a name="line1126">1126: </a>    template&lt;typename Section&gt;
<a name="line1127">1127: </a>    static void completeSection(const Obj&lt;bundle_type&gt;&amp; bundle, const Obj&lt;Section&gt;&amp; section) {
<a name="line1128">1128: </a>      <font color="#4169E1">typedef</font> typename Distribution&lt;bundle_type&gt;::sieveCompletion sieveCompletion;
<a name="line1129">1129: </a>      <font color="#4169E1">typedef</font> typename bundle_type::send_overlap_type             send_overlap_type;
<a name="line1130">1130: </a>      <font color="#4169E1">typedef</font> typename bundle_type::recv_overlap_type             recv_overlap_type;
<a name="line1131">1131: </a>      <font color="#4169E1">typedef</font> typename Section::value_type                        value_type;
<a name="line1132">1132: </a>      <font color="#4169E1">typedef</font> typename alloc_type::template rebind&lt;typename Section::value_type&gt;::other value_alloc_type;
<a name="line1133">1133: </a>      <font color="#4169E1">typedef</font> typename ALE::Field&lt;send_overlap_type, int, ALE::Section&lt;point_type, value_type, value_alloc_type&gt; &gt; send_section_type;
<a name="line1134">1134: </a>      <font color="#4169E1">typedef</font> typename ALE::Field&lt;recv_overlap_type, int, ALE::Section&lt;point_type, value_type, value_alloc_type&gt; &gt; recv_section_type;
<a name="line1135">1135: </a>      <font color="#4169E1">typedef</font> ALE::New::SizeSection&lt;Section&gt;                                SectionSizer;
<a name="line1136">1136: </a>      const int debug = section-&gt;debug();

<a name="line1138">1138: </a>      bundle-&gt;constructOverlap();
<a name="line1139">1139: </a>      const Obj&lt;send_overlap_type&gt; sendOverlap = bundle-&gt;getSendOverlap();
<a name="line1140">1140: </a>      const Obj&lt;recv_overlap_type&gt; recvOverlap = bundle-&gt;getRecvOverlap();
<a name="line1141">1141: </a>      const Obj&lt;send_section_type&gt; sendSection = new send_section_type(section-&gt;comm(), section-&gt;debug());
<a name="line1142">1142: </a>      const Obj&lt;recv_section_type&gt; recvSection = new recv_section_type(section-&gt;comm(), sendSection-&gt;getTag(), section-&gt;debug());
<a name="line1143">1143: </a>      const Obj&lt;SectionSizer&gt;      sizer       = new SectionSizer(section);

<a name="line1145">1145: </a><strong><font color="#FF0000">      sectionCompletion:</font></strong>:completeSection(sendOverlap, recvOverlap, sizer, section, sendSection, recvSection);
<a name="line1146">1146: </a>      // Update section with remote data
<a name="line1147">1147: </a>      const Obj&lt;typename recv_overlap_type::traits::baseSequence&gt; recvPoints = bundle-&gt;getRecvOverlap()-&gt;base();

<a name="line1149">1149: </a>      <font color="#4169E1">for</font>(typename recv_overlap_type::traits::baseSequence::iterator r_iter = recvPoints-&gt;begin(); r_iter != recvPoints-&gt;end(); ++r_iter) {
<a name="line1150">1150: </a>        const Obj&lt;typename recv_overlap_type::traits::coneSequence&gt;&amp;     recvPatches = recvOverlap-&gt;cone(*r_iter);
<a name="line1151">1151: </a>        const typename recv_overlap_type::traits::coneSequence::iterator end         = recvPatches-&gt;end();

<a name="line1153">1153: </a>        <font color="#4169E1">for</font>(typename recv_overlap_type::traits::coneSequence::iterator p_iter = recvPatches-&gt;begin(); p_iter != end; ++p_iter) {
<a name="line1154">1154: </a>          <font color="#4169E1">if</font> (recvSection-&gt;getSection(*p_iter)-&gt;getFiberDimension(p_iter.color())) {
<a name="line1155">1155: </a>            <font color="#4169E1">if</font> (debug) {std::cout &lt;&lt; <font color="#666666">"["</font>&lt;&lt;section-&gt;commRank()&lt;&lt;<font color="#666666">"]Completed point "</font> &lt;&lt; *r_iter &lt;&lt; std::endl;}
<a name="line1156">1156: </a>            section-&gt;updateAddPoint(*r_iter, recvSection-&gt;getSection(*p_iter)-&gt;restrictPoint(p_iter.color()));
<a name="line1157">1157: </a>          }
<a name="line1158">1158: </a>        }
<a name="line1159">1159: </a>      }
<a name="line1160">1160: </a>    };
<a name="line1161">1161: </a>  };
<a name="line1162">1162: </a>}
<a name="line1163">1163: </a><font color="#A020F0">#endif</font>
</pre>
</body>

</html>
